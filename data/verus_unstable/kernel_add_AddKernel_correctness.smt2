(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(set-option :rewriter.sort_disjunctions false)
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) :qid prelude_fuel_defaults :skolemid skolem_prelude_fuel_defaults))))
(declare-sort Char 0)
(declare-fun char%from_unicode (Int) Char)
(declare-fun char%to_unicode (Char) Int)
(declare-sort StrSlice 0)
(declare-fun str%strslice_is_ascii (StrSlice) Bool)
(declare-fun str%strslice_len (StrSlice) Int)
(declare-fun str%strslice_get_char (StrSlice Int) Char)
(declare-fun str%new_strlit (Int) StrSlice)
(declare-fun str%from_strlit (StrSlice) Int)
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun S (StrSlice) Poly)
(declare-fun %S (Poly) StrSlice)
(declare-fun C (Char) Poly)
(declare-fun %C (Poly) Char)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const STRSLICE Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-sort Dcr 0)
(declare-const $ Dcr)
(declare-fun REF (Dcr) Dcr)
(declare-fun MUT_REF (Dcr) Dcr)
(declare-fun BOX (Dcr) Dcr)
(declare-fun RC (Dcr) Dcr)
(declare-fun ARC (Dcr) Dcr)
(declare-fun GHOST (Dcr) Dcr)
(declare-fun TRACKED (Dcr) Dcr)
(declare-fun NEVER (Dcr) Dcr)
(declare-fun ARRAY (Dcr Type Dcr Type) Type)
(declare-fun SLICE (Dcr Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (! (= i (const_int (CONST_INT i))) :pattern ((CONST_INT i)) :qid prelude_type_id_const_int :skolemid skolem_prelude_type_id_const_int)))
(assert (forall ((b Bool)) (! (has_type (B b) BOOL) :pattern ((has_type (B b) BOOL)) :qid prelude_has_type_bool :skolemid skolem_prelude_has_type_bool)))
(assert (forall ((x Poly) (t Type)) (! (and (has_type (as_type x t) t) (=> (has_type x t) (= x (as_type x t)))) :pattern ((as_type x t)) :qid prelude_as_type :skolemid skolem_prelude_as_type)))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)) :qid prelude_mk_fun :skolemid skolem_prelude_mk_fun)))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)) :qid prelude_unbox_box_bool :skolemid skolem_prelude_unbox_box_bool)))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)) :qid prelude_unbox_box_int :skolemid skolem_prelude_unbox_box_int)))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)) :qid prelude_box_unbox_bool :skolemid skolem_prelude_box_unbox_bool)))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)) :qid prelude_box_unbox_int :skolemid skolem_prelude_box_unbox_int)))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)) :qid prelude_box_unbox_nat :skolemid skolem_prelude_box_unbox_nat)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))) :qid prelude_box_unbox_uint :skolemid skolem_prelude_box_unbox_uint)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))) :qid prelude_box_unbox_sint :skolemid skolem_prelude_box_unbox_sint)))
(assert (forall ((x Int)) (! (= (str%from_strlit (str%new_strlit x)) x) :pattern ((str%new_strlit x)) :qid prelude_strlit_injective :skolemid skolem_prelude_strlit_injective)))
(assert (forall ((x Poly)) (! (=> (has_type x STRSLICE) (= x (S (%S x)))) :pattern ((has_type x STRSLICE)) :qid prelude_box_unbox_strslice :skolemid skolem_prelude_box_unbox_strslice)))
(assert (forall ((x StrSlice)) (! (= x (%S (S x))) :pattern ((S x)) :qid prelude_unbox_box_strslice :skolemid skolem_prelude_unbox_box_strslice)))
(assert (forall ((x StrSlice)) (! (has_type (S x) STRSLICE) :pattern ((has_type (S x) STRSLICE)) :qid prelude_has_type_strslice :skolemid skolem_prelude_has_type_strslice)))
(declare-fun ext_eq (Bool Type Poly Poly) Bool)
(assert (forall ((deep Bool) (t Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep t x y)) :pattern ((ext_eq deep t x y)) :qid prelude_ext_eq :skolemid skolem_prelude_ext_eq)))
(declare-const SZ Int)
(assert (or (= SZ 32) (= SZ 64)))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)) :qid prelude_nat_clip :skolemid skolem_prelude_nat_clip)))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)) :qid prelude_u_clip :skolemid skolem_prelude_u_clip)))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)) :qid prelude_i_clip :skolemid skolem_prelude_i_clip)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)) :qid prelude_u_inv :skolemid skolem_prelude_u_inv)))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)) :qid prelude_i_inv :skolemid skolem_prelude_i_inv)))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)) :qid prelude_has_type_int :skolemid skolem_prelude_has_type_int)))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)) :qid prelude_has_type_nat :skolemid skolem_prelude_has_type_nat)))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))) :qid prelude_has_type_uint :skolemid skolem_prelude_has_type_uint)))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))) :qid prelude_has_type_sint :skolemid skolem_prelude_has_type_sint)))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)) :qid prelude_unbox_int :skolemid skolem_prelude_unbox_int)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))) :qid prelude_unbox_uint :skolemid skolem_prelude_unbox_uint)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))) :qid prelude_unbox_sint :skolemid skolem_prelude_unbox_sint)))
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Add x y) (+ x y)) :pattern ((Add x y)) :qid prelude_add :skolemid skolem_prelude_add)))
(assert (forall ((x Int) (y Int)) (! (= (Sub x y) (- x y)) :pattern ((Sub x y)) :qid prelude_sub :skolemid skolem_prelude_sub)))
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)) :qid prelude_mul :skolemid skolem_prelude_mul)))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)) :qid prelude_eucdiv :skolemid skolem_prelude_eucdiv)))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)) :qid prelude_eucmod :skolemid skolem_prelude_eucmod)))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (C (%C x)))) :pattern ((has_type x CHAR)) :qid prelude_box_unbox_char :skolemid skolem_prelude_box_unbox_char)))
(assert (forall ((x Char)) (! (= x (%C (C x))) :pattern ((C x)) :qid prelude_unbox_box_char :skolemid skolem_prelude_unbox_box_char)))
(assert (forall ((x Char)) (! (has_type (C x) CHAR) :pattern ((has_type (C x) CHAR)) :qid prelude_has_type_char :skolemid skolem_prelude_has_type_char)))
(assert (forall ((x Int)) (! (= (char%to_unicode (char%from_unicode x)) x) :pattern ((char%from_unicode x)) :qid prelude_char_injective :skolemid skolem_prelude_char_injective)))
(assert (forall ((c Char)) (! (and (<= 0 (char%to_unicode c)) (< (char%to_unicode c) (uHi 32))) :pattern ((char%to_unicode c)) :qid prelude_to_unicode_bounds :skolemid skolem_prelude_to_unicode_bounds)))
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and ((_ partial-order 0) x y) (not (= x y)))) :pattern ((height_lt x y)) :qid prelude_height_lt :skolemid skolem_prelude_height_lt)))
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)) :qid prelude_check_decrease_int :skolemid skolem_prelude_check_decrease_int)))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)) :qid prelude_check_decrease_height :skolemid skolem_prelude_check_decrease_height)))
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)
(declare-fun singular_mod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (=> (not (= y 0)) (= (EucMod x y) (singular_mod x y))) :pattern ((singular_mod x y)) :qid prelude_singularmod :skolemid skolem_prelude_singularmod)))
(declare-fun closure_req (Dcr Type Dcr Type Poly Poly) Bool)
(declare-fun closure_ens (Dcr Type Dcr Type Poly Poly Poly) Bool)
(set-info :comment ";; MODULE 'kernel_add::AddKernel'")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!map.impl&%0.new. FuelId)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.impl&%0.contains_key. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_add. FuelId)
(declare-const fuel%vstd!set.impl&%0.choose. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%0.valid. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%0.to_machine. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%1.new. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.valid. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.valid_register. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.valid_instruction. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.get. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.set. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.step. FuelId)
(declare-const fuel%crate!semantics.Abstract.impl&%2.to_machine. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%0.num_blocks. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%0.valid. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%1.new. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.valid. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.valid_register. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.valid_instruction. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.valid_instructions. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.get. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.set. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.step. FuelId)
(declare-const fuel%crate!semantics.Machine.impl&%2.steps. FuelId)
(declare-const fuel%crate!semantics.MachineImplementation.impl&%0.to_machine. FuelId)
(declare-const fuel%crate!semantics.MachineImplementation.impl&%1.to_machine. FuelId)
(declare-const fuel%crate!kernel_add.AddKernel.spec_generate_block. FuelId)
(declare-const fuel%crate!kernel_add.AddKernel.spec_generate. FuelId)
(declare-const fuel%crate!kernel_add.AddKernel.parameters. FuelId)
(declare-const fuel%crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs. FuelId)
(declare-const fuel%crate!arith.product_of. FuelId)
(declare-const fuel%crate!arith.pow2. FuelId)
(declare-const fuel%crate!arith.are_valid_rns_moduli. FuelId)
(declare-const fuel%crate!semantics.impl&%0.valid. FuelId)
(declare-const fuel%crate!semantics.impl&%0.block_size. FuelId)
(assert (distinct fuel%vstd!map.impl&%0.new. fuel%vstd!map.impl&%0.spec_index. fuel%vstd!map.impl&%0.contains_key. fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.impl&%0.spec_add. fuel%vstd!set.impl&%0.choose. fuel%crate!semantics.Abstract.impl&%0.valid. fuel%crate!semantics.Abstract.impl&%0.to_machine. fuel%crate!semantics.Abstract.impl&%1.new. fuel%crate!semantics.Abstract.impl&%2.valid. fuel%crate!semantics.Abstract.impl&%2.valid_register. fuel%crate!semantics.Abstract.impl&%2.valid_instruction. fuel%crate!semantics.Abstract.impl&%2.get. fuel%crate!semantics.Abstract.impl&%2.set. fuel%crate!semantics.Abstract.impl&%2.step. fuel%crate!semantics.Abstract.impl&%2.to_machine. fuel%crate!semantics.Machine.impl&%0.num_blocks. fuel%crate!semantics.Machine.impl&%0.valid. fuel%crate!semantics.Machine.impl&%1.new. fuel%crate!semantics.Machine.impl&%2.valid. fuel%crate!semantics.Machine.impl&%2.valid_register. fuel%crate!semantics.Machine.impl&%2.valid_instruction. fuel%crate!semantics.Machine.impl&%2.valid_instructions. fuel%crate!semantics.Machine.impl&%2.get. fuel%crate!semantics.Machine.impl&%2.set. fuel%crate!semantics.Machine.impl&%2.step. fuel%crate!semantics.Machine.impl&%2.steps. fuel%crate!semantics.MachineImplementation.impl&%0.to_machine. fuel%crate!semantics.MachineImplementation.impl&%1.to_machine. fuel%crate!kernel_add.AddKernel.spec_generate_block. fuel%crate!kernel_add.AddKernel.spec_generate. fuel%crate!kernel_add.AddKernel.parameters. fuel%crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs. fuel%crate!arith.product_of. fuel%crate!arith.pow2. fuel%crate!arith.are_valid_rns_moduli. fuel%crate!semantics.impl&%0.valid. fuel%crate!semantics.impl&%0.block_size.))
(set-info :comment ";; Datatypes")
(declare-sort alloc!alloc.Global. 0)
(declare-sort alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. 0)
(declare-sort vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. 0)
(declare-sort vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. 0)
(declare-sort vstd!seq.Seq<int.>. 0)
(declare-sort vstd!seq.Seq<crate!semantics.Machine.Instruction.>. 0)
(declare-sort vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. 0)
(declare-sort vstd!seq.Seq<vstd!seq.Seq<int.>.>. 0)
(declare-sort vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. 0)
(declare-sort vstd!set.Set<i32.>. 0)
(declare-datatypes ((crate!semantics.Abstract.Polynomial. 0) (crate!semantics.Abstract.Register. 0) (crate!semantics.Abstract.Instruction. 0) (crate!semantics.Abstract.State. 0) (crate!semantics.Machine.Polynomial. 0) (crate!semantics.Machine.Register. 0) (crate!semantics.Machine.Instruction. 0) (crate!semantics.Machine.State. 0) (crate!semantics.MachineImplementation.Register. 0) (crate!semantics.MachineImplementation.Instruction. 0) (crate!semantics.Parameters. 0) (tuple%0. 0) (tuple%2. 0)) (((crate!semantics.Abstract.Polynomial./Polynomial (crate!semantics.Abstract.Polynomial./Polynomial/?log_degree Int) (crate!semantics.Abstract.Polynomial./Polynomial/?coeffs vstd!seq.Seq<int.>.))) ((crate!semantics.Abstract.Register./Register (crate!semantics.Abstract.Register./Register/?name Int))) ((crate!semantics.Abstract.Instruction./Add (crate!semantics.Abstract.Instruction./Add/?_0 Int) (crate!semantics.Abstract.Instruction./Add/?_1 crate!semantics.Abstract.Register.) (crate!semantics.Abstract.Instruction./Add/?_2 crate!semantics.Abstract.Register.) (crate!semantics.Abstract.Instruction./Add/?_3 crate!semantics.Abstract.Register.)) (crate!semantics.Abstract.Instruction./Mul (crate!semantics.Abstract.Instruction./Mul/?_0 Int) (crate!semantics.Abstract.Instruction./Mul/?_1 crate!semantics.Abstract.Register.) (crate!semantics.Abstract.Instruction./Mul/?_2 crate!semantics.Abstract.Register.) (crate!semantics.Abstract.Instruction./Mul/?_3 crate!semantics.Abstract.Register.)) (crate!semantics.Abstract.Instruction./NTT (crate!semantics.Abstract.Instruction./NTT/?_0 Int) (crate!semantics.Abstract.Instruction./NTT/?_1 crate!semantics.Abstract.Register.))) ((crate!semantics.Abstract.State./State (crate!semantics.Abstract.State./State/?params crate!semantics.Parameters.) (crate!semantics.Abstract.State./State/?registers vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.))) ((crate!semantics.Machine.Polynomial./Polynomial (crate!semantics.Machine.Polynomial./Polynomial/?log_num_blocks Int) (crate!semantics.Machine.Polynomial./Polynomial/?coeffs vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.))) ((crate!semantics.Machine.Register./Register (crate!semantics.Machine.Register./Register/?name Int) (crate!semantics.Machine.Register./Register/?rns_index Int) (crate!semantics.Machine.Register./Register/?block_index Int))) ((crate!semantics.Machine.Instruction./Add (crate!semantics.Machine.Instruction./Add/?_0 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./Add/?_1 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./Add/?_2 crate!semantics.Machine.Register.)) (crate!semantics.Machine.Instruction./Mul (crate!semantics.Machine.Instruction./Mul/?_0 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./Mul/?_1 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./Mul/?_2 crate!semantics.Machine.Register.)) (crate!semantics.Machine.Instruction./NTTStage (crate!semantics.Machine.Instruction./NTTStage/?_0 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./NTTStage/?_1 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./NTTStage/?_2 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./NTTStage/?_3 crate!semantics.Machine.Register.) (crate!semantics.Machine.Instruction./NTTStage/?_4 Int) (crate!semantics.Machine.Instruction./NTTStage/?_5 Int))) ((crate!semantics.Machine.State./State (crate!semantics.Machine.State./State/?params crate!semantics.Parameters.) (crate!semantics.Machine.State./State/?registers vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.))) ((crate!semantics.MachineImplementation.Register./Register (crate!semantics.MachineImplementation.Register./Register/?name Int) (crate!semantics.MachineImplementation.Register./Register/?rns_index Int) (crate!semantics.MachineImplementation.Register./Register/?block_index Int))) ((crate!semantics.MachineImplementation.Instruction./Add (crate!semantics.MachineImplementation.Instruction./Add/?_0 crate!semantics.MachineImplementation.Register.) (crate!semantics.MachineImplementation.Instruction./Add/?_1 crate!semantics.MachineImplementation.Register.) (crate!semantics.MachineImplementation.Instruction./Add/?_2 crate!semantics.MachineImplementation.Register.)) (crate!semantics.MachineImplementation.Instruction./Mul (crate!semantics.MachineImplementation.Instruction./Mul/?_0 crate!semantics.MachineImplementation.Register.) (crate!semantics.MachineImplementation.Instruction./Mul/?_1 crate!semantics.MachineImplementation.Register.) (crate!semantics.MachineImplementation.Instruction./Mul/?_2 crate!semantics.MachineImplementation.Register.))) ((crate!semantics.Parameters./Parameters (crate!semantics.Parameters./Parameters/?rns_moduli vstd!seq.Seq<int.>.) (crate!semantics.Parameters./Parameters/?modulus Int) (crate!semantics.Parameters./Parameters/?log_num_tiles Int) (crate!semantics.Parameters./Parameters/?log_num_rows Int) (crate!semantics.Parameters./Parameters/?log_block_size Int))) ((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?field%0 Poly) (tuple%2./tuple%2/?field%1 Poly)))))
(declare-fun crate!semantics.Abstract.Polynomial./Polynomial/log_degree (crate!semantics.Abstract.Polynomial.) Int)
(declare-fun crate!semantics.Abstract.Polynomial./Polynomial/coeffs (crate!semantics.Abstract.Polynomial.) vstd!seq.Seq<int.>.)
(declare-fun crate!semantics.Abstract.Register./Register/name (crate!semantics.Abstract.Register.) Int)
(declare-fun crate!semantics.Abstract.Instruction./Add/_0 (crate!semantics.Abstract.Instruction.) Int)
(declare-fun crate!semantics.Abstract.Instruction./Add/_1 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./Add/_2 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./Add/_3 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./Mul/_0 (crate!semantics.Abstract.Instruction.) Int)
(declare-fun crate!semantics.Abstract.Instruction./Mul/_1 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./Mul/_2 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./Mul/_3 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.Instruction./NTT/_0 (crate!semantics.Abstract.Instruction.) Int)
(declare-fun crate!semantics.Abstract.Instruction./NTT/_1 (crate!semantics.Abstract.Instruction.) crate!semantics.Abstract.Register.)
(declare-fun crate!semantics.Abstract.State./State/params (crate!semantics.Abstract.State.) crate!semantics.Parameters.)
(declare-fun crate!semantics.Abstract.State./State/registers (crate!semantics.Abstract.State.) vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.)
(declare-fun crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (crate!semantics.Machine.Polynomial.) Int)
(declare-fun crate!semantics.Machine.Polynomial./Polynomial/coeffs (crate!semantics.Machine.Polynomial.) vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.)
(declare-fun crate!semantics.Machine.Register./Register/name (crate!semantics.Machine.Register.) Int)
(declare-fun crate!semantics.Machine.Register./Register/rns_index (crate!semantics.Machine.Register.) Int)
(declare-fun crate!semantics.Machine.Register./Register/block_index (crate!semantics.Machine.Register.) Int)
(declare-fun crate!semantics.Machine.Instruction./Add/_0 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./Add/_1 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./Add/_2 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./Mul/_0 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./Mul/_1 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./Mul/_2 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_0 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_1 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_2 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_3 (crate!semantics.Machine.Instruction.) crate!semantics.Machine.Register.)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_4 (crate!semantics.Machine.Instruction.) Int)
(declare-fun crate!semantics.Machine.Instruction./NTTStage/_5 (crate!semantics.Machine.Instruction.) Int)
(declare-fun crate!semantics.Machine.State./State/params (crate!semantics.Machine.State.) crate!semantics.Parameters.)
(declare-fun crate!semantics.Machine.State./State/registers (crate!semantics.Machine.State.) vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.)
(declare-fun crate!semantics.MachineImplementation.Register./Register/name (crate!semantics.MachineImplementation.Register.) Int)
(declare-fun crate!semantics.MachineImplementation.Register./Register/rns_index (crate!semantics.MachineImplementation.Register.) Int)
(declare-fun crate!semantics.MachineImplementation.Register./Register/block_index (crate!semantics.MachineImplementation.Register.) Int)
(declare-fun crate!semantics.MachineImplementation.Instruction./Add/_0 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.MachineImplementation.Instruction./Add/_1 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.MachineImplementation.Instruction./Add/_2 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.MachineImplementation.Instruction./Mul/_0 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.MachineImplementation.Instruction./Mul/_1 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.MachineImplementation.Instruction./Mul/_2 (crate!semantics.MachineImplementation.Instruction.) crate!semantics.MachineImplementation.Register.)
(declare-fun crate!semantics.Parameters./Parameters/rns_moduli (crate!semantics.Parameters.) vstd!seq.Seq<int.>.)
(declare-fun crate!semantics.Parameters./Parameters/modulus (crate!semantics.Parameters.) Int)
(declare-fun crate!semantics.Parameters./Parameters/log_num_tiles (crate!semantics.Parameters.) Int)
(declare-fun crate!semantics.Parameters./Parameters/log_num_rows (crate!semantics.Parameters.) Int)
(declare-fun crate!semantics.Parameters./Parameters/log_block_size (crate!semantics.Parameters.) Int)
(declare-fun tuple%2./tuple%2/field%0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/field%1 (tuple%2.) Poly)
(declare-fun TYPE%fun%1. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%alloc!vec.Vec. (Dcr Type Dcr Type) Type)
(declare-const TYPE%alloc!alloc.Global. Type)
(declare-fun TYPE%vstd!map.Map. (Dcr Type Dcr Type) Type)
(declare-fun TYPE%vstd!seq.Seq. (Dcr Type) Type)
(declare-fun TYPE%vstd!set.Set. (Dcr Type) Type)
(declare-const TYPE%crate!semantics.Abstract.Polynomial. Type)
(declare-const TYPE%crate!semantics.Abstract.Register. Type)
(declare-const TYPE%crate!semantics.Abstract.Instruction. Type)
(declare-const TYPE%crate!semantics.Abstract.State. Type)
(declare-const TYPE%crate!semantics.Machine.Polynomial. Type)
(declare-const TYPE%crate!semantics.Machine.Register. Type)
(declare-const TYPE%crate!semantics.Machine.Instruction. Type)
(declare-const TYPE%crate!semantics.Machine.State. Type)
(declare-const TYPE%crate!semantics.MachineImplementation.Register. Type)
(declare-const TYPE%crate!semantics.MachineImplementation.Instruction. Type)
(declare-const TYPE%crate!semantics.Parameters. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Dcr Type Dcr Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%alloc!alloc.Global. (alloc!alloc.Global.) Poly)
(declare-fun %Poly%alloc!alloc.Global. (Poly) alloc!alloc.Global.)
(declare-fun Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. (alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.) Poly)
(declare-fun %Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. (Poly) alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.)
(declare-fun Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.) Poly)
(declare-fun %Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (Poly) vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.)
(declare-fun Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.) Poly)
(declare-fun %Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (Poly) vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.)
(declare-fun Poly%vstd!seq.Seq<int.>. (vstd!seq.Seq<int.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<int.>. (Poly) vstd!seq.Seq<int.>.)
(declare-fun Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (Poly) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(declare-fun Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. (vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. (Poly) vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>.)
(declare-fun Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. (vstd!seq.Seq<vstd!seq.Seq<int.>.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. (Poly) vstd!seq.Seq<vstd!seq.Seq<int.>.>.)
(declare-fun Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (Poly) vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.)
(declare-fun Poly%vstd!set.Set<i32.>. (vstd!set.Set<i32.>.) Poly)
(declare-fun %Poly%vstd!set.Set<i32.>. (Poly) vstd!set.Set<i32.>.)
(declare-fun Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.Polynomial.) Poly)
(declare-fun %Poly%crate!semantics.Abstract.Polynomial. (Poly) crate!semantics.Abstract.Polynomial.)
(declare-fun Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Register.) Poly)
(declare-fun %Poly%crate!semantics.Abstract.Register. (Poly) crate!semantics.Abstract.Register.)
(declare-fun Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction.) Poly)
(declare-fun %Poly%crate!semantics.Abstract.Instruction. (Poly) crate!semantics.Abstract.Instruction.)
(declare-fun Poly%crate!semantics.Abstract.State. (crate!semantics.Abstract.State.) Poly)
(declare-fun %Poly%crate!semantics.Abstract.State. (Poly) crate!semantics.Abstract.State.)
(declare-fun Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Machine.Polynomial.) Poly)
(declare-fun %Poly%crate!semantics.Machine.Polynomial. (Poly) crate!semantics.Machine.Polynomial.)
(declare-fun Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Register.) Poly)
(declare-fun %Poly%crate!semantics.Machine.Register. (Poly) crate!semantics.Machine.Register.)
(declare-fun Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction.) Poly)
(declare-fun %Poly%crate!semantics.Machine.Instruction. (Poly) crate!semantics.Machine.Instruction.)
(declare-fun Poly%crate!semantics.Machine.State. (crate!semantics.Machine.State.) Poly)
(declare-fun %Poly%crate!semantics.Machine.State. (Poly) crate!semantics.Machine.State.)
(declare-fun Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Register.) Poly)
(declare-fun %Poly%crate!semantics.MachineImplementation.Register. (Poly) crate!semantics.MachineImplementation.Register.)
(declare-fun Poly%crate!semantics.MachineImplementation.Instruction. (crate!semantics.MachineImplementation.Instruction.) Poly)
(declare-fun %Poly%crate!semantics.MachineImplementation.Instruction. (Poly) crate!semantics.MachineImplementation.Instruction.)
(declare-fun Poly%crate!semantics.Parameters. (crate!semantics.Parameters.) Poly)
(declare-fun %Poly%crate!semantics.Parameters. (Poly) crate!semantics.Parameters.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(assert (forall ((x@ %%Function%%)) (! (= x@ (%Poly%fun%1. (Poly%fun%1. x@))) :pattern ((Poly%fun%1. x@)) :qid internal_crate__fun__1_box_axiom_definition :skolemid skolem_internal_crate__fun__1_box_axiom_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (= x@ (Poly%fun%1. (%Poly%fun%1. x@)))) :pattern ((has_type x@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :qid internal_crate__fun__1_unbox_axiom_definition :skolemid skolem_internal_crate__fun__1_unbox_axiom_definition)))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x@ %%Function%%)) (! (=> (forall ((T%0@ Poly)) (! (=> (has_type T%0@ T%0&) (has_type (%%apply%%0 x@ T%0@) T%1&)) :pattern ((has_type (%%apply%%0 x@ T%0@) T%1&)) :qid internal_crate__fun__1_constructor_inner_definition :skolemid skolem_internal_crate__fun__1_constructor_inner_definition)) (has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :qid internal_crate__fun__1_constructor_definition :skolemid skolem_internal_crate__fun__1_constructor_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0@ Poly) (x@ %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0@ T%0&)) (has_type (%%apply%%0 x@ T%0@) T%1&)) :pattern ((%%apply%%0 x@ T%0@) (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :qid internal_crate__fun__1_apply_definition :skolemid skolem_internal_crate__fun__1_apply_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (T%0@ Poly) (x@ %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type T%0@ T%0&)) (height_lt (height (%%apply%%0 x@ T%0@)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x@)))))) :pattern ((height (%%apply%%0 x@ T%0@)) (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0&. T%0& T%1&. T%1&))) :qid internal_crate__fun__1_height_apply_definition :skolemid skolem_internal_crate__fun__1_height_apply_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep@ Bool) (x@ Poly) (y@ Poly)) (! (=> (and (has_type x@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (has_type y@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&)) (forall ((T%0@ Poly)) (! (=> (has_type T%0@ T%0&) (ext_eq deep@ T%1& (%%apply%%0 (%Poly%fun%1. x@) T%0@) (%%apply%%0 (%Poly%fun%1. y@) T%0@))) :pattern ((ext_eq deep@ T%1& (%%apply%%0 (%Poly%fun%1. x@) T%0@) (%%apply%%0 (%Poly%fun%1. y@) T%0@))) :qid internal_crate__fun__1_inner_ext_equal_definition :skolemid skolem_internal_crate__fun__1_inner_ext_equal_definition))) (ext_eq deep@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x@ y@)) :pattern ((ext_eq deep@ (TYPE%fun%1. T%0&. T%0& T%1&. T%1&) x@ y@)) :qid internal_crate__fun__1_ext_equal_definition :skolemid skolem_internal_crate__fun__1_ext_equal_definition)))
(assert (forall ((x@ alloc!alloc.Global.)) (! (= x@ (%Poly%alloc!alloc.Global. (Poly%alloc!alloc.Global. x@))) :pattern ((Poly%alloc!alloc.Global. x@)) :qid internal_alloc__alloc__Global_box_axiom_definition :skolemid skolem_internal_alloc__alloc__Global_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%alloc!alloc.Global.) (= x@ (Poly%alloc!alloc.Global. (%Poly%alloc!alloc.Global. x@)))) :pattern ((has_type x@ TYPE%alloc!alloc.Global.)) :qid internal_alloc__alloc__Global_unbox_axiom_definition :skolemid skolem_internal_alloc__alloc__Global_unbox_axiom_definition)))
(assert (forall ((x@ alloc!alloc.Global.)) (! (has_type (Poly%alloc!alloc.Global. x@) TYPE%alloc!alloc.Global.) :pattern ((has_type (Poly%alloc!alloc.Global. x@) TYPE%alloc!alloc.Global.)) :qid internal_alloc__alloc__Global_has_type_always_definition :skolemid skolem_internal_alloc__alloc__Global_has_type_always_definition)))
(assert (forall ((x@ alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.)) (! (= x@ (%Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. (Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. x@))) :pattern ((Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. x@)) :qid internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_box_axiom_definition :skolemid skolem_internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%alloc!vec.Vec. $ TYPE%crate!semantics.MachineImplementation.Instruction. $ TYPE%alloc!alloc.Global.)) (= x@ (Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. (%Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. x@)))) :pattern ((has_type x@ (TYPE%alloc!vec.Vec. $ TYPE%crate!semantics.MachineImplementation.Instruction. $ TYPE%alloc!alloc.Global.))) :qid internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_unbox_axiom_definition :skolemid skolem_internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_unbox_axiom_definition)))
(assert (forall ((x@ alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.)) (! (has_type (Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. x@) (TYPE%alloc!vec.Vec. $ TYPE%crate!semantics.MachineImplementation.Instruction. $ TYPE%alloc!alloc.Global.)) :pattern ((has_type (Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. x@) (TYPE%alloc!vec.Vec. $ TYPE%crate!semantics.MachineImplementation.Instruction. $ TYPE%alloc!alloc.Global.))) :qid internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_has_type_always_definition :skolemid skolem_internal_alloc__vec__Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>_has_type_always_definition)))
(assert (forall ((x@ vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.)) (! (= x@ (%Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. x@))) :pattern ((Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. x@)) :qid internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_box_axiom_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial.)) (= x@ (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (%Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial.))) :qid internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_unbox_axiom_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.)) (! (has_type (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. x@) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial.)) :pattern ((has_type (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. x@) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial.))) :qid internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_has_type_always_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Abstract.Polynomial.>_has_type_always_definition)))
(assert (forall ((x@ vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.)) (! (= x@ (%Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. x@))) :pattern ((Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. x@)) :qid internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_box_axiom_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.)) (= x@ (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (%Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.))) :qid internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_unbox_axiom_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.)) (! (has_type (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. x@) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.)) :pattern ((has_type (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. x@) (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.))) :qid internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_has_type_always_definition :skolemid skolem_internal_vstd__map__Map<i32./crate!semantics.Machine.Polynomial.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<int.>.)) (! (= x@ (%Poly%vstd!seq.Seq<int.>. (Poly%vstd!seq.Seq<int.>. x@))) :pattern ((Poly%vstd!seq.Seq<int.>. x@)) :qid internal_vstd__seq__Seq<int.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<int.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. $ INT)) (= x@ (Poly%vstd!seq.Seq<int.>. (%Poly%vstd!seq.Seq<int.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. $ INT))) :qid internal_vstd__seq__Seq<int.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<int.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<int.>.)) (! (has_type (Poly%vstd!seq.Seq<int.>. x@) (TYPE%vstd!seq.Seq. $ INT)) :pattern ((has_type (Poly%vstd!seq.Seq<int.>. x@) (TYPE%vstd!seq.Seq. $ INT))) :qid internal_vstd__seq__Seq<int.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<int.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= x@ (%Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. x@))) :pattern ((Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. x@)) :qid internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.Machine.Instruction.)) (= x@ (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (%Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.Machine.Instruction.))) :qid internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (has_type (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. x@) (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.Machine.Instruction.)) :pattern ((has_type (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. x@) (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.Machine.Instruction.))) :qid internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.Machine.Instruction.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>.)) (! (= x@ (%Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. (Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. x@))) :pattern ((Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. x@)) :qid internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.MachineImplementation.Instruction.)) (= x@ (Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. (%Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.MachineImplementation.Instruction.))) :qid internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>.)) (! (has_type (Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. x@) (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.MachineImplementation.Instruction.)) :pattern ((has_type (Poly%vstd!seq.Seq<crate!semantics.MachineImplementation.Instruction.>. x@) (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.MachineImplementation.Instruction.))) :qid internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<crate!semantics.MachineImplementation.Instruction.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<vstd!seq.Seq<int.>.>.)) (! (= x@ (%Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. (Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. x@))) :pattern ((Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. x@)) :qid internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))) (= x@ (Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. (%Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)))) :qid internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<vstd!seq.Seq<int.>.>.)) (! (has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. x@) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))) :pattern ((has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<int.>.>. x@) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)))) :qid internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<int.>.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.)) (! (= x@ (%Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. x@))) :pattern ((Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. x@)) :qid internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)))) (= x@ (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (%Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))))) :qid internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.)) (! (has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. x@) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)))) :pattern ((has_type (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. x@) (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))))) :qid internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>_has_type_always_definition)))
(assert (forall ((x@ vstd!set.Set<i32.>.)) (! (= x@ (%Poly%vstd!set.Set<i32.>. (Poly%vstd!set.Set<i32.>. x@))) :pattern ((Poly%vstd!set.Set<i32.>. x@)) :qid internal_vstd__set__Set<i32.>_box_axiom_definition :skolemid skolem_internal_vstd__set__Set<i32.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!set.Set. $ (SINT 32))) (= x@ (Poly%vstd!set.Set<i32.>. (%Poly%vstd!set.Set<i32.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!set.Set. $ (SINT 32)))) :qid internal_vstd__set__Set<i32.>_unbox_axiom_definition :skolemid skolem_internal_vstd__set__Set<i32.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!set.Set<i32.>.)) (! (has_type (Poly%vstd!set.Set<i32.>. x@) (TYPE%vstd!set.Set. $ (SINT 32))) :pattern ((has_type (Poly%vstd!set.Set<i32.>. x@) (TYPE%vstd!set.Set. $ (SINT 32)))) :qid internal_vstd__set__Set<i32.>_has_type_always_definition :skolemid skolem_internal_vstd__set__Set<i32.>_has_type_always_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Polynomial.)) (! (= x@ (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. x@))) :pattern ((Poly%crate!semantics.Abstract.Polynomial. x@)) :qid internal_crate__semantics__Abstract__Polynomial_box_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Polynomial_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Polynomial.) (= x@ (Poly%crate!semantics.Abstract.Polynomial. (%Poly%crate!semantics.Abstract.Polynomial. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Abstract.Polynomial.)) :qid internal_crate__semantics__Abstract__Polynomial_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Polynomial_unbox_axiom_definition)))
(assert (forall ((log_degree@ Int) (coeffs@ vstd!seq.Seq<int.>.)) (! (=> (<= 0 log_degree@) (has_type (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.Polynomial./Polynomial log_degree@ coeffs@)) TYPE%crate!semantics.Abstract.Polynomial.)) :pattern ((has_type (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.Polynomial./Polynomial log_degree@ coeffs@)) TYPE%crate!semantics.Abstract.Polynomial.)) :qid internal_crate!semantics.Abstract.Polynomial./Polynomial_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.Polynomial./Polynomial_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Polynomial.)) (! (= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree x@) (crate!semantics.Abstract.Polynomial./Polynomial/?log_degree x@)) :pattern ((crate!semantics.Abstract.Polynomial./Polynomial/log_degree x@)) :qid internal_crate!semantics.Abstract.Polynomial./Polynomial/log_degree_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Polynomial./Polynomial/log_degree_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Polynomial.) (<= 0 (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. x@)))) :pattern ((crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Polynomial.)) :qid internal_crate!semantics.Abstract.Polynomial./Polynomial/log_degree_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Polynomial./Polynomial/log_degree_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Polynomial.)) (! (= (crate!semantics.Abstract.Polynomial./Polynomial/coeffs x@) (crate!semantics.Abstract.Polynomial./Polynomial/?coeffs x@)) :pattern ((crate!semantics.Abstract.Polynomial./Polynomial/coeffs x@)) :qid internal_crate!semantics.Abstract.Polynomial./Polynomial/coeffs_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Polynomial./Polynomial/coeffs_accessor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Register.)) (! (= x@ (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. x@))) :pattern ((Poly%crate!semantics.Abstract.Register. x@)) :qid internal_crate__semantics__Abstract__Register_box_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Register_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Register.) (= x@ (Poly%crate!semantics.Abstract.Register. (%Poly%crate!semantics.Abstract.Register. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Abstract.Register.)) :qid internal_crate__semantics__Abstract__Register_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Register_unbox_axiom_definition)))
(assert (forall ((name@ Int)) (! (=> (iInv 32 name@) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Register./Register name@)) TYPE%crate!semantics.Abstract.Register.)) :pattern ((has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Register./Register name@)) TYPE%crate!semantics.Abstract.Register.)) :qid internal_crate!semantics.Abstract.Register./Register_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.Register./Register_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Register.)) (! (= (crate!semantics.Abstract.Register./Register/name x@) (crate!semantics.Abstract.Register./Register/?name x@)) :pattern ((crate!semantics.Abstract.Register./Register/name x@)) :qid internal_crate!semantics.Abstract.Register./Register/name_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Register./Register/name_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Register.) (iInv 32 (crate!semantics.Abstract.Register./Register/name (%Poly%crate!semantics.Abstract.Register. x@)))) :pattern ((crate!semantics.Abstract.Register./Register/name (%Poly%crate!semantics.Abstract.Register. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Register.)) :qid internal_crate!semantics.Abstract.Register./Register/name_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Register./Register/name_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= x@ (%Poly%crate!semantics.Abstract.Instruction. (Poly%crate!semantics.Abstract.Instruction. x@))) :pattern ((Poly%crate!semantics.Abstract.Instruction. x@)) :qid internal_crate__semantics__Abstract__Instruction_box_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Instruction_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (= x@ (Poly%crate!semantics.Abstract.Instruction. (%Poly%crate!semantics.Abstract.Instruction. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate__semantics__Abstract__Instruction_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__Instruction_unbox_axiom_definition)))
(assert (forall ((_0@ Int) (_1@ crate!semantics.Abstract.Register.) (_2@ crate!semantics.Abstract.Register.) (_3@ crate!semantics.Abstract.Register.)) (! (=> (and (<= 0 _0@) (has_type (Poly%crate!semantics.Abstract.Register. _1@) TYPE%crate!semantics.Abstract.Register.) (has_type (Poly%crate!semantics.Abstract.Register. _2@) TYPE%crate!semantics.Abstract.Register.) (has_type (Poly%crate!semantics.Abstract.Register. _3@) TYPE%crate!semantics.Abstract.Register.)) (has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Add _0@ _1@ _2@ _3@)) TYPE%crate!semantics.Abstract.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Add _0@ _1@ _2@ _3@)) TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Add_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Add/_0 x@) (crate!semantics.Abstract.Instruction./Add/?_0 x@)) :pattern ((crate!semantics.Abstract.Instruction./Add/_0 x@)) :qid internal_crate!semantics.Abstract.Instruction./Add/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (<= 0 (crate!semantics.Abstract.Instruction./Add/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)))) :pattern ((crate!semantics.Abstract.Instruction./Add/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Add/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Add/_1 x@) (crate!semantics.Abstract.Instruction./Add/?_1 x@)) :pattern ((crate!semantics.Abstract.Instruction./Add/_1 x@)) :qid internal_crate!semantics.Abstract.Instruction./Add/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Add/_1 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Add/_1 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Add/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Add/_2 x@) (crate!semantics.Abstract.Instruction./Add/?_2 x@)) :pattern ((crate!semantics.Abstract.Instruction./Add/_2 x@)) :qid internal_crate!semantics.Abstract.Instruction./Add/_2_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Add/_2 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Add/_2 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Add/_2_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_2_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Add/_3 x@) (crate!semantics.Abstract.Instruction./Add/?_3 x@)) :pattern ((crate!semantics.Abstract.Instruction./Add/_3 x@)) :qid internal_crate!semantics.Abstract.Instruction./Add/_3_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_3_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Add/_3 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Add/_3 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Add/_3_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Add/_3_invariant_definition)))
(assert (forall ((_0@ Int) (_1@ crate!semantics.Abstract.Register.) (_2@ crate!semantics.Abstract.Register.) (_3@ crate!semantics.Abstract.Register.)) (! (=> (and (<= 0 _0@) (has_type (Poly%crate!semantics.Abstract.Register. _1@) TYPE%crate!semantics.Abstract.Register.) (has_type (Poly%crate!semantics.Abstract.Register. _2@) TYPE%crate!semantics.Abstract.Register.) (has_type (Poly%crate!semantics.Abstract.Register. _3@) TYPE%crate!semantics.Abstract.Register.)) (has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Mul _0@ _1@ _2@ _3@)) TYPE%crate!semantics.Abstract.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Mul _0@ _1@ _2@ _3@)) TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Mul_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Mul/_0 x@) (crate!semantics.Abstract.Instruction./Mul/?_0 x@)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_0 x@)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (<= 0 (crate!semantics.Abstract.Instruction./Mul/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)))) :pattern ((crate!semantics.Abstract.Instruction./Mul/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Mul/_1 x@) (crate!semantics.Abstract.Instruction./Mul/?_1 x@)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_1 x@)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Mul/_1 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_1 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Mul/_2 x@) (crate!semantics.Abstract.Instruction./Mul/?_2 x@)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_2 x@)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_2_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Mul/_2 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_2 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_2_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_2_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./Mul/_3 x@) (crate!semantics.Abstract.Instruction./Mul/?_3 x@)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_3 x@)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_3_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_3_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./Mul/_3 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./Mul/_3 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./Mul/_3_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./Mul/_3_invariant_definition)))
(assert (forall ((_0@ Int) (_1@ crate!semantics.Abstract.Register.)) (! (=> (and (<= 0 _0@) (has_type (Poly%crate!semantics.Abstract.Register. _1@) TYPE%crate!semantics.Abstract.Register.)) (has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./NTT _0@ _1@)) TYPE%crate!semantics.Abstract.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./NTT _0@ _1@)) TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./NTT_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./NTT_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./NTT/_0 x@) (crate!semantics.Abstract.Instruction./NTT/?_0 x@)) :pattern ((crate!semantics.Abstract.Instruction./NTT/_0 x@)) :qid internal_crate!semantics.Abstract.Instruction./NTT/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./NTT/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (<= 0 (crate!semantics.Abstract.Instruction./NTT/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)))) :pattern ((crate!semantics.Abstract.Instruction./NTT/_0 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./NTT/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./NTT/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.Instruction.)) (! (= (crate!semantics.Abstract.Instruction./NTT/_1 x@) (crate!semantics.Abstract.Instruction./NTT/?_1 x@)) :pattern ((crate!semantics.Abstract.Instruction./NTT/_1 x@)) :qid internal_crate!semantics.Abstract.Instruction./NTT/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./NTT/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.Instruction.) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.Instruction./NTT/_1 (%Poly%crate!semantics.Abstract.Instruction. x@))) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.Instruction./NTT/_1 (%Poly%crate!semantics.Abstract.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Abstract.Instruction.)) :qid internal_crate!semantics.Abstract.Instruction./NTT/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.Instruction./NTT/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.State.)) (! (= x@ (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. x@))) :pattern ((Poly%crate!semantics.Abstract.State. x@)) :qid internal_crate__semantics__Abstract__State_box_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__State_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.State.) (= x@ (Poly%crate!semantics.Abstract.State. (%Poly%crate!semantics.Abstract.State. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Abstract.State.)) :qid internal_crate__semantics__Abstract__State_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Abstract__State_unbox_axiom_definition)))
(assert (forall ((params@ crate!semantics.Parameters.) (registers@ vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>.)) (! (=> (has_type (Poly%crate!semantics.Parameters. params@) TYPE%crate!semantics.Parameters.) (has_type (Poly%crate!semantics.Abstract.State. (crate!semantics.Abstract.State./State params@ registers@)) TYPE%crate!semantics.Abstract.State.)) :pattern ((has_type (Poly%crate!semantics.Abstract.State. (crate!semantics.Abstract.State./State params@ registers@)) TYPE%crate!semantics.Abstract.State.)) :qid internal_crate!semantics.Abstract.State./State_constructor_definition :skolemid skolem_internal_crate!semantics.Abstract.State./State_constructor_definition)))
(assert (forall ((x@ crate!semantics.Abstract.State.)) (! (= (crate!semantics.Abstract.State./State/params x@) (crate!semantics.Abstract.State./State/?params x@)) :pattern ((crate!semantics.Abstract.State./State/params x@)) :qid internal_crate!semantics.Abstract.State./State/params_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.State./State/params_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Abstract.State.) (has_type (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. x@))) TYPE%crate!semantics.Parameters.)) :pattern ((crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. x@)) (has_type x@ TYPE%crate!semantics.Abstract.State.)) :qid internal_crate!semantics.Abstract.State./State/params_invariant_definition :skolemid skolem_internal_crate!semantics.Abstract.State./State/params_invariant_definition)))
(assert (forall ((x@ crate!semantics.Abstract.State.)) (! (= (crate!semantics.Abstract.State./State/registers x@) (crate!semantics.Abstract.State./State/?registers x@)) :pattern ((crate!semantics.Abstract.State./State/registers x@)) :qid internal_crate!semantics.Abstract.State./State/registers_accessor_definition :skolemid skolem_internal_crate!semantics.Abstract.State./State/registers_accessor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Polynomial.)) (! (= x@ (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. x@))) :pattern ((Poly%crate!semantics.Machine.Polynomial. x@)) :qid internal_crate__semantics__Machine__Polynomial_box_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Polynomial_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Polynomial.) (= x@ (Poly%crate!semantics.Machine.Polynomial. (%Poly%crate!semantics.Machine.Polynomial. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Machine.Polynomial.)) :qid internal_crate__semantics__Machine__Polynomial_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Polynomial_unbox_axiom_definition)))
(assert (forall ((log_num_blocks@ Int) (coeffs@ vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>.)) (! (=> (<= 0 log_num_blocks@) (has_type (Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Machine.Polynomial./Polynomial log_num_blocks@ coeffs@)) TYPE%crate!semantics.Machine.Polynomial.)) :pattern ((has_type (Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Machine.Polynomial./Polynomial log_num_blocks@ coeffs@)) TYPE%crate!semantics.Machine.Polynomial.)) :qid internal_crate!semantics.Machine.Polynomial./Polynomial_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.Polynomial./Polynomial_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Polynomial.)) (! (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks x@) (crate!semantics.Machine.Polynomial./Polynomial/?log_num_blocks x@)) :pattern ((crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks x@)) :qid internal_crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Polynomial.) (<= 0 (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. x@)))) :pattern ((crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. x@)) (has_type x@ TYPE%crate!semantics.Machine.Polynomial.)) :qid internal_crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Polynomial.)) (! (= (crate!semantics.Machine.Polynomial./Polynomial/coeffs x@) (crate!semantics.Machine.Polynomial./Polynomial/?coeffs x@)) :pattern ((crate!semantics.Machine.Polynomial./Polynomial/coeffs x@)) :qid internal_crate!semantics.Machine.Polynomial./Polynomial/coeffs_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Polynomial./Polynomial/coeffs_accessor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Register.)) (! (= x@ (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. x@))) :pattern ((Poly%crate!semantics.Machine.Register. x@)) :qid internal_crate__semantics__Machine__Register_box_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Register_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Register.) (= x@ (Poly%crate!semantics.Machine.Register. (%Poly%crate!semantics.Machine.Register. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Machine.Register.)) :qid internal_crate__semantics__Machine__Register_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Register_unbox_axiom_definition)))
(assert (forall ((name@ Int) (rns_index@ Int) (block_index@ Int)) (! (=> (iInv 32 name@) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Register./Register name@ rns_index@ block_index@)) TYPE%crate!semantics.Machine.Register.)) :pattern ((has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Register./Register name@ rns_index@ block_index@)) TYPE%crate!semantics.Machine.Register.)) :qid internal_crate!semantics.Machine.Register./Register_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.Register./Register_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Register.)) (! (= (crate!semantics.Machine.Register./Register/name x@) (crate!semantics.Machine.Register./Register/?name x@)) :pattern ((crate!semantics.Machine.Register./Register/name x@)) :qid internal_crate!semantics.Machine.Register./Register/name_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Register./Register/name_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Register.) (iInv 32 (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. x@)))) :pattern ((crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. x@)) (has_type x@ TYPE%crate!semantics.Machine.Register.)) :qid internal_crate!semantics.Machine.Register./Register/name_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Register./Register/name_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Register.)) (! (= (crate!semantics.Machine.Register./Register/rns_index x@) (crate!semantics.Machine.Register./Register/?rns_index x@)) :pattern ((crate!semantics.Machine.Register./Register/rns_index x@)) :qid internal_crate!semantics.Machine.Register./Register/rns_index_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Register./Register/rns_index_accessor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Register.)) (! (= (crate!semantics.Machine.Register./Register/block_index x@) (crate!semantics.Machine.Register./Register/?block_index x@)) :pattern ((crate!semantics.Machine.Register./Register/block_index x@)) :qid internal_crate!semantics.Machine.Register./Register/block_index_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Register./Register/block_index_accessor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= x@ (%Poly%crate!semantics.Machine.Instruction. (Poly%crate!semantics.Machine.Instruction. x@))) :pattern ((Poly%crate!semantics.Machine.Instruction. x@)) :qid internal_crate__semantics__Machine__Instruction_box_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Instruction_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (= x@ (Poly%crate!semantics.Machine.Instruction. (%Poly%crate!semantics.Machine.Instruction. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate__semantics__Machine__Instruction_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__Instruction_unbox_axiom_definition)))
(assert (forall ((_0@ crate!semantics.Machine.Register.) (_1@ crate!semantics.Machine.Register.) (_2@ crate!semantics.Machine.Register.)) (! (=> (and (has_type (Poly%crate!semantics.Machine.Register. _0@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _1@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _2@) TYPE%crate!semantics.Machine.Register.)) (has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./Add _0@ _1@ _2@)) TYPE%crate!semantics.Machine.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./Add _0@ _1@ _2@)) TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Add_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Add/_0 x@) (crate!semantics.Machine.Instruction./Add/?_0 x@)) :pattern ((crate!semantics.Machine.Instruction./Add/_0 x@)) :qid internal_crate!semantics.Machine.Instruction./Add/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Add/_0 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Add/_0 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Add/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Add/_1 x@) (crate!semantics.Machine.Instruction./Add/?_1 x@)) :pattern ((crate!semantics.Machine.Instruction./Add/_1 x@)) :qid internal_crate!semantics.Machine.Instruction./Add/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Add/_1 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Add/_1 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Add/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Add/_2 x@) (crate!semantics.Machine.Instruction./Add/?_2 x@)) :pattern ((crate!semantics.Machine.Instruction./Add/_2 x@)) :qid internal_crate!semantics.Machine.Instruction./Add/_2_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Add/_2 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Add/_2 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Add/_2_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Add/_2_invariant_definition)))
(assert (forall ((_0@ crate!semantics.Machine.Register.) (_1@ crate!semantics.Machine.Register.) (_2@ crate!semantics.Machine.Register.)) (! (=> (and (has_type (Poly%crate!semantics.Machine.Register. _0@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _1@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _2@) TYPE%crate!semantics.Machine.Register.)) (has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./Mul _0@ _1@ _2@)) TYPE%crate!semantics.Machine.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./Mul _0@ _1@ _2@)) TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Mul_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Mul/_0 x@) (crate!semantics.Machine.Instruction./Mul/?_0 x@)) :pattern ((crate!semantics.Machine.Instruction./Mul/_0 x@)) :qid internal_crate!semantics.Machine.Instruction./Mul/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Mul/_0 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Mul/_0 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Mul/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Mul/_1 x@) (crate!semantics.Machine.Instruction./Mul/?_1 x@)) :pattern ((crate!semantics.Machine.Instruction./Mul/_1 x@)) :qid internal_crate!semantics.Machine.Instruction./Mul/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Mul/_1 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Mul/_1 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Mul/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./Mul/_2 x@) (crate!semantics.Machine.Instruction./Mul/?_2 x@)) :pattern ((crate!semantics.Machine.Instruction./Mul/_2 x@)) :qid internal_crate!semantics.Machine.Instruction./Mul/_2_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./Mul/_2 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./Mul/_2 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./Mul/_2_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./Mul/_2_invariant_definition)))
(assert (forall ((_0@ crate!semantics.Machine.Register.) (_1@ crate!semantics.Machine.Register.) (_2@ crate!semantics.Machine.Register.) (_3@ crate!semantics.Machine.Register.) (_4@ Int) (_5@ Int)) (! (=> (and (has_type (Poly%crate!semantics.Machine.Register. _0@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _1@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _2@) TYPE%crate!semantics.Machine.Register.) (has_type (Poly%crate!semantics.Machine.Register. _3@) TYPE%crate!semantics.Machine.Register.) (<= 0 _4@) (<= 0 _5@)) (has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./NTTStage _0@ _1@ _2@ _3@ _4@ _5@)) TYPE%crate!semantics.Machine.Instruction.)) :pattern ((has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./NTTStage _0@ _1@ _2@ _3@ _4@ _5@)) TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_0 x@) (crate!semantics.Machine.Instruction./NTTStage/?_0 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_0 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_0_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./NTTStage/_0 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_0 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_0_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_1 x@) (crate!semantics.Machine.Instruction./NTTStage/?_1 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_1 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_1_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./NTTStage/_1 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_1 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_1_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_2 x@) (crate!semantics.Machine.Instruction./NTTStage/?_2 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_2 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_2_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./NTTStage/_2 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_2 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_2_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_2_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_3 x@) (crate!semantics.Machine.Instruction./NTTStage/?_3 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_3 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_3_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_3_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.Instruction./NTTStage/_3 (%Poly%crate!semantics.Machine.Instruction. x@))) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_3 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_3_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_3_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_4 x@) (crate!semantics.Machine.Instruction./NTTStage/?_4 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_4 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_4_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_4_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (<= 0 (crate!semantics.Machine.Instruction./NTTStage/_4 (%Poly%crate!semantics.Machine.Instruction. x@)))) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_4 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_4_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_4_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.Instruction.)) (! (= (crate!semantics.Machine.Instruction./NTTStage/_5 x@) (crate!semantics.Machine.Instruction./NTTStage/?_5 x@)) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_5 x@)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_5_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_5_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.Instruction.) (<= 0 (crate!semantics.Machine.Instruction./NTTStage/_5 (%Poly%crate!semantics.Machine.Instruction. x@)))) :pattern ((crate!semantics.Machine.Instruction./NTTStage/_5 (%Poly%crate!semantics.Machine.Instruction. x@)) (has_type x@ TYPE%crate!semantics.Machine.Instruction.)) :qid internal_crate!semantics.Machine.Instruction./NTTStage/_5_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.Instruction./NTTStage/_5_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.State.)) (! (= x@ (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. x@))) :pattern ((Poly%crate!semantics.Machine.State. x@)) :qid internal_crate__semantics__Machine__State_box_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__State_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.State.) (= x@ (Poly%crate!semantics.Machine.State. (%Poly%crate!semantics.Machine.State. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Machine.State.)) :qid internal_crate__semantics__Machine__State_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Machine__State_unbox_axiom_definition)))
(assert (forall ((params@ crate!semantics.Parameters.) (registers@ vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>.)) (! (=> (has_type (Poly%crate!semantics.Parameters. params@) TYPE%crate!semantics.Parameters.) (has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.State./State params@ registers@)) TYPE%crate!semantics.Machine.State.)) :pattern ((has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.State./State params@ registers@)) TYPE%crate!semantics.Machine.State.)) :qid internal_crate!semantics.Machine.State./State_constructor_definition :skolemid skolem_internal_crate!semantics.Machine.State./State_constructor_definition)))
(assert (forall ((x@ crate!semantics.Machine.State.)) (! (= (crate!semantics.Machine.State./State/params x@) (crate!semantics.Machine.State./State/?params x@)) :pattern ((crate!semantics.Machine.State./State/params x@)) :qid internal_crate!semantics.Machine.State./State/params_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.State./State/params_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Machine.State.) (has_type (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. x@))) TYPE%crate!semantics.Parameters.)) :pattern ((crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. x@)) (has_type x@ TYPE%crate!semantics.Machine.State.)) :qid internal_crate!semantics.Machine.State./State/params_invariant_definition :skolemid skolem_internal_crate!semantics.Machine.State./State/params_invariant_definition)))
(assert (forall ((x@ crate!semantics.Machine.State.)) (! (= (crate!semantics.Machine.State./State/registers x@) (crate!semantics.Machine.State./State/?registers x@)) :pattern ((crate!semantics.Machine.State./State/registers x@)) :qid internal_crate!semantics.Machine.State./State/registers_accessor_definition :skolemid skolem_internal_crate!semantics.Machine.State./State/registers_accessor_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Register.)) (! (= x@ (%Poly%crate!semantics.MachineImplementation.Register. (Poly%crate!semantics.MachineImplementation.Register. x@))) :pattern ((Poly%crate!semantics.MachineImplementation.Register. x@)) :qid internal_crate__semantics__MachineImplementation__Register_box_axiom_definition :skolemid skolem_internal_crate__semantics__MachineImplementation__Register_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.) (= x@ (Poly%crate!semantics.MachineImplementation.Register. (%Poly%crate!semantics.MachineImplementation.Register. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.MachineImplementation.Register.)) :qid internal_crate__semantics__MachineImplementation__Register_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__MachineImplementation__Register_unbox_axiom_definition)))
(assert (forall ((name@ Int) (rns_index@ Int) (block_index@ Int)) (! (=> (and (iInv 32 name@) (uInv 32 rns_index@) (uInv 32 block_index@)) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Register./Register name@ rns_index@ block_index@)) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Register./Register name@ rns_index@ block_index@)) TYPE%crate!semantics.MachineImplementation.Register.)) :qid internal_crate!semantics.MachineImplementation.Register./Register_constructor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register_constructor_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Register.)) (! (= (crate!semantics.MachineImplementation.Register./Register/name x@) (crate!semantics.MachineImplementation.Register./Register/?name x@)) :pattern ((crate!semantics.MachineImplementation.Register./Register/name x@)) :qid internal_crate!semantics.MachineImplementation.Register./Register/name_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/name_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.) (iInv 32 (crate!semantics.MachineImplementation.Register./Register/name (%Poly%crate!semantics.MachineImplementation.Register. x@)))) :pattern ((crate!semantics.MachineImplementation.Register./Register/name (%Poly%crate!semantics.MachineImplementation.Register. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.)) :qid internal_crate!semantics.MachineImplementation.Register./Register/name_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/name_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Register.)) (! (= (crate!semantics.MachineImplementation.Register./Register/rns_index x@) (crate!semantics.MachineImplementation.Register./Register/?rns_index x@)) :pattern ((crate!semantics.MachineImplementation.Register./Register/rns_index x@)) :qid internal_crate!semantics.MachineImplementation.Register./Register/rns_index_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/rns_index_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.) (uInv 32 (crate!semantics.MachineImplementation.Register./Register/rns_index (%Poly%crate!semantics.MachineImplementation.Register. x@)))) :pattern ((crate!semantics.MachineImplementation.Register./Register/rns_index (%Poly%crate!semantics.MachineImplementation.Register. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.)) :qid internal_crate!semantics.MachineImplementation.Register./Register/rns_index_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/rns_index_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Register.)) (! (= (crate!semantics.MachineImplementation.Register./Register/block_index x@) (crate!semantics.MachineImplementation.Register./Register/?block_index x@)) :pattern ((crate!semantics.MachineImplementation.Register./Register/block_index x@)) :qid internal_crate!semantics.MachineImplementation.Register./Register/block_index_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/block_index_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.) (uInv 32 (crate!semantics.MachineImplementation.Register./Register/block_index (%Poly%crate!semantics.MachineImplementation.Register. x@)))) :pattern ((crate!semantics.MachineImplementation.Register./Register/block_index (%Poly%crate!semantics.MachineImplementation.Register. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Register.)) :qid internal_crate!semantics.MachineImplementation.Register./Register/block_index_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Register./Register/block_index_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= x@ (%Poly%crate!semantics.MachineImplementation.Instruction. (Poly%crate!semantics.MachineImplementation.Instruction. x@))) :pattern ((Poly%crate!semantics.MachineImplementation.Instruction. x@)) :qid internal_crate__semantics__MachineImplementation__Instruction_box_axiom_definition :skolemid skolem_internal_crate__semantics__MachineImplementation__Instruction_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (= x@ (Poly%crate!semantics.MachineImplementation.Instruction. (%Poly%crate!semantics.MachineImplementation.Instruction. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate__semantics__MachineImplementation__Instruction_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__MachineImplementation__Instruction_unbox_axiom_definition)))
(assert (forall ((_0@ crate!semantics.MachineImplementation.Register.) (_1@ crate!semantics.MachineImplementation.Register.) (_2@ crate!semantics.MachineImplementation.Register.)) (! (=> (and (has_type (Poly%crate!semantics.MachineImplementation.Register. _0@) TYPE%crate!semantics.MachineImplementation.Register.) (has_type (Poly%crate!semantics.MachineImplementation.Register. _1@) TYPE%crate!semantics.MachineImplementation.Register.) (has_type (Poly%crate!semantics.MachineImplementation.Register. _2@) TYPE%crate!semantics.MachineImplementation.Register.)) (has_type (Poly%crate!semantics.MachineImplementation.Instruction. (crate!semantics.MachineImplementation.Instruction./Add _0@ _1@ _2@)) TYPE%crate!semantics.MachineImplementation.Instruction.)) :pattern ((has_type (Poly%crate!semantics.MachineImplementation.Instruction. (crate!semantics.MachineImplementation.Instruction./Add _0@ _1@ _2@)) TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add_constructor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add_constructor_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Add/_0 x@) (crate!semantics.MachineImplementation.Instruction./Add/?_0 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_0 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_0_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Add/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_0_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Add/_1 x@) (crate!semantics.MachineImplementation.Instruction./Add/?_1 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_1 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_1_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Add/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_1_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Add/_2 x@) (crate!semantics.MachineImplementation.Instruction./Add/?_2 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_2 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_2_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Add/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Add/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Add/_2_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Add/_2_invariant_definition)))
(assert (forall ((_0@ crate!semantics.MachineImplementation.Register.) (_1@ crate!semantics.MachineImplementation.Register.) (_2@ crate!semantics.MachineImplementation.Register.)) (! (=> (and (has_type (Poly%crate!semantics.MachineImplementation.Register. _0@) TYPE%crate!semantics.MachineImplementation.Register.) (has_type (Poly%crate!semantics.MachineImplementation.Register. _1@) TYPE%crate!semantics.MachineImplementation.Register.) (has_type (Poly%crate!semantics.MachineImplementation.Register. _2@) TYPE%crate!semantics.MachineImplementation.Register.)) (has_type (Poly%crate!semantics.MachineImplementation.Instruction. (crate!semantics.MachineImplementation.Instruction./Mul _0@ _1@ _2@)) TYPE%crate!semantics.MachineImplementation.Instruction.)) :pattern ((has_type (Poly%crate!semantics.MachineImplementation.Instruction. (crate!semantics.MachineImplementation.Instruction./Mul _0@ _1@ _2@)) TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul_constructor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul_constructor_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Mul/_0 x@) (crate!semantics.MachineImplementation.Instruction./Mul/?_0 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_0 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_0_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Mul/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_0_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_0_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Mul/_1 x@) (crate!semantics.MachineImplementation.Instruction./Mul/?_1 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_1 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_1_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_1_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Mul/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_1_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_1_invariant_definition)))
(assert (forall ((x@ crate!semantics.MachineImplementation.Instruction.)) (! (= (crate!semantics.MachineImplementation.Instruction./Mul/_2 x@) (crate!semantics.MachineImplementation.Instruction./Mul/?_2 x@)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_2 x@)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_2_accessor_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_2_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.MachineImplementation.Register. (crate!semantics.MachineImplementation.Instruction./Mul/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. x@))) TYPE%crate!semantics.MachineImplementation.Register.)) :pattern ((crate!semantics.MachineImplementation.Instruction./Mul/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. x@)) (has_type x@ TYPE%crate!semantics.MachineImplementation.Instruction.)) :qid internal_crate!semantics.MachineImplementation.Instruction./Mul/_2_invariant_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.Instruction./Mul/_2_invariant_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= x@ (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. x@))) :pattern ((Poly%crate!semantics.Parameters. x@)) :qid internal_crate__semantics__Parameters_box_axiom_definition :skolemid skolem_internal_crate__semantics__Parameters_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Parameters.) (= x@ (Poly%crate!semantics.Parameters. (%Poly%crate!semantics.Parameters. x@)))) :pattern ((has_type x@ TYPE%crate!semantics.Parameters.)) :qid internal_crate__semantics__Parameters_unbox_axiom_definition :skolemid skolem_internal_crate__semantics__Parameters_unbox_axiom_definition)))
(assert (forall ((rns_moduli@ vstd!seq.Seq<int.>.) (modulus@ Int) (log_num_tiles@ Int) (log_num_rows@ Int) (log_block_size@ Int)) (! (=> (and (<= 0 log_num_tiles@) (<= 0 log_num_rows@) (<= 0 log_block_size@)) (has_type (Poly%crate!semantics.Parameters. (crate!semantics.Parameters./Parameters rns_moduli@ modulus@ log_num_tiles@ log_num_rows@ log_block_size@)) TYPE%crate!semantics.Parameters.)) :pattern ((has_type (Poly%crate!semantics.Parameters. (crate!semantics.Parameters./Parameters rns_moduli@ modulus@ log_num_tiles@ log_num_rows@ log_block_size@)) TYPE%crate!semantics.Parameters.)) :qid internal_crate!semantics.Parameters./Parameters_constructor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters_constructor_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= (crate!semantics.Parameters./Parameters/rns_moduli x@) (crate!semantics.Parameters./Parameters/?rns_moduli x@)) :pattern ((crate!semantics.Parameters./Parameters/rns_moduli x@)) :qid internal_crate!semantics.Parameters./Parameters/rns_moduli_accessor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/rns_moduli_accessor_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= (crate!semantics.Parameters./Parameters/modulus x@) (crate!semantics.Parameters./Parameters/?modulus x@)) :pattern ((crate!semantics.Parameters./Parameters/modulus x@)) :qid internal_crate!semantics.Parameters./Parameters/modulus_accessor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/modulus_accessor_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= (crate!semantics.Parameters./Parameters/log_num_tiles x@) (crate!semantics.Parameters./Parameters/?log_num_tiles x@)) :pattern ((crate!semantics.Parameters./Parameters/log_num_tiles x@)) :qid internal_crate!semantics.Parameters./Parameters/log_num_tiles_accessor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_num_tiles_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Parameters.) (<= 0 (crate!semantics.Parameters./Parameters/log_num_tiles (%Poly%crate!semantics.Parameters. x@)))) :pattern ((crate!semantics.Parameters./Parameters/log_num_tiles (%Poly%crate!semantics.Parameters. x@)) (has_type x@ TYPE%crate!semantics.Parameters.)) :qid internal_crate!semantics.Parameters./Parameters/log_num_tiles_invariant_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_num_tiles_invariant_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= (crate!semantics.Parameters./Parameters/log_num_rows x@) (crate!semantics.Parameters./Parameters/?log_num_rows x@)) :pattern ((crate!semantics.Parameters./Parameters/log_num_rows x@)) :qid internal_crate!semantics.Parameters./Parameters/log_num_rows_accessor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_num_rows_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Parameters.) (<= 0 (crate!semantics.Parameters./Parameters/log_num_rows (%Poly%crate!semantics.Parameters. x@)))) :pattern ((crate!semantics.Parameters./Parameters/log_num_rows (%Poly%crate!semantics.Parameters. x@)) (has_type x@ TYPE%crate!semantics.Parameters.)) :qid internal_crate!semantics.Parameters./Parameters/log_num_rows_invariant_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_num_rows_invariant_definition)))
(assert (forall ((x@ crate!semantics.Parameters.)) (! (= (crate!semantics.Parameters./Parameters/log_block_size x@) (crate!semantics.Parameters./Parameters/?log_block_size x@)) :pattern ((crate!semantics.Parameters./Parameters/log_block_size x@)) :qid internal_crate!semantics.Parameters./Parameters/log_block_size_accessor_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_block_size_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%crate!semantics.Parameters.) (<= 0 (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. x@)))) :pattern ((crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. x@)) (has_type x@ TYPE%crate!semantics.Parameters.)) :qid internal_crate!semantics.Parameters./Parameters/log_block_size_invariant_definition :skolemid skolem_internal_crate!semantics.Parameters./Parameters/log_block_size_invariant_definition)))
(assert (forall ((x@ tuple%0.)) (! (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@))) :pattern ((Poly%tuple%0. x@)) :qid internal_crate__tuple__0_box_axiom_definition :skolemid skolem_internal_crate__tuple__0_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%tuple%0.) (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))) :pattern ((has_type x@ TYPE%tuple%0.)) :qid internal_crate__tuple__0_unbox_axiom_definition :skolemid skolem_internal_crate__tuple__0_unbox_axiom_definition)))
(assert (forall ((x@ tuple%0.)) (! (has_type (Poly%tuple%0. x@) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.)) :qid internal_crate__tuple__0_has_type_always_definition :skolemid skolem_internal_crate__tuple__0_has_type_always_definition)))
(assert (forall ((x@ tuple%2.)) (! (= x@ (%Poly%tuple%2. (Poly%tuple%2. x@))) :pattern ((Poly%tuple%2. x@)) :qid internal_crate__tuple__2_box_axiom_definition :skolemid skolem_internal_crate__tuple__2_box_axiom_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (= x@ (Poly%tuple%2. (%Poly%tuple%2. x@)))) :pattern ((has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :qid internal_crate__tuple__2_unbox_axiom_definition :skolemid skolem_internal_crate__tuple__2_unbox_axiom_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (field%0@ Poly) (field%1@ Poly)) (! (=> (and (has_type field%0@ T%0&) (has_type field%1@ T%1&)) (has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :qid internal_tuple__2./tuple__2_constructor_definition :skolemid skolem_internal_tuple__2./tuple__2_constructor_definition)))
(assert (forall ((x@ tuple%2.)) (! (= (tuple%2./tuple%2/field%0 x@) (tuple%2./tuple%2/?field%0 x@)) :pattern ((tuple%2./tuple%2/field%0 x@)) :qid internal_tuple__2./tuple__2/field__0_accessor_definition :skolemid skolem_internal_tuple__2./tuple__2/field__0_accessor_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) T%0&)) :pattern ((tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :qid internal_tuple__2./tuple__2/field__0_invariant_definition :skolemid skolem_internal_tuple__2./tuple__2/field__0_invariant_definition)))
(assert (forall ((x@ tuple%2.)) (! (= (tuple%2./tuple%2/field%1 x@) (tuple%2./tuple%2/?field%1 x@)) :pattern ((tuple%2./tuple%2/field%1 x@)) :qid internal_tuple__2./tuple__2/field__1_accessor_definition :skolemid skolem_internal_tuple__2./tuple__2/field__1_accessor_definition)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type (tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) T%1&)) :pattern ((tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&))) :qid internal_tuple__2./tuple__2/field__1_invariant_definition :skolemid skolem_internal_tuple__2./tuple__2/field__1_invariant_definition)))
(assert (forall ((x tuple%2.)) (! (=> ((_ is tuple%2./tuple%2) x) (height_lt (height (tuple%2./tuple%2/field%0 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/field%0 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x tuple%2.)) (! (=> ((_ is tuple%2./tuple%2) x) (height_lt (height (tuple%2./tuple%2/field%1 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/field%1 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((T%0&. Dcr) (T%0& Type) (T%1&. Dcr) (T%1& Type) (deep@ Bool) (x@ Poly) (y@ Poly)) (! (=> (and (has_type x@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (has_type y@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&)) (ext_eq deep@ T%0& (tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) (tuple%2./tuple%2/field%0 (%Poly%tuple%2. y@))) (ext_eq deep@ T%1& (tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) (tuple%2./tuple%2/field%1 (%Poly%tuple%2. y@)))) (ext_eq deep@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x@ y@)) :pattern ((ext_eq deep@ (TYPE%tuple%2. T%0&. T%0& T%1&. T%1&) x@ y@)) :qid internal_tuple__2./tuple__2_ext_equal_definition :skolemid skolem_internal_tuple__2./tuple__2_ext_equal_definition)))
(set-info :comment ";; Function-Decl vstd::std_specs::vec::VecAdditionalSpecFns::view")
(declare-fun vstd!std_specs.vec.VecAdditionalSpecFns.view.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::vec::spec_vec_len")
(declare-fun vstd!std_specs.vec.spec_vec_len.? (Dcr Type Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::empty")
(declare-fun vstd!map.impl&%0.empty.? (Dcr Type Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::new")
(declare-fun vstd!map.impl&%0.new.? (Dcr Type Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::dom")
(declare-fun vstd!map.impl&%0.dom.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::index")
(declare-fun vstd!map.impl&%0.index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::spec_index")
(declare-fun vstd!map.impl&%0.spec_index.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::insert")
(declare-fun vstd!map.impl&%0.insert.? (Dcr Type Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::remove")
(declare-fun vstd!map.impl&%0.remove.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::contains_key")
(declare-fun vstd!map.impl&%0.contains_key.? (Dcr Type Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::seq::Seq::empty")
(declare-fun vstd!seq.Seq.empty.? (Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::new")
(declare-fun vstd!seq.Seq.new.? (Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::push")
(declare-fun vstd!seq.Seq.push.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::update")
(declare-fun vstd!seq.Seq.update.? (Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::subrange")
(declare-fun vstd!seq.Seq.subrange.? (Dcr Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::add")
(declare-fun vstd!seq.Seq.add.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_add")
(declare-fun vstd!seq.impl&%0.spec_add.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::empty")
(declare-fun vstd!set.impl&%0.empty.? (Dcr Type) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::new")
(declare-fun vstd!set.impl&%0.new.? (Dcr Type Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::contains")
(declare-fun vstd!set.impl&%0.contains.? (Dcr Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::insert")
(declare-fun vstd!set.impl&%0.insert.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::remove")
(declare-fun vstd!set.impl&%0.remove.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::union")
(declare-fun vstd!set.impl&%0.union.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::intersect")
(declare-fun vstd!set.impl&%0.intersect.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::difference")
(declare-fun vstd!set.impl&%0.difference.? (Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::complement")
(declare-fun vstd!set.impl&%0.complement.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::finite")
(declare-fun vstd!set.impl&%0.finite.? (Dcr Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::len")
(declare-fun vstd!set.impl&%0.len.? (Dcr Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::choose")
(declare-fun vstd!set.impl&%0.choose.? (Dcr Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::mk_map")
(declare-fun vstd!set.impl&%0.mk_map.? (Dcr Type Dcr Type Dcr Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::Polynomial::valid")
(declare-fun crate!semantics.Abstract.impl&%0.valid.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::Polynomial::to_machine")
(declare-fun crate!semantics.Abstract.impl&%0.to_machine.? (Poly Poly) crate!semantics.Machine.Polynomial.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::Register::new")
(declare-fun crate!semantics.Abstract.impl&%1.new.? (Poly) crate!semantics.Abstract.Register.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::valid")
(declare-fun crate!semantics.Abstract.impl&%2.valid.? (Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::valid_register")
(declare-fun crate!semantics.Abstract.impl&%2.valid_register.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::valid_instruction")
(declare-fun crate!semantics.Abstract.impl&%2.valid_instruction.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::get")
(declare-fun crate!semantics.Abstract.impl&%2.get.? (Poly Poly) crate!semantics.Abstract.Polynomial.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::set")
(declare-fun crate!semantics.Abstract.impl&%2.set.? (Poly Poly Poly) crate!semantics.Abstract.State.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::step")
(declare-fun crate!semantics.Abstract.impl&%2.step.? (Poly Poly) crate!semantics.Abstract.State.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::State::to_machine")
(declare-fun crate!semantics.Abstract.impl&%2.to_machine.? (Poly) crate!semantics.Machine.State.)
(set-info :comment ";; Function-Decl crate::semantics::Abstract::ntt")
(declare-fun crate!semantics.Abstract.ntt.? (Poly Poly) vstd!seq.Seq<int.>.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::Polynomial::num_blocks")
(declare-fun crate!semantics.Machine.impl&%0.num_blocks.? (Poly) Int)
(set-info :comment ";; Function-Decl crate::semantics::Machine::Polynomial::valid")
(declare-fun crate!semantics.Machine.impl&%0.valid.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Machine::Register::new")
(declare-fun crate!semantics.Machine.impl&%1.new.? (Poly Poly Poly) crate!semantics.Machine.Register.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::valid")
(declare-fun crate!semantics.Machine.impl&%2.valid.? (Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::valid_register")
(declare-fun crate!semantics.Machine.impl&%2.valid_register.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::valid_instruction")
(declare-fun crate!semantics.Machine.impl&%2.valid_instruction.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::valid_instructions")
(declare-fun crate!semantics.Machine.impl&%2.valid_instructions.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::get")
(declare-fun crate!semantics.Machine.impl&%2.get.? (Poly Poly) vstd!seq.Seq<int.>.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::set")
(declare-fun crate!semantics.Machine.impl&%2.set.? (Poly Poly Poly) crate!semantics.Machine.State.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::step")
(declare-fun crate!semantics.Machine.impl&%2.step.? (Poly Poly) crate!semantics.Machine.State.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::State::steps")
(declare-fun crate!semantics.Machine.impl&%2.steps.? (Poly Poly) crate!semantics.Machine.State.)
(declare-fun crate!semantics.Machine.impl&%2.rec%steps.? (Poly Poly Fuel) crate!semantics.Machine.State.)
(set-info :comment ";; Function-Decl crate::semantics::Machine::ntt_stage_block")
(declare-fun crate!semantics.Machine.ntt_stage_block.? (Poly Poly Poly Poly Poly Poly) tuple%2.)
(set-info :comment ";; Function-Decl crate::semantics::MachineImplementation::Register::to_machine")
(declare-fun crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly) crate!semantics.Machine.Register.)
(set-info :comment ";; Function-Decl crate::semantics::MachineImplementation::Instruction::to_machine")
(declare-fun crate!semantics.MachineImplementation.impl&%1.to_machine.? (Poly) crate!semantics.Machine.Instruction.)
(set-info :comment ";; Function-Decl crate::kernel_add::AddKernel::spec_generate_block")
(declare-fun crate!kernel_add.AddKernel.spec_generate_block.? (Poly Poly Poly Poly Poly) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(declare-fun crate!kernel_add.AddKernel.rec%spec_generate_block.? (Poly Poly Poly Poly Poly Fuel) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(set-info :comment ";; Function-Decl crate::kernel_add::AddKernel::spec_generate")
(declare-fun crate!kernel_add.AddKernel.spec_generate.? (Poly Poly Poly Poly Poly) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(declare-fun crate!kernel_add.AddKernel.rec%spec_generate.? (Poly Poly Poly Poly Poly Fuel) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(set-info :comment ";; Function-Decl crate::kernel_add::AddKernel::parameters")
(declare-fun crate!kernel_add.AddKernel.parameters.? (Poly Poly) crate!semantics.Parameters.)
(set-info :comment ";; Function-Decl crate::kernel_add::AddKernel::impl_instrs_to_machine_instrs")
(declare-fun crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.? (Poly) vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(set-info :comment ";; Function-Decl crate::arith::product_of")
(declare-fun crate!arith.product_of.? (Poly) Int)
(declare-fun crate!arith.rec%product_of.? (Poly Fuel) Int)
(set-info :comment ";; Function-Decl crate::arith::pow2")
(declare-fun crate!arith.pow2.? (Poly) Int)
(declare-fun crate!arith.rec%pow2.? (Poly Fuel) Int)
(set-info :comment ";; Function-Decl crate::arith::are_pairwise_coprime")
(declare-fun crate!arith.are_pairwise_coprime.? (Poly) Bool)
(set-info :comment ";; Function-Decl crate::arith::are_valid_rns_moduli")
(declare-fun crate!arith.are_valid_rns_moduli.? (Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Parameters::valid")
(declare-fun crate!semantics.impl&%0.valid.? (Poly) Bool)
(set-info :comment ";; Function-Decl crate::semantics::Parameters::block_size")
(declare-fun crate!semantics.impl&%0.block_size.? (Poly) Int)
(set-info :comment ";; Function-Decl crate::semantics::block_index_to_coeff_index")
(declare-fun crate!semantics.block_index_to_coeff_index.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Axioms vstd::std_specs::vec::VecAdditionalSpecFns::view")
(assert (forall ((Self%&. Dcr) (Self%& Type) (T&. Dcr) (T& Type) (self~2@ Poly)) (! (=> (has_type self~2@ Self%&) (has_type (vstd!std_specs.vec.VecAdditionalSpecFns.view.? Self%&. Self%& T&. T& self~2@) (TYPE%vstd!seq.Seq. T&. T&))) :pattern ((vstd!std_specs.vec.VecAdditionalSpecFns.view.? Self%&. Self%& T&. T& self~2@)) :qid internal_vstd!std_specs.vec.VecAdditionalSpecFns.view.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.vec.VecAdditionalSpecFns.view.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (<= 0 (vstd!seq.Seq.len.? A&. A& self~2@))) :pattern ((vstd!seq.Seq.len.? A&. A& self~2@)) :qid internal_vstd!seq.Seq.len.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.len.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly)) (! (= (req%vstd!seq.Seq.index. A&. A& self~2@ i~4@) (=> %%global_location_label%%0 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A&. A& self~2@))))) :pattern ((req%vstd!seq.Seq.index. A&. A& self~2@ i~4@)) :qid internal_req__vstd!seq.Seq.index._definition :skolemid skolem_internal_req__vstd!seq.Seq.index._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4@ INT)) (has_type (vstd!seq.Seq.index.? A&. A& self~2@ i~4@) A&)) :pattern ((vstd!seq.Seq.index.? A&. A& self~2@ i~4@)) :qid internal_vstd!seq.Seq.index.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::vec::spec_vec_len")
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (v~2@ Poly)) (! (=> (has_type v~2@ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) (uInv SZ (vstd!std_specs.vec.spec_vec_len.? T&. T& A&. A& v~2@))) :pattern ((vstd!std_specs.vec.spec_vec_len.? T&. T& A&. A& v~2@)) :qid internal_vstd!std_specs.vec.spec_vec_len.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.vec.spec_vec_len.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::seq::Seq::update")
(declare-fun req%vstd!seq.Seq.update. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly) (a~6@ Poly)) (! (= (req%vstd!seq.Seq.update. A&. A& self~2@ i~4@ a~6@) (=> %%global_location_label%%1 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A&. A& self~2@))))) :pattern ((req%vstd!seq.Seq.update. A&. A& self~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.Seq.update._definition :skolemid skolem_internal_req__vstd!seq.Seq.update._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::update")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly) (a~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4@ INT) (has_type a~6@ A&)) (has_type (vstd!seq.Seq.update.? A&. A& self~2@ i~4@ a~6@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.update.? A&. A& self~2@ i~4@ a~6@)) :qid internal_vstd!seq.Seq.update.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.update.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::vec::axiom_spec_len")
(declare-fun ens%vstd!std_specs.vec.axiom_spec_len. (Dcr Type Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (v~2@ Poly)) (! (= (ens%vstd!std_specs.vec.axiom_spec_len. A&. A& v~2@) (= (vstd!std_specs.vec.spec_vec_len.? A&. A& $ TYPE%alloc!alloc.Global. v~2@) (vstd!seq.Seq.len.? A&. A& (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. A&. A& $ TYPE%alloc!alloc.Global.) A&. A& v~2@)))) :pattern ((ens%vstd!std_specs.vec.axiom_spec_len. A&. A& v~2@)) :qid internal_ens__vstd!std_specs.vec.axiom_spec_len._definition :skolemid skolem_internal_ens__vstd!std_specs.vec.axiom_spec_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (v~2$ Poly)) (! (=> (has_type v~2$ (TYPE%alloc!vec.Vec. A&. A& $ TYPE%alloc!alloc.Global.)) (= (vstd!std_specs.vec.spec_vec_len.? A&. A& $ TYPE%alloc!alloc.Global. v~2$) (vstd!seq.Seq.len.? A&. A& (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. A&. A& $ TYPE%alloc!alloc.Global.) A&. A& v~2$)))) :pattern ((vstd!std_specs.vec.spec_vec_len.? A&. A& $ TYPE%alloc!alloc.Global. v~2$)) :qid user_vstd__std_specs__vec__axiom_spec_len_0 :skolemid skolem_user_vstd__std_specs__vec__axiom_spec_len_0)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::empty")
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!seq.Seq.empty.? A&. A&) (TYPE%vstd!seq.Seq. A&. A&)) :pattern ((vstd!seq.Seq.empty.? A&. A&)) :qid internal_vstd!seq.Seq.empty.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms alloc::vec::impl&%0::new")
(declare-fun ens%alloc!vec.impl&%0.new. (Dcr Type Poly) Bool)
(assert (forall ((T&. Dcr) (T& Type) (v~8@ Poly)) (! (= (ens%alloc!vec.impl&%0.new. T&. T& v~8@) (and (has_type v~8@ (TYPE%alloc!vec.Vec. T&. T& $ TYPE%alloc!alloc.Global.)) (= (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. T&. T& $ TYPE%alloc!alloc.Global.) T&. T& v~8@) (vstd!seq.Seq.empty.? T&. T&)))) :pattern ((ens%alloc!vec.impl&%0.new. T&. T& v~8@)) :qid internal_ens__alloc!vec.impl&__0.new._definition :skolemid skolem_internal_ens__alloc!vec.impl&__0.new._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::push")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type a~4@ A&)) (has_type (vstd!seq.Seq.push.? A&. A& self~2@ a~4@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.push.? A&. A& self~2@ a~4@)) :qid internal_vstd!seq.Seq.push.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.push.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms alloc::vec::impl&%1::push")
(declare-fun ens%alloc!vec.impl&%1.push. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((T&. Dcr) (T& Type) (A&. Dcr) (A& Type) (pre%vec~2@ Poly) (vec~2@ Poly) (value~4@ Poly)) (! (= (ens%alloc!vec.impl&%1.push. T&. T& A&. A& pre%vec~2@ vec~2@ value~4@) (and (has_type vec~2@ (TYPE%alloc!vec.Vec. T&. T& A&. A&)) (= (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) T&. T& vec~2@) (vstd!seq.Seq.push.? T&. T& (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. T&. T& A&. A&) T&. T& pre%vec~2@) value~4@)))) :pattern ((ens%alloc!vec.impl&%1.push. T&. T& A&. A& pre%vec~2@ vec~2@ value~4@)) :qid internal_ens__alloc!vec.impl&__1.push._definition :skolemid skolem_internal_ens__alloc!vec.impl&__1.push._definition)))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A&. A& self~2@ i~4@) (=> %%global_location_label%%2 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A&. A& self~2@))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A&. A& self~2@ i~4@)) :qid internal_req__vstd!seq.impl&__0.spec_index._definition :skolemid skolem_internal_req__vstd!seq.impl&__0.spec_index._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A&. A& self~2@ i~4@) (vstd!seq.Seq.index.? A&. A& self~2@ i~4@)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self~2@ i~4@)) :qid internal_vstd!seq.impl&__0.spec_index.?_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_index.?_definition))))
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (i~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4@ INT)) (has_type (vstd!seq.impl&%0.spec_index.? A&. A& self~2@ i~4@) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A&. A& self~2@ i~4@)) :qid internal_vstd!seq.impl&__0.spec_index.?_pre_post_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_index.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::seq::Seq::subrange")
(declare-fun req%vstd!seq.Seq.subrange. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (start_inclusive~4@ Poly) (end_exclusive~6@ Poly)) (! (= (req%vstd!seq.Seq.subrange. A&. A& self~2@ start_inclusive~4@ end_exclusive~6@) (=> %%global_location_label%%3 (and (and (<= 0 (%I start_inclusive~4@)) (<= (%I start_inclusive~4@) (%I end_exclusive~6@))) (<= (%I end_exclusive~6@) (vstd!seq.Seq.len.? A&. A& self~2@))))) :pattern ((req%vstd!seq.Seq.subrange. A&. A& self~2@ start_inclusive~4@ end_exclusive~6@)) :qid internal_req__vstd!seq.Seq.subrange._definition :skolemid skolem_internal_req__vstd!seq.Seq.subrange._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::subrange")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (start_inclusive~4@ Poly) (end_exclusive~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type start_inclusive~4@ INT) (has_type end_exclusive~6@ INT)) (has_type (vstd!seq.Seq.subrange.? A&. A& self~2@ start_inclusive~4@ end_exclusive~6@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.subrange.? A&. A& self~2@ start_inclusive~4@ end_exclusive~6@)) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.subrange.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::add")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (rhs~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type rhs~4@ (TYPE%vstd!seq.Seq. A&. A&))) (has_type (vstd!seq.Seq.add.? A&. A& self~2@ rhs~4@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.add.? A&. A& self~2@ rhs~4@)) :qid internal_vstd!seq.Seq.add.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.add.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_add")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_add.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_add.) (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (rhs~4@ Poly)) (! (= (vstd!seq.impl&%0.spec_add.? A&. A& self~2@ rhs~4@) (vstd!seq.Seq.add.? A&. A& self~2@ rhs~4@)) :pattern ((vstd!seq.impl&%0.spec_add.? A&. A& self~2@ rhs~4@)) :qid internal_vstd!seq.impl&__0.spec_add.?_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_add.?_definition))))
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (rhs~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&. A&)) (has_type rhs~4@ (TYPE%vstd!seq.Seq. A&. A&))) (has_type (vstd!seq.impl&%0.spec_add.? A&. A& self~2@ rhs~4@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.impl&%0.spec_add.? A&. A& self~2@ rhs~4@)) :qid internal_vstd!seq.impl&__0.spec_add.?_pre_post_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_add.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::empty")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (has_type (vstd!map.impl&%0.empty.? K&. K& V&. V&) (TYPE%vstd!map.Map. K&. K& V&. V&)) :pattern ((vstd!map.impl&%0.empty.? K&. K& V&. V&)) :qid internal_vstd!map.impl&__0.empty.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::mk_map")
(assert (forall ((A&. Dcr) (A& Type) (V&. Dcr) (V& Type) (F&. Dcr) (F& Type) (self~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type f~4@ F&)) (has_type (vstd!set.impl&%0.mk_map.? A&. A& V&. V& F&. F& self~2@ f~4@) (TYPE%vstd!map.Map. A&. A& V&. V&))) :pattern ((vstd!set.impl&%0.mk_map.? A&. A& V&. V& F&. F& self~2@ f~4@)) :qid internal_vstd!set.impl&__0.mk_map.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.mk_map.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::complement")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type (vstd!set.impl&%0.complement.? A&. A& self~2@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.complement.? A&. A& self~2@)) :qid internal_vstd!set.impl&__0.complement.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.complement.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::empty")
(assert (forall ((A&. Dcr) (A& Type)) (! (has_type (vstd!set.impl&%0.empty.? A&. A&) (TYPE%vstd!set.Set. A&. A&)) :pattern ((vstd!set.impl&%0.empty.? A&. A&)) :qid internal_vstd!set.impl&__0.empty.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::new")
(assert (forall ((A&. Dcr) (A& Type) (F&. Dcr) (F& Type) (f~2@ Poly)) (! (=> (has_type f~2@ F&) (has_type (vstd!set.impl&%0.new.? A&. A& F&. F& f~2@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.new.? A&. A& F&. F& f~2@)) :qid internal_vstd!set.impl&__0.new.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::new")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.new.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.new.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk~2@ Poly) (fv~4@ Poly)) (! (= (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk~2@ fv~4@) (vstd!set.impl&%0.mk_map.? K&. K& V&. V& impl%3&. impl%3& (vstd!set.impl&%0.new.? K&. K& impl%2&. impl%2& fk~2@) fv~4@)) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk~2@ fv~4@)) :qid internal_vstd!map.impl&__0.new.?_definition :skolemid skolem_internal_vstd!map.impl&__0.new.?_definition))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (impl%2&. Dcr) (impl%2& Type) (impl%3&. Dcr) (impl%3& Type) (fk~2@ Poly) (fv~4@ Poly)) (! (=> (and (has_type fk~2@ impl%2&) (has_type fv~4@ impl%3&)) (has_type (vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk~2@ fv~4@) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.new.? K&. K& V&. V& impl%2&. impl%2& impl%3&. impl%3& fk~2@ fv~4@)) :qid internal_vstd!map.impl&__0.new.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::dom")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type (vstd!map.impl&%0.dom.? K&. K& V&. V& self~2@) (TYPE%vstd!set.Set. K&. K&))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& self~2@)) :qid internal_vstd!map.impl&__0.dom.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.dom.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::index")
(declare-fun req%vstd!map.impl&%0.index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.impl&%0.index. K&. K& V&. V& self~2@ key~4@) (=> %%global_location_label%%4 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self~2@) key~4@))) :pattern ((req%vstd!map.impl&%0.index. K&. K& V&. V& self~2@ key~4@)) :qid internal_req__vstd!map.impl&__0.index._definition :skolemid skolem_internal_req__vstd!map.impl&__0.index._definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::index")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.index.? K&. K& V&. V& self~2@ key~4@) V&)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& self~2@ key~4@)) :qid internal_vstd!map.impl&__0.index.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.index.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::spec_index")
(declare-fun req%vstd!map.impl&%0.spec_index. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self~2@ key~4@) (=> %%global_location_label%%5 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self~2@) key~4@))) :pattern ((req%vstd!map.impl&%0.spec_index. K&. K& V&. V& self~2@ key~4@)) :qid internal_req__vstd!map.impl&__0.spec_index._definition :skolemid skolem_internal_req__vstd!map.impl&__0.spec_index._definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.spec_index.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (= (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self~2@ key~4@) (vstd!map.impl&%0.index.? K&. K& V&. V& self~2@ key~4@)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self~2@ key~4@)) :qid internal_vstd!map.impl&__0.spec_index.?_definition :skolemid skolem_internal_vstd!map.impl&__0.spec_index.?_definition))))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.spec_index.? K&. K& V&. V& self~2@ key~4@) V&)) :pattern ((vstd!map.impl&%0.spec_index.? K&. K& V&. V& self~2@ key~4@)) :qid internal_vstd!map.impl&__0.spec_index.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.spec_index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::insert")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4@ K&) (has_type value~6@ V&)) (has_type (vstd!map.impl&%0.insert.? K&. K& V&. V& self~2@ key~4@ value~6@) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.insert.? K&. K& V&. V& self~2@ key~4@ value~6@)) :qid internal_vstd!map.impl&__0.insert.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.insert.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::remove")
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.remove.? K&. K& V&. V& self~2@ key~4@) (TYPE%vstd!map.Map. K&. K& V&. V&))) :pattern ((vstd!map.impl&%0.remove.? K&. K& V&. V& self~2@ key~4@)) :qid internal_vstd!map.impl&__0.remove.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.remove.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::contains_key")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.contains_key.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.contains_key.) (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (self~2@ Poly) (k~4@ Poly)) (! (= (vstd!map.impl&%0.contains_key.? K&. K& V&. V& self~2@ k~4@) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& self~2@) k~4@)) :pattern ((vstd!map.impl&%0.contains_key.? K&. K& V&. V& self~2@ k~4@)) :qid internal_vstd!map.impl&__0.contains_key.?_definition :skolemid skolem_internal_vstd!map.impl&__0.contains_key.?_definition))))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_index_decreases_finite")
(declare-fun req%vstd!map.axiom_map_index_decreases_finite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%6 Bool)
(declare-const %%global_location_label%%7 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.axiom_map_index_decreases_finite. K&. K& V&. V& m~2@ key~4@) (and (=> %%global_location_label%%6 (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@))) (=> %%global_location_label%%7 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key~4@)))) :pattern ((req%vstd!map.axiom_map_index_decreases_finite. K&. K& V&. V& m~2@ key~4@)) :qid internal_req__vstd!map.axiom_map_index_decreases_finite._definition :skolemid skolem_internal_req__vstd!map.axiom_map_index_decreases_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_index_decreases_finite")
(declare-fun ens%vstd!map.axiom_map_index_decreases_finite. (Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_index_decreases_finite. K&. K& V&. V& m~2@ key~4@) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2@ key~4@)) (height m~2@))) :pattern ((ens%vstd!map.axiom_map_index_decreases_finite. K&. K& V&. V& m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_index_decreases_finite._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_index_decreases_finite._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4$ K&)) (=> (and (vstd!set.impl&%0.finite.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$)) (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key~4$)) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key~4$)) (height m~2$)))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key~4$))) :qid user_vstd__map__axiom_map_index_decreases_finite_1 :skolemid skolem_user_vstd__map__axiom_map_index_decreases_finite_1)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_index_decreases_infinite")
(declare-fun req%vstd!map.axiom_map_index_decreases_infinite. (Dcr Type Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.axiom_map_index_decreases_infinite. K&. K& V&. V& m~2@ key~4@) (=> %%global_location_label%%8 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key~4@))) :pattern ((req%vstd!map.axiom_map_index_decreases_infinite. K&. K& V&. V& m~2@ key~4@)) :qid internal_req__vstd!map.axiom_map_index_decreases_infinite._definition :skolemid skolem_internal_req__vstd!map.axiom_map_index_decreases_infinite._definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_index_decreases_infinite")
(declare-fun ens%vstd!map.axiom_map_index_decreases_infinite. (Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_index_decreases_infinite. K&. K& V&. V& m~2@ key~4@) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2@ key~4@)) (height (fun_from_recursive_field m~2@)))) :pattern ((ens%vstd!map.axiom_map_index_decreases_infinite. K&. K& V&. V& m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_index_decreases_infinite._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_index_decreases_infinite._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4$ K&)) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key~4$) (height_lt (height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key~4$)) (height (fun_from_recursive_field m~2$))))) :pattern ((height (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key~4$))) :qid user_vstd__map__axiom_map_index_decreases_infinite_2 :skolemid skolem_user_vstd__map__axiom_map_index_decreases_infinite_2)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_empty")
(declare-fun ens%vstd!map.axiom_map_empty. (Dcr Type Dcr Type) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (= (ens%vstd!map.axiom_map_empty. K&. K& V&. V&) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&)) (vstd!set.impl&%0.empty.? K&. K&))) :pattern ((ens%vstd!map.axiom_map_empty. K&. K& V&. V&)) :qid internal_ens__vstd!map.axiom_map_empty._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_empty._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type)) (! (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&)) (vstd!set.impl&%0.empty.? K&. K&)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.empty.? K&. K& V&. V&))) :qid user_vstd__map__axiom_map_empty_3 :skolemid skolem_user_vstd__map__axiom_map_empty_3)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::insert")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4@ A&)) (has_type (vstd!set.impl&%0.insert.? A&. A& self~2@ a~4@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.insert.? A&. A& self~2@ a~4@)) :qid internal_vstd!set.impl&__0.insert.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.insert.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_domain")
(declare-fun ens%vstd!map.axiom_map_insert_domain. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_domain. K&. K& V&. V& m~2@ key~4@ value~6@) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2@ key~4@ value~6@)) (vstd!set.impl&%0.insert.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key~4@))) :pattern ((ens%vstd!map.axiom_map_insert_domain. K&. K& V&. V& m~2@ key~4@ value~6@)) :qid internal_ens__vstd!map.axiom_map_insert_domain._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_domain._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key~4$ Poly) (value~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4$ K&) (has_type value~6$ V&)) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key~4$ value~6$)) (vstd!set.impl&%0.insert.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key~4$))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key~4$ value~6$))) :qid user_vstd__map__axiom_map_insert_domain_4 :skolemid skolem_user_vstd__map__axiom_map_insert_domain_4)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_same")
(declare-fun ens%vstd!map.axiom_map_insert_same. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_same. K&. K& V&. V& m~2@ key~4@ value~6@) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2@ key~4@ value~6@) key~4@) value~6@)) :pattern ((ens%vstd!map.axiom_map_insert_same. K&. K& V&. V& m~2@ key~4@ value~6@)) :qid internal_ens__vstd!map.axiom_map_insert_same._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_same._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key~4$ Poly) (value~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4$ K&) (has_type value~6$ V&)) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key~4$ value~6$) key~4$) value~6$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key~4$ value~6$) key~4$)) :qid user_vstd__map__axiom_map_insert_same_5 :skolemid skolem_user_vstd__map__axiom_map_insert_same_5)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_insert_different")
(declare-fun req%vstd!map.axiom_map_insert_different. (Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%9 Bool)
(declare-const %%global_location_label%%10 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly) (value~8@ Poly)) (! (= (req%vstd!map.axiom_map_insert_different. K&. K& V&. V& m~2@ key1~4@ key2~6@ value~8@) (and (=> %%global_location_label%%9 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key1~4@)) (=> %%global_location_label%%10 (not (= key1~4@ key2~6@))))) :pattern ((req%vstd!map.axiom_map_insert_different. K&. K& V&. V& m~2@ key1~4@ key2~6@ value~8@)) :qid internal_req__vstd!map.axiom_map_insert_different._definition :skolemid skolem_internal_req__vstd!map.axiom_map_insert_different._definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_different")
(declare-fun ens%vstd!map.axiom_map_insert_different. (Dcr Type Dcr Type Poly Poly Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly) (value~8@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_different. K&. K& V&. V& m~2@ key1~4@ key2~6@ value~8@) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2@ key2~6@ value~8@) key1~4@) (vstd!map.impl&%0.index.? K&. K& V&. V& m~2@ key1~4@))) :pattern ((ens%vstd!map.axiom_map_insert_different. K&. K& V&. V& m~2@ key1~4@ key2~6@ value~8@)) :qid internal_ens__vstd!map.axiom_map_insert_different._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_different._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key1~4$ Poly) (key2~6$ Poly) (value~8$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key1~4$ K&) (has_type key2~6$ K&) (has_type value~8$ V&)) (=> (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key1~4$) (not (= key1~4$ key2~6$))) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key2~6$ value~8$) key1~4$) (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key1~4$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.insert.? K&. K& V&. V& m~2$ key2~6$ value~8$) key1~4$)) :qid user_vstd__map__axiom_map_insert_different_6 :skolemid skolem_user_vstd__map__axiom_map_insert_different_6)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::remove")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4@ A&)) (has_type (vstd!set.impl&%0.remove.? A&. A& self~2@ a~4@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.remove.? A&. A& self~2@ a~4@)) :qid internal_vstd!set.impl&__0.remove.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.remove.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_remove_domain")
(declare-fun ens%vstd!map.axiom_map_remove_domain. (Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_remove_domain. K&. K& V&. V& m~2@ key~4@) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2@ key~4@)) (vstd!set.impl&%0.remove.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key~4@))) :pattern ((ens%vstd!map.axiom_map_remove_domain. K&. K& V&. V& m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_remove_domain._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_remove_domain._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key~4$ K&)) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2$ key~4$)) (vstd!set.impl&%0.remove.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key~4$))) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2$ key~4$))) :qid user_vstd__map__axiom_map_remove_domain_7 :skolemid skolem_user_vstd__map__axiom_map_remove_domain_7)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_remove_different")
(declare-fun req%vstd!map.axiom_map_remove_different. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%11 Bool)
(declare-const %%global_location_label%%12 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly)) (! (= (req%vstd!map.axiom_map_remove_different. K&. K& V&. V& m~2@ key1~4@ key2~6@) (and (=> %%global_location_label%%11 (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2@) key1~4@)) (=> %%global_location_label%%12 (not (= key1~4@ key2~6@))))) :pattern ((req%vstd!map.axiom_map_remove_different. K&. K& V&. V& m~2@ key1~4@ key2~6@)) :qid internal_req__vstd!map.axiom_map_remove_different._definition :skolemid skolem_internal_req__vstd!map.axiom_map_remove_different._definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_remove_different")
(declare-fun ens%vstd!map.axiom_map_remove_different. (Dcr Type Dcr Type Poly Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly)) (! (= (ens%vstd!map.axiom_map_remove_different. K&. K& V&. V& m~2@ key1~4@ key2~6@) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2@ key2~6@) key1~4@) (vstd!map.impl&%0.index.? K&. K& V&. V& m~2@ key1~4@))) :pattern ((ens%vstd!map.axiom_map_remove_different. K&. K& V&. V& m~2@ key1~4@ key2~6@)) :qid internal_ens__vstd!map.axiom_map_remove_different._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_remove_different._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m~2$ Poly) (key1~4$ Poly) (key2~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type key1~4$ K&) (has_type key2~6$ K&)) (=> (and (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m~2$) key1~4$) (not (= key1~4$ key2~6$))) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2$ key2~6$) key1~4$) (vstd!map.impl&%0.index.? K&. K& V&. V& m~2$ key1~4$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!map.impl&%0.remove.? K&. K& V&. V& m~2$ key2~6$) key1~4$)) :qid user_vstd__map__axiom_map_remove_different_8 :skolemid skolem_user_vstd__map__axiom_map_remove_different_8)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_ext_equal")
(declare-fun ens%vstd!map.axiom_map_ext_equal. (Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1~2@ Poly) (m2~4@ Poly)) (! (= (ens%vstd!map.axiom_map_ext_equal. K&. K& V&. V& m1~2@ m2~4@) (= (ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2@ m2~4@) (and (ext_eq false (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2@) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2~4@)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2@) k~47$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& m1~2@ k~47$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2~4@ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1~2@ k~47$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2~4@ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_9 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_9))))) :pattern ((ens%vstd!map.axiom_map_ext_equal. K&. K& V&. V& m1~2@ m2~4@)) :qid internal_ens__vstd!map.axiom_map_ext_equal._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_ext_equal._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1~2$ Poly) (m2~4$ Poly)) (! (=> (and (has_type m1~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2~4$ (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2$ m2~4$) (and (ext_eq false (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2$) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2~4$)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2$) k~47$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& m1~2$ k~47$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2~4$ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1~2$ k~47$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2~4$ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_10 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_10))))) :pattern ((ext_eq false (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2$ m2~4$)) :qid user_vstd__map__axiom_map_ext_equal_11 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_11)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_ext_equal_deep")
(declare-fun ens%vstd!map.axiom_map_ext_equal_deep. (Dcr Type Dcr Type Poly Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1~2@ Poly) (m2~4@ Poly)) (! (= (ens%vstd!map.axiom_map_ext_equal_deep. K&. K& V&. V& m1~2@ m2~4@) (= (ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2@ m2~4@) (and (ext_eq true (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2@) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2~4@)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2@) k~47$) (ext_eq true V& (vstd!map.impl&%0.index.? K&. K& V&. V& m1~2@ k~47$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2~4@ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1~2@ k~47$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2~4@ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_deep_12 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_12))))) :pattern ((ens%vstd!map.axiom_map_ext_equal_deep. K&. K& V&. V& m1~2@ m2~4@)) :qid internal_ens__vstd!map.axiom_map_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_ext_equal_deep._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (m1~2$ Poly) (m2~4$ Poly)) (! (=> (and (has_type m1~2$ (TYPE%vstd!map.Map. K&. K& V&. V&)) (has_type m2~4$ (TYPE%vstd!map.Map. K&. K& V&. V&))) (= (ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2$ m2~4$) (and (ext_eq true (TYPE%vstd!set.Set. K&. K&) (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2$) (vstd!map.impl&%0.dom.? K&. K& V&. V& m2~4$)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K&. K& (vstd!map.impl&%0.dom.? K&. K& V&. V& m1~2$) k~47$) (ext_eq true V& (vstd!map.impl&%0.index.? K&. K& V&. V& m1~2$ k~47$) (vstd!map.impl&%0.index.? K&. K& V&. V& m2~4$ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m1~2$ k~47$)) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& m2~4$ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_deep_13 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_13))))) :pattern ((ext_eq true (TYPE%vstd!map.Map. K&. K& V&. V&) m1~2$ m2~4$)) :qid user_vstd__map__axiom_map_ext_equal_deep_14 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_14)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::new")
(assert (forall ((A&. Dcr) (A& Type) (impl%1&. Dcr) (impl%1& Type) (len~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type len~2@ NAT) (has_type f~4@ impl%1&)) (has_type (vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len~2@ f~4@) (TYPE%vstd!seq.Seq. A&. A&))) :pattern ((vstd!seq.Seq.new.? A&. A& impl%1&. impl%1& len~2@ f~4@)) :qid internal_vstd!seq.Seq.new.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.new.?_pre_post_definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_index_decreases")
(declare-fun req%vstd!seq.axiom_seq_index_decreases. (Dcr Type Poly Int) Bool)
(declare-const %%global_location_label%%13 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int)) (! (= (req%vstd!seq.axiom_seq_index_decreases. A&. A& s~2@ i~4@) (=> %%global_location_label%%13 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A&. A& s~2@))))) :pattern ((req%vstd!seq.axiom_seq_index_decreases. A&. A& s~2@ i~4@)) :qid internal_req__vstd!seq.axiom_seq_index_decreases._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_index_decreases._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_index_decreases")
(declare-fun ens%vstd!seq.axiom_seq_index_decreases. (Dcr Type Poly Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int)) (! (= (ens%vstd!seq.axiom_seq_index_decreases. A&. A& s~2@ i~4@) (height_lt (height (vstd!seq.Seq.index.? A&. A& s~2@ (I i~4@))) (height s~2@))) :pattern ((ens%vstd!seq.axiom_seq_index_decreases. A&. A& s~2@ i~4@)) :qid internal_ens__vstd!seq.axiom_seq_index_decreases._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_index_decreases._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (i~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4$ INT)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A&. A& s~2$))) (height_lt (height (vstd!seq.Seq.index.? A&. A& s~2$ i~4$)) (height s~2$)))) :pattern ((height (vstd!seq.Seq.index.? A&. A& s~2$ i~4$))) :qid user_vstd__seq__axiom_seq_index_decreases_15 :skolemid skolem_user_vstd__seq__axiom_seq_index_decreases_15)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_empty")
(declare-fun ens%vstd!seq.axiom_seq_empty. (Dcr Type) Bool)
(assert (forall ((A&. Dcr) (A& Type)) (! (= (ens%vstd!seq.axiom_seq_empty. A&. A&) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) 0)) :pattern ((ens%vstd!seq.axiom_seq_empty. A&. A&)) :qid internal_ens__vstd!seq.axiom_seq_empty._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_empty._definition)))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&)) 0) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.empty.? A&. A&))) :qid user_vstd__seq__axiom_seq_empty_16 :skolemid skolem_user_vstd__seq__axiom_seq_empty_16)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_new_len")
(declare-fun ens%vstd!seq.axiom_seq_new_len. (Dcr Type Int %%Function%%) Bool)
(assert (forall ((A&. Dcr) (A& Type) (len~2@ Int) (f~4@ %%Function%%)) (! (= (ens%vstd!seq.axiom_seq_new_len. A&. A& len~2@ f~4@) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) (I len~2@) (Poly%fun%1. f~4@))) len~2@)) :pattern ((ens%vstd!seq.axiom_seq_new_len. A&. A& len~2@ f~4@)) :qid internal_ens__vstd!seq.axiom_seq_new_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_new_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (len~2$ Poly) (f~4$ Poly)) (! (=> (and (has_type len~2$ NAT) (has_type f~4$ (TYPE%fun%1. $ INT A&. A&))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len~2$ f~4$)) (%I len~2$))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len~2$ f~4$))) :qid user_vstd__seq__axiom_seq_new_len_17 :skolemid skolem_user_vstd__seq__axiom_seq_new_len_17)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_new_index")
(declare-fun req%vstd!seq.axiom_seq_new_index. (Dcr Type Int %%Function%% Int) Bool)
(declare-const %%global_location_label%%14 Bool)
(assert (forall ((A&. Dcr) (A& Type) (len~2@ Int) (f~4@ %%Function%%) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_new_index. A&. A& len~2@ f~4@ i~6@) (=> %%global_location_label%%14 (and (<= 0 i~6@) (< i~6@ len~2@)))) :pattern ((req%vstd!seq.axiom_seq_new_index. A&. A& len~2@ f~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_new_index._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_new_index._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_new_index")
(declare-fun ens%vstd!seq.axiom_seq_new_index. (Dcr Type Int %%Function%% Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (len~2@ Int) (f~4@ %%Function%%) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_new_index. A&. A& len~2@ f~4@ i~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) (I len~2@) (Poly%fun%1. f~4@)) (I i~6@)) (%%apply%%0 f~4@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_new_index. A&. A& len~2@ f~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_new_index._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_new_index._definition)))
(assert (forall ((A&. Dcr) (A& Type) (len~2$ Poly) (f~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type len~2$ NAT) (has_type f~4$ (TYPE%fun%1. $ INT A&. A&)) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (%I len~2$))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len~2$ f~4$) i~6$) (%%apply%%0 (%Poly%fun%1. f~4$) i~6$)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.new.? A&. A& $ (TYPE%fun%1. $ INT A&. A&) len~2$ f~4$) i~6$)) :qid user_vstd__seq__axiom_seq_new_index_18 :skolemid skolem_user_vstd__seq__axiom_seq_new_index_18)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_len")
(declare-fun ens%vstd!seq.axiom_seq_push_len. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_push_len. A&. A& s~2@ a~4@) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2@ a~4@)) (nClip (Add (vstd!seq.Seq.len.? A&. A& s~2@) 1)))) :pattern ((ens%vstd!seq.axiom_seq_push_len. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!seq.axiom_seq_push_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type a~4$ A&)) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$)) (nClip (Add (vstd!seq.Seq.len.? A&. A& s~2$) 1)))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$))) :qid user_vstd__seq__axiom_seq_push_len_19 :skolemid skolem_user_vstd__seq__axiom_seq_push_len_19)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_push_index_same")
(declare-fun req%vstd!seq.axiom_seq_push_index_same. (Dcr Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%15 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_push_index_same. A&. A& s~2@ a~4@ i~6@) (=> %%global_location_label%%15 (= i~6@ (vstd!seq.Seq.len.? A&. A& s~2@)))) :pattern ((req%vstd!seq.axiom_seq_push_index_same. A&. A& s~2@ a~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_push_index_same._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_push_index_same._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_index_same")
(declare-fun ens%vstd!seq.axiom_seq_push_index_same. (Dcr Type Poly Poly Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_push_index_same. A&. A& s~2@ a~4@ i~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2@ a~4@) (I i~6@)) a~4@)) :pattern ((ens%vstd!seq.axiom_seq_push_index_same. A&. A& s~2@ a~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_push_index_same._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_index_same._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type a~4$ A&) (has_type i~6$ INT)) (=> (= (%I i~6$) (vstd!seq.Seq.len.? A&. A& s~2$)) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$) i~6$) a~4$))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$) i~6$)) :qid user_vstd__seq__axiom_seq_push_index_same_20 :skolemid skolem_user_vstd__seq__axiom_seq_push_index_same_20)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_push_index_different")
(declare-fun req%vstd!seq.axiom_seq_push_index_different. (Dcr Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%16 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_push_index_different. A&. A& s~2@ a~4@ i~6@) (=> %%global_location_label%%16 (and (<= 0 i~6@) (< i~6@ (vstd!seq.Seq.len.? A&. A& s~2@))))) :pattern ((req%vstd!seq.axiom_seq_push_index_different. A&. A& s~2@ a~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_push_index_different._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_push_index_different._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_index_different")
(declare-fun ens%vstd!seq.axiom_seq_push_index_different. (Dcr Type Poly Poly Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_push_index_different. A&. A& s~2@ a~4@ i~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2@ a~4@) (I i~6@)) (vstd!seq.Seq.index.? A&. A& s~2@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_push_index_different. A&. A& s~2@ a~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_push_index_different._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_index_different._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type a~4$ A&) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (vstd!seq.Seq.len.? A&. A& s~2$))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$) i~6$) (vstd!seq.Seq.index.? A&. A& s~2$ i~6$)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.push.? A&. A& s~2$ a~4$) i~6$)) :qid user_vstd__seq__axiom_seq_push_index_different_21 :skolemid skolem_user_vstd__seq__axiom_seq_push_index_different_21)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_len")
(declare-fun req%vstd!seq.axiom_seq_update_len. (Dcr Type Poly Int Poly) Bool)
(declare-const %%global_location_label%%17 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_len. A&. A& s~2@ i~4@ a~6@) (=> %%global_location_label%%17 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A&. A& s~2@))))) :pattern ((req%vstd!seq.axiom_seq_update_len. A&. A& s~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.axiom_seq_update_len._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_len._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_len")
(declare-fun ens%vstd!seq.axiom_seq_update_len. (Dcr Type Poly Int Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_len. A&. A& s~2@ i~4@ a~6@) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2@ (I i~4@) a~6@)) (vstd!seq.Seq.len.? A&. A& s~2@))) :pattern ((ens%vstd!seq.axiom_seq_update_len. A&. A& s~2@ i~4@ a~6@)) :qid internal_ens__vstd!seq.axiom_seq_update_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (i~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4$ INT) (has_type a~6$ A&)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A&. A& s~2$))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i~4$ a~6$)) (vstd!seq.Seq.len.? A&. A& s~2$)))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i~4$ a~6$))) :qid user_vstd__seq__axiom_seq_update_len_22 :skolemid skolem_user_vstd__seq__axiom_seq_update_len_22)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_same")
(declare-fun req%vstd!seq.axiom_seq_update_same. (Dcr Type Poly Int Poly) Bool)
(declare-const %%global_location_label%%18 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_same. A&. A& s~2@ i~4@ a~6@) (=> %%global_location_label%%18 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A&. A& s~2@))))) :pattern ((req%vstd!seq.axiom_seq_update_same. A&. A& s~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.axiom_seq_update_same._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_same._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_same")
(declare-fun ens%vstd!seq.axiom_seq_update_same. (Dcr Type Poly Int Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_same. A&. A& s~2@ i~4@ a~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2@ (I i~4@) a~6@) (I i~4@)) a~6@)) :pattern ((ens%vstd!seq.axiom_seq_update_same. A&. A& s~2@ i~4@ a~6@)) :qid internal_ens__vstd!seq.axiom_seq_update_same._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_same._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (i~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~4$ INT) (has_type a~6$ A&)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A&. A& s~2$))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i~4$ a~6$) i~4$) a~6$))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i~4$ a~6$) i~4$)) :qid user_vstd__seq__axiom_seq_update_same_23 :skolemid skolem_user_vstd__seq__axiom_seq_update_same_23)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_different")
(declare-fun req%vstd!seq.axiom_seq_update_different. (Dcr Type Poly Int Int Poly) Bool)
(declare-const %%global_location_label%%19 Bool)
(declare-const %%global_location_label%%20 Bool)
(declare-const %%global_location_label%%21 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i1~4@ Int) (i2~6@ Int) (a~8@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_different. A&. A& s~2@ i1~4@ i2~6@ a~8@) (and (=> %%global_location_label%%19 (and (<= 0 i1~4@) (< i1~4@ (vstd!seq.Seq.len.? A&. A& s~2@)))) (=> %%global_location_label%%20 (and (<= 0 i2~6@) (< i2~6@ (vstd!seq.Seq.len.? A&. A& s~2@)))) (=> %%global_location_label%%21 (not (= i1~4@ i2~6@))))) :pattern ((req%vstd!seq.axiom_seq_update_different. A&. A& s~2@ i1~4@ i2~6@ a~8@)) :qid internal_req__vstd!seq.axiom_seq_update_different._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_different._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_different")
(declare-fun ens%vstd!seq.axiom_seq_update_different. (Dcr Type Poly Int Int Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (i1~4@ Int) (i2~6@ Int) (a~8@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_different. A&. A& s~2@ i1~4@ i2~6@ a~8@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2@ (I i2~6@) a~8@) (I i1~4@)) (vstd!seq.Seq.index.? A&. A& s~2@ (I i1~4@)))) :pattern ((ens%vstd!seq.axiom_seq_update_different. A&. A& s~2@ i1~4@ i2~6@ a~8@)) :qid internal_ens__vstd!seq.axiom_seq_update_different._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_different._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (i1~4$ Poly) (i2~6$ Poly) (a~8$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i1~4$ INT) (has_type i2~6$ INT) (has_type a~8$ A&)) (=> (and (and (and (<= 0 (%I i1~4$)) (< (%I i1~4$) (vstd!seq.Seq.len.? A&. A& s~2$))) (and (<= 0 (%I i2~6$)) (< (%I i2~6$) (vstd!seq.Seq.len.? A&. A& s~2$)))) (not (= i1~4$ i2~6$))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i2~6$ a~8$) i1~4$) (vstd!seq.Seq.index.? A&. A& s~2$ i1~4$)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.update.? A&. A& s~2$ i2~6$ a~8$) i1~4$)) :qid user_vstd__seq__axiom_seq_update_different_24 :skolemid skolem_user_vstd__seq__axiom_seq_update_different_24)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_ext_equal")
(declare-fun ens%vstd!seq.axiom_seq_ext_equal. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_ext_equal. A&. A& s1~2@ s2~4@) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1~2@ s2~4@) (and (= (vstd!seq.Seq.len.? A&. A& s1~2@) (vstd!seq.Seq.len.? A&. A& s2~4@)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A&. A& s1~2@))) (= (vstd!seq.Seq.index.? A&. A& s1~2@ i~47$) (vstd!seq.Seq.index.? A&. A& s2~4@ i~47$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1~2@ i~47$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2~4@ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_25 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_25))))) :pattern ((ens%vstd!seq.axiom_seq_ext_equal. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_ext_equal._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_ext_equal._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1~2$ s2~4$) (and (= (vstd!seq.Seq.len.? A&. A& s1~2$) (vstd!seq.Seq.len.? A&. A& s2~4$)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A&. A& s1~2$))) (= (vstd!seq.Seq.index.? A&. A& s1~2$ i~47$) (vstd!seq.Seq.index.? A&. A& s2~4$ i~47$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1~2$ i~47$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2~4$ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_26 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_26))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&. A&) s1~2$ s2~4$)) :qid user_vstd__seq__axiom_seq_ext_equal_27 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_27)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_ext_equal_deep")
(declare-fun ens%vstd!seq.axiom_seq_ext_equal_deep. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_ext_equal_deep. A&. A& s1~2@ s2~4@) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1~2@ s2~4@) (and (= (vstd!seq.Seq.len.? A&. A& s1~2@) (vstd!seq.Seq.len.? A&. A& s2~4@)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A&. A& s1~2@))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1~2@ i~47$) (vstd!seq.Seq.index.? A&. A& s2~4@ i~47$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1~2@ i~47$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2~4@ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_28 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_28))))) :pattern ((ens%vstd!seq.axiom_seq_ext_equal_deep. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_ext_equal_deep._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1~2$ s2~4$) (and (= (vstd!seq.Seq.len.? A&. A& s1~2$) (vstd!seq.Seq.len.? A&. A& s2~4$)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A&. A& s1~2$))) (ext_eq true A& (vstd!seq.Seq.index.? A&. A& s1~2$ i~47$) (vstd!seq.Seq.index.? A&. A& s2~4$ i~47$)))) :pattern ((vstd!seq.Seq.index.? A&. A& s1~2$ i~47$)) :pattern ((vstd!seq.Seq.index.? A&. A& s2~4$ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_29 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_29))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&. A&) s1~2$ s2~4$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_30 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_30)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_subrange_len")
(declare-fun req%vstd!seq.axiom_seq_subrange_len. (Dcr Type Poly Int Int) Bool)
(declare-const %%global_location_label%%22 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int)) (! (= (req%vstd!seq.axiom_seq_subrange_len. A&. A& s~2@ j~4@ k~6@) (=> %%global_location_label%%22 (and (and (<= 0 j~4@) (<= j~4@ k~6@)) (<= k~6@ (vstd!seq.Seq.len.? A&. A& s~2@))))) :pattern ((req%vstd!seq.axiom_seq_subrange_len. A&. A& s~2@ j~4@ k~6@)) :qid internal_req__vstd!seq.axiom_seq_subrange_len._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_subrange_len._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_subrange_len")
(declare-fun ens%vstd!seq.axiom_seq_subrange_len. (Dcr Type Poly Int Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_subrange_len. A&. A& s~2@ j~4@ k~6@) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2@ (I j~4@) (I k~6@))) (Sub k~6@ j~4@))) :pattern ((ens%vstd!seq.axiom_seq_subrange_len. A&. A& s~2@ j~4@ k~6@)) :qid internal_ens__vstd!seq.axiom_seq_subrange_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_subrange_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (j~4$ Poly) (k~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type j~4$ INT) (has_type k~6$ INT)) (=> (and (and (<= 0 (%I j~4$)) (<= (%I j~4$) (%I k~6$))) (<= (%I k~6$) (vstd!seq.Seq.len.? A&. A& s~2$))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2$ j~4$ k~6$)) (Sub (%I k~6$) (%I j~4$))))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2$ j~4$ k~6$))) :qid user_vstd__seq__axiom_seq_subrange_len_31 :skolemid skolem_user_vstd__seq__axiom_seq_subrange_len_31)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_subrange_index")
(declare-fun req%vstd!seq.axiom_seq_subrange_index. (Dcr Type Poly Int Int Int) Bool)
(declare-const %%global_location_label%%23 Bool)
(declare-const %%global_location_label%%24 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int) (i~8@ Int)) (! (= (req%vstd!seq.axiom_seq_subrange_index. A&. A& s~2@ j~4@ k~6@ i~8@) (and (=> %%global_location_label%%23 (and (and (<= 0 j~4@) (<= j~4@ k~6@)) (<= k~6@ (vstd!seq.Seq.len.? A&. A& s~2@)))) (=> %%global_location_label%%24 (and (<= 0 i~8@) (< i~8@ (Sub k~6@ j~4@)))))) :pattern ((req%vstd!seq.axiom_seq_subrange_index. A&. A& s~2@ j~4@ k~6@ i~8@)) :qid internal_req__vstd!seq.axiom_seq_subrange_index._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_subrange_index._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_subrange_index")
(declare-fun ens%vstd!seq.axiom_seq_subrange_index. (Dcr Type Poly Int Int Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int) (i~8@ Int)) (! (= (ens%vstd!seq.axiom_seq_subrange_index. A&. A& s~2@ j~4@ k~6@ i~8@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2@ (I j~4@) (I k~6@)) (I i~8@)) (vstd!seq.Seq.index.? A&. A& s~2@ (I (Add i~8@ j~4@))))) :pattern ((ens%vstd!seq.axiom_seq_subrange_index. A&. A& s~2@ j~4@ k~6@ i~8@)) :qid internal_ens__vstd!seq.axiom_seq_subrange_index._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_subrange_index._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (j~4$ Poly) (k~6$ Poly) (i~8$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type j~4$ INT) (has_type k~6$ INT) (has_type i~8$ INT)) (=> (and (and (and (<= 0 (%I j~4$)) (<= (%I j~4$) (%I k~6$))) (<= (%I k~6$) (vstd!seq.Seq.len.? A&. A& s~2$))) (and (<= 0 (%I i~8$)) (< (%I i~8$) (Sub (%I k~6$) (%I j~4$))))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2$ j~4$ k~6$) i~8$) (vstd!seq.Seq.index.? A&. A& s~2$ (I (Add (%I i~8$) (%I j~4$))))))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.subrange.? A&. A& s~2$ j~4$ k~6$) i~8$)) :qid user_vstd__seq__axiom_seq_subrange_index_32 :skolemid skolem_user_vstd__seq__axiom_seq_subrange_index_32)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_len")
(declare-fun ens%vstd!seq.axiom_seq_add_len. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_add_len. A&. A& s1~2@ s2~4@) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2@ s2~4@)) (nClip (Add (vstd!seq.Seq.len.? A&. A& s1~2@) (vstd!seq.Seq.len.? A&. A& s2~4@))))) :pattern ((ens%vstd!seq.axiom_seq_add_len. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_add_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&. A&))) (= (vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$)) (nClip (Add (vstd!seq.Seq.len.? A&. A& s1~2$) (vstd!seq.Seq.len.? A&. A& s2~4$))))) :pattern ((vstd!seq.Seq.len.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$))) :qid user_vstd__seq__axiom_seq_add_len_33 :skolemid skolem_user_vstd__seq__axiom_seq_add_len_33)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_add_index1")
(declare-fun req%vstd!seq.axiom_seq_add_index1. (Dcr Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%25 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_add_index1. A&. A& s1~2@ s2~4@ i~6@) (=> %%global_location_label%%25 (and (<= 0 i~6@) (< i~6@ (vstd!seq.Seq.len.? A&. A& s1~2@))))) :pattern ((req%vstd!seq.axiom_seq_add_index1. A&. A& s1~2@ s2~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_add_index1._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_add_index1._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_index1")
(declare-fun ens%vstd!seq.axiom_seq_add_index1. (Dcr Type Poly Poly Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_add_index1. A&. A& s1~2@ s2~4@ i~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2@ s2~4@) (I i~6@)) (vstd!seq.Seq.index.? A&. A& s1~2@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_add_index1. A&. A& s1~2@ s2~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_add_index1._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_index1._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (vstd!seq.Seq.len.? A&. A& s1~2$))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$) i~6$) (vstd!seq.Seq.index.? A&. A& s1~2$ i~6$)))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$) i~6$)) :qid user_vstd__seq__axiom_seq_add_index1_34 :skolemid skolem_user_vstd__seq__axiom_seq_add_index1_34)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_add_index2")
(declare-fun req%vstd!seq.axiom_seq_add_index2. (Dcr Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%26 Bool)
(declare-const %%global_location_label%%27 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_add_index2. A&. A& s1~2@ s2~4@ i~6@) (and (=> %%global_location_label%%26 (<= 0 (vstd!seq.Seq.len.? A&. A& s1~2@))) (=> %%global_location_label%%27 (< i~6@ (Add (vstd!seq.Seq.len.? A&. A& s1~2@) (vstd!seq.Seq.len.? A&. A& s2~4@)))))) :pattern ((req%vstd!seq.axiom_seq_add_index2. A&. A& s1~2@ s2~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_add_index2._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_add_index2._definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_index2")
(declare-fun ens%vstd!seq.axiom_seq_add_index2. (Dcr Type Poly Poly Int) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_add_index2. A&. A& s1~2@ s2~4@ i~6@) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2@ s2~4@) (I i~6@)) (vstd!seq.Seq.index.? A&. A& s2~4@ (I (Sub i~6@ (vstd!seq.Seq.len.? A&. A& s1~2@)))))) :pattern ((ens%vstd!seq.axiom_seq_add_index2. A&. A& s1~2@ s2~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_add_index2._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_index2._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&. A&)) (has_type i~6$ INT)) (=> (and (<= 0 (vstd!seq.Seq.len.? A&. A& s1~2$)) (< (%I i~6$) (Add (vstd!seq.Seq.len.? A&. A& s1~2$) (vstd!seq.Seq.len.? A&. A& s2~4$)))) (= (vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$) i~6$) (vstd!seq.Seq.index.? A&. A& s2~4$ (I (Sub (%I i~6$) (vstd!seq.Seq.len.? A&. A& s1~2$))))))) :pattern ((vstd!seq.Seq.index.? A&. A& (vstd!seq.Seq.add.? A&. A& s1~2$ s2~4$) i~6$)) :qid user_vstd__seq__axiom_seq_add_index2_35 :skolemid skolem_user_vstd__seq__axiom_seq_add_index2_35)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::len")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (<= 0 (vstd!set.impl&%0.len.? A&. A& self~2@))) :pattern ((vstd!set.impl&%0.len.? A&. A& self~2@)) :qid internal_vstd!set.impl&__0.len.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.len.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::union")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&. A&))) (has_type (vstd!set.impl&%0.union.? A&. A& self~2@ s2~4@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.union.? A&. A& self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.union.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.union.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::intersect")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&. A&))) (has_type (vstd!set.impl&%0.intersect.? A&. A& self~2@ s2~4@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.intersect.? A&. A& self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.intersect.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.intersect.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::difference")
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&. A&))) (has_type (vstd!set.impl&%0.difference.? A&. A& self~2@ s2~4@) (TYPE%vstd!set.Set. A&. A&))) :pattern ((vstd!set.impl&%0.difference.? A&. A& self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.difference.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.difference.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::choose")
(assert (fuel_bool_default fuel%vstd!set.impl&%0.choose.))
(declare-fun %%choose%%0 (Type Dcr Type Poly Dcr Type Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Dcr) (%%hole%%2 Type) (%%hole%%3 Poly) (%%hole%%4 Dcr) (%%hole%%5 Type) (%%hole%%6 Poly)) (! (=> (exists ((a~10$ Poly)) (! (and (has_type a~10$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a~10$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a~10$)) :qid user_vstd__set__impl&%0__choose_36 :skolemid skolem_user_vstd__set__impl&%0__choose_36)) (exists ((a~10$ Poly)) (! (and (and (has_type a~10$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a~10$)) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) a~10$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a~10$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6)))))
(assert (=> (fuel_bool fuel%vstd!set.impl&%0.choose.) (forall ((A&. Dcr) (A& Type) (self~2@ Poly)) (! (= (vstd!set.impl&%0.choose.? A&. A& self~2@) (as_type (%%choose%%0 A& A&. A& self~2@ A&. A& self~2@) A&)) :pattern ((vstd!set.impl&%0.choose.? A&. A& self~2@)) :qid internal_vstd!set.impl&__0.choose.?_definition :skolemid skolem_internal_vstd!set.impl&__0.choose.?_definition))))
(assert (forall ((A&. Dcr) (A& Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&. A&)) (has_type (vstd!set.impl&%0.choose.? A&. A& self~2@) A&)) :pattern ((vstd!set.impl&%0.choose.? A&. A& self~2@)) :qid internal_vstd!set.impl&__0.choose.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.choose.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty")
(declare-fun ens%vstd!set.axiom_set_empty. (Dcr Type Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (a~2@ Poly)) (! (= (ens%vstd!set.axiom_set_empty. A&. A& a~2@) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a~2@))) :pattern ((ens%vstd!set.axiom_set_empty. A&. A& a~2@)) :qid internal_ens__vstd!set.axiom_set_empty._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty._definition)))
(assert (forall ((A&. Dcr) (A& Type) (a~2$ Poly)) (! (=> (has_type a~2$ A&) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a~2$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.empty.? A&. A&) a~2$)) :qid user_vstd__set__axiom_set_empty_37 :skolemid skolem_user_vstd__set__axiom_set_empty_37)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_new")
(declare-fun ens%vstd!set.axiom_set_new. (Dcr Type %%Function%% Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (f~2@ %%Function%%) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_new. A&. A& f~2@ a~4@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) (Poly%fun%1. f~2@)) a~4@) (%B (%%apply%%0 f~2@ a~4@)))) :pattern ((ens%vstd!set.axiom_set_new. A&. A& f~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_new._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_new._definition)))
(assert (forall ((A&. Dcr) (A& Type) (f~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type f~2$ (TYPE%fun%1. A&. A& $ BOOL)) (has_type a~4$ A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f~2$) a~4$) (%B (%%apply%%0 (%Poly%fun%1. f~2$) a~4$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.new.? A&. A& $ (TYPE%fun%1. A&. A& $ BOOL) f~2$) a~4$)) :qid user_vstd__set__axiom_set_new_38 :skolemid skolem_user_vstd__set__axiom_set_new_38)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_same")
(declare-fun ens%vstd!set.axiom_set_insert_same. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_same. A&. A& s~2@ a~4@) (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2@ a~4@) a~4@)) :pattern ((ens%vstd!set.axiom_set_insert_same. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_same._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_same._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$) a~4$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$) a~4$)) :qid user_vstd__set__axiom_set_insert_same_39 :skolemid skolem_user_vstd__set__axiom_set_insert_same_39)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_different")
(declare-fun req%vstd!set.axiom_set_insert_different. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%28 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (req%vstd!set.axiom_set_insert_different. A&. A& s~2@ a1~4@ a2~6@) (=> %%global_location_label%%28 (not (= a1~4@ a2~6@)))) :pattern ((req%vstd!set.axiom_set_insert_different. A&. A& s~2@ a1~4@ a2~6@)) :qid internal_req__vstd!set.axiom_set_insert_different._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_different._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_different")
(declare-fun ens%vstd!set.axiom_set_insert_different. (Dcr Type Poly Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_different. A&. A& s~2@ a1~4@ a2~6@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2@ a2~6@) a1~4@) (vstd!set.impl&%0.contains.? A&. A& s~2@ a1~4@))) :pattern ((ens%vstd!set.axiom_set_insert_different. A&. A& s~2@ a1~4@ a2~6@)) :qid internal_ens__vstd!set.axiom_set_insert_different._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_different._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a1~4$ Poly) (a2~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a1~4$ A&) (has_type a2~6$ A&)) (=> (not (= a1~4$ a2~6$)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a2~6$) a1~4$) (vstd!set.impl&%0.contains.? A&. A& s~2$ a1~4$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a2~6$) a1~4$)) :qid user_vstd__set__axiom_set_insert_different_40 :skolemid skolem_user_vstd__set__axiom_set_insert_different_40)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_same")
(declare-fun ens%vstd!set.axiom_set_remove_same. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_same. A&. A& s~2@ a~4@) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2@ a~4@) a~4@))) :pattern ((ens%vstd!set.axiom_set_remove_same. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_same._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_same._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (not (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$) a~4$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$) a~4$)) :qid user_vstd__set__axiom_set_remove_same_41 :skolemid skolem_user_vstd__set__axiom_set_remove_same_41)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_different")
(declare-fun req%vstd!set.axiom_set_remove_different. (Dcr Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%29 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (req%vstd!set.axiom_set_remove_different. A&. A& s~2@ a1~4@ a2~6@) (=> %%global_location_label%%29 (not (= a1~4@ a2~6@)))) :pattern ((req%vstd!set.axiom_set_remove_different. A&. A& s~2@ a1~4@ a2~6@)) :qid internal_req__vstd!set.axiom_set_remove_different._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_different._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_different")
(declare-fun ens%vstd!set.axiom_set_remove_different. (Dcr Type Poly Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_different. A&. A& s~2@ a1~4@ a2~6@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2@ a2~6@) a1~4@) (vstd!set.impl&%0.contains.? A&. A& s~2@ a1~4@))) :pattern ((ens%vstd!set.axiom_set_remove_different. A&. A& s~2@ a1~4@ a2~6@)) :qid internal_ens__vstd!set.axiom_set_remove_different._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_different._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a1~4$ Poly) (a2~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a1~4$ A&) (has_type a2~6$ A&)) (=> (not (= a1~4$ a2~6$)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a2~6$) a1~4$) (vstd!set.impl&%0.contains.? A&. A& s~2$ a1~4$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a2~6$) a1~4$)) :qid user_vstd__set__axiom_set_remove_different_42 :skolemid skolem_user_vstd__set__axiom_set_remove_different_42)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_union")
(declare-fun ens%vstd!set.axiom_set_union. (Dcr Type Poly Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_union. A&. A& s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2@ s2~4@) a~6@) (or (vstd!set.impl&%0.contains.? A&. A& s1~2@ a~6@) (vstd!set.impl&%0.contains.? A&. A& s2~4@ a~6@)))) :pattern ((ens%vstd!set.axiom_set_union. A&. A& s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_union._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_union._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2$ s2~4$) a~6$) (or (vstd!set.impl&%0.contains.? A&. A& s1~2$ a~6$) (vstd!set.impl&%0.contains.? A&. A& s2~4$ a~6$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_union_43 :skolemid skolem_user_vstd__set__axiom_set_union_43)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_intersect")
(declare-fun ens%vstd!set.axiom_set_intersect. (Dcr Type Poly Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_intersect. A&. A& s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2@ s2~4@) a~6@) (and (vstd!set.impl&%0.contains.? A&. A& s1~2@ a~6@) (vstd!set.impl&%0.contains.? A&. A& s2~4@ a~6@)))) :pattern ((ens%vstd!set.axiom_set_intersect. A&. A& s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_intersect._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_intersect._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2$ s2~4$) a~6$) (and (vstd!set.impl&%0.contains.? A&. A& s1~2$ a~6$) (vstd!set.impl&%0.contains.? A&. A& s2~4$ a~6$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_intersect_44 :skolemid skolem_user_vstd__set__axiom_set_intersect_44)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_difference")
(declare-fun ens%vstd!set.axiom_set_difference. (Dcr Type Poly Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_difference. A&. A& s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2@ s2~4@) a~6@) (and (vstd!set.impl&%0.contains.? A&. A& s1~2@ a~6@) (not (vstd!set.impl&%0.contains.? A&. A& s2~4@ a~6@))))) :pattern ((ens%vstd!set.axiom_set_difference. A&. A& s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_difference._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_difference._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2$ s2~4$) a~6$) (and (vstd!set.impl&%0.contains.? A&. A& s1~2$ a~6$) (not (vstd!set.impl&%0.contains.? A&. A& s2~4$ a~6$))))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_difference_45 :skolemid skolem_user_vstd__set__axiom_set_difference_45)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_complement")
(declare-fun ens%vstd!set.axiom_set_complement. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_complement. A&. A& s~2@ a~4@) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.complement.? A&. A& s~2@) a~4@) (not (vstd!set.impl&%0.contains.? A&. A& s~2@ a~4@)))) :pattern ((ens%vstd!set.axiom_set_complement. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_complement._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_complement._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (= (vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.complement.? A&. A& s~2$) a~4$) (not (vstd!set.impl&%0.contains.? A&. A& s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& (vstd!set.impl&%0.complement.? A&. A& s~2$) a~4$)) :qid user_vstd__set__axiom_set_complement_46 :skolemid skolem_user_vstd__set__axiom_set_complement_46)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_ext_equal")
(declare-fun ens%vstd!set.axiom_set_ext_equal. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_ext_equal. A&. A& s1~2@ s2~4@) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1~2@ s2~4@) (forall ((a~32$ Poly)) (! (=> (has_type a~32$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1~2@ a~32$) (vstd!set.impl&%0.contains.? A&. A& s2~4@ a~32$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1~2@ a~32$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2~4@ a~32$)) :qid user_vstd__set__axiom_set_ext_equal_47 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_47)))) :pattern ((ens%vstd!set.axiom_set_ext_equal. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_ext_equal._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_ext_equal._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1~2$ s2~4$) (forall ((a~32$ Poly)) (! (=> (has_type a~32$ A&) (= (vstd!set.impl&%0.contains.? A&. A& s1~2$ a~32$) (vstd!set.impl&%0.contains.? A&. A& s2~4$ a~32$))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s1~2$ a~32$)) :pattern ((vstd!set.impl&%0.contains.? A&. A& s2~4$ a~32$)) :qid user_vstd__set__axiom_set_ext_equal_48 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_48)))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&. A&) s1~2$ s2~4$)) :qid user_vstd__set__axiom_set_ext_equal_49 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_49)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_ext_equal_deep")
(declare-fun ens%vstd!set.axiom_set_ext_equal_deep. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_ext_equal_deep. A&. A& s1~2@ s2~4@) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1~2@ s2~4@) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_ext_equal_deep. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_ext_equal_deep._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&. A&) s1~2$ s2~4$) (ext_eq false (TYPE%vstd!set.Set. A&. A&) s1~2$ s2~4$))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&. A&) s1~2$ s2~4$)) :qid user_vstd__set__axiom_set_ext_equal_deep_50 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_deep_50)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_mk_map_domain")
(declare-fun ens%vstd!set.axiom_mk_map_domain. (Dcr Type Dcr Type Poly %%Function%%) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s~2@ Poly) (f~4@ %%Function%%)) (! (= (ens%vstd!set.axiom_mk_map_domain. K&. K& V&. V& s~2@ f~4@) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2@ (Poly%fun%1. f~4@))) s~2@)) :pattern ((ens%vstd!set.axiom_mk_map_domain. K&. K& V&. V& s~2@ f~4@)) :qid internal_ens__vstd!set.axiom_mk_map_domain._definition :skolemid skolem_internal_ens__vstd!set.axiom_mk_map_domain._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s~2$ Poly) (f~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. K&. K&)) (has_type f~4$ (TYPE%fun%1. K&. K& V&. V&))) (= (vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2$ f~4$)) s~2$)) :pattern ((vstd!map.impl&%0.dom.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2$ f~4$))) :qid user_vstd__set__axiom_mk_map_domain_51 :skolemid skolem_user_vstd__set__axiom_mk_map_domain_51)))
(set-info :comment ";; Function-Specs vstd::set::axiom_mk_map_index")
(declare-fun req%vstd!set.axiom_mk_map_index. (Dcr Type Dcr Type Poly %%Function%% Poly) Bool)
(declare-const %%global_location_label%%30 Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s~2@ Poly) (f~4@ %%Function%%) (key~6@ Poly)) (! (= (req%vstd!set.axiom_mk_map_index. K&. K& V&. V& s~2@ f~4@ key~6@) (=> %%global_location_label%%30 (vstd!set.impl&%0.contains.? K&. K& s~2@ key~6@))) :pattern ((req%vstd!set.axiom_mk_map_index. K&. K& V&. V& s~2@ f~4@ key~6@)) :qid internal_req__vstd!set.axiom_mk_map_index._definition :skolemid skolem_internal_req__vstd!set.axiom_mk_map_index._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_mk_map_index")
(declare-fun ens%vstd!set.axiom_mk_map_index. (Dcr Type Dcr Type Poly %%Function%% Poly) Bool)
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s~2@ Poly) (f~4@ %%Function%%) (key~6@ Poly)) (! (= (ens%vstd!set.axiom_mk_map_index. K&. K& V&. V& s~2@ f~4@ key~6@) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2@ (Poly%fun%1. f~4@)) key~6@) (%%apply%%0 f~4@ key~6@))) :pattern ((ens%vstd!set.axiom_mk_map_index. K&. K& V&. V& s~2@ f~4@ key~6@)) :qid internal_ens__vstd!set.axiom_mk_map_index._definition :skolemid skolem_internal_ens__vstd!set.axiom_mk_map_index._definition)))
(assert (forall ((K&. Dcr) (K& Type) (V&. Dcr) (V& Type) (s~2$ Poly) (f~4$ Poly) (key~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. K&. K&)) (has_type f~4$ (TYPE%fun%1. K&. K& V&. V&)) (has_type key~6$ K&)) (=> (vstd!set.impl&%0.contains.? K&. K& s~2$ key~6$) (= (vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2$ f~4$) key~6$) (%%apply%%0 (%Poly%fun%1. f~4$) key~6$)))) :pattern ((vstd!map.impl&%0.index.? K&. K& V&. V& (vstd!set.impl&%0.mk_map.? K&. K& V&. V& $ (TYPE%fun%1. K&. K& V&. V&) s~2$ f~4$) key~6$)) :qid user_vstd__set__axiom_mk_map_index_52 :skolemid skolem_user_vstd__set__axiom_mk_map_index_52)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty_finite")
(declare-fun ens%vstd!set.axiom_set_empty_finite. (Dcr Type) Bool)
(assert (forall ((A&. Dcr) (A& Type)) (! (= (ens%vstd!set.axiom_set_empty_finite. A&. A&) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&))) :pattern ((ens%vstd!set.axiom_set_empty_finite. A&. A&)) :qid internal_ens__vstd!set.axiom_set_empty_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type)) (! (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.empty.? A&. A&))) :qid user_vstd__set__axiom_set_empty_finite_53 :skolemid skolem_user_vstd__set__axiom_set_empty_finite_53)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_finite")
(declare-fun req%vstd!set.axiom_set_insert_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%31 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_insert_finite. A&. A& s~2@ a~4@) (=> %%global_location_label%%31 (vstd!set.impl&%0.finite.? A&. A& s~2@))) :pattern ((req%vstd!set.axiom_set_insert_finite. A&. A& s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_insert_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_finite")
(declare-fun ens%vstd!set.axiom_set_insert_finite. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_finite. A&. A& s~2@ a~4@) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2@ a~4@))) :pattern ((ens%vstd!set.axiom_set_insert_finite. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s~2$) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$))) :qid user_vstd__set__axiom_set_insert_finite_54 :skolemid skolem_user_vstd__set__axiom_set_insert_finite_54)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_finite")
(declare-fun req%vstd!set.axiom_set_remove_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%32 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_remove_finite. A&. A& s~2@ a~4@) (=> %%global_location_label%%32 (vstd!set.impl&%0.finite.? A&. A& s~2@))) :pattern ((req%vstd!set.axiom_set_remove_finite. A&. A& s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_remove_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_finite")
(declare-fun ens%vstd!set.axiom_set_remove_finite. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_finite. A&. A& s~2@ a~4@) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2@ a~4@))) :pattern ((ens%vstd!set.axiom_set_remove_finite. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s~2$) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$))) :qid user_vstd__set__axiom_set_remove_finite_55 :skolemid skolem_user_vstd__set__axiom_set_remove_finite_55)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_union_finite")
(declare-fun req%vstd!set.axiom_set_union_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%33 Bool)
(declare-const %%global_location_label%%34 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_union_finite. A&. A& s1~2@ s2~4@) (and (=> %%global_location_label%%33 (vstd!set.impl&%0.finite.? A&. A& s1~2@)) (=> %%global_location_label%%34 (vstd!set.impl&%0.finite.? A&. A& s2~4@)))) :pattern ((req%vstd!set.axiom_set_union_finite. A&. A& s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_union_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_union_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_union_finite")
(declare-fun ens%vstd!set.axiom_set_union_finite. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_union_finite. A&. A& s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_union_finite. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_union_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_union_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&))) (=> (and (vstd!set.impl&%0.finite.? A&. A& s1~2$) (vstd!set.impl&%0.finite.? A&. A& s2~4$)) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.union.? A&. A& s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_union_finite_56 :skolemid skolem_user_vstd__set__axiom_set_union_finite_56)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_intersect_finite")
(declare-fun req%vstd!set.axiom_set_intersect_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%35 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_intersect_finite. A&. A& s1~2@ s2~4@) (=> %%global_location_label%%35 (or (vstd!set.impl&%0.finite.? A&. A& s1~2@) (vstd!set.impl&%0.finite.? A&. A& s2~4@)))) :pattern ((req%vstd!set.axiom_set_intersect_finite. A&. A& s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_intersect_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_intersect_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_intersect_finite")
(declare-fun ens%vstd!set.axiom_set_intersect_finite. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_intersect_finite. A&. A& s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_intersect_finite. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_intersect_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_intersect_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&))) (=> (or (vstd!set.impl&%0.finite.? A&. A& s1~2$) (vstd!set.impl&%0.finite.? A&. A& s2~4$)) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.intersect.? A&. A& s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_intersect_finite_57 :skolemid skolem_user_vstd__set__axiom_set_intersect_finite_57)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_difference_finite")
(declare-fun req%vstd!set.axiom_set_difference_finite. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%36 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_difference_finite. A&. A& s1~2@ s2~4@) (=> %%global_location_label%%36 (vstd!set.impl&%0.finite.? A&. A& s1~2@))) :pattern ((req%vstd!set.axiom_set_difference_finite. A&. A& s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_difference_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_difference_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_difference_finite")
(declare-fun ens%vstd!set.axiom_set_difference_finite. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_difference_finite. A&. A& s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_difference_finite. A&. A& s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_difference_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_difference_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&. A&))) (=> (vstd!set.impl&%0.finite.? A&. A& s1~2$) (vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A&. A& (vstd!set.impl&%0.difference.? A&. A& s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_difference_finite_58 :skolemid skolem_user_vstd__set__axiom_set_difference_finite_58)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_choose_finite")
(declare-fun req%vstd!set.axiom_set_choose_finite. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%37 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly)) (! (= (req%vstd!set.axiom_set_choose_finite. A&. A& s~2@) (=> %%global_location_label%%37 (not (vstd!set.impl&%0.finite.? A&. A& s~2@)))) :pattern ((req%vstd!set.axiom_set_choose_finite. A&. A& s~2@)) :qid internal_req__vstd!set.axiom_set_choose_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_choose_finite._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_choose_finite")
(declare-fun ens%vstd!set.axiom_set_choose_finite. (Dcr Type Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly)) (! (= (ens%vstd!set.axiom_set_choose_finite. A&. A& s~2@) (vstd!set.impl&%0.contains.? A&. A& s~2@ (vstd!set.impl&%0.choose.? A&. A& s~2@))) :pattern ((ens%vstd!set.axiom_set_choose_finite. A&. A& s~2@)) :qid internal_ens__vstd!set.axiom_set_choose_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_choose_finite._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly)) (! (=> (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (=> (not (vstd!set.impl&%0.finite.? A&. A& s~2$)) (vstd!set.impl&%0.contains.? A&. A& s~2$ (vstd!set.impl&%0.choose.? A&. A& s~2$)))) :pattern ((vstd!set.impl&%0.contains.? A&. A& s~2$ (vstd!set.impl&%0.choose.? A&. A& s~2$))) :qid user_vstd__set__axiom_set_choose_finite_59 :skolemid skolem_user_vstd__set__axiom_set_choose_finite_59)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty_len")
(declare-fun ens%vstd!set.axiom_set_empty_len. (Dcr Type) Bool)
(assert (forall ((A&. Dcr) (A& Type)) (! (= (ens%vstd!set.axiom_set_empty_len. A&. A&) (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) 0)) :pattern ((ens%vstd!set.axiom_set_empty_len. A&. A&)) :qid internal_ens__vstd!set.axiom_set_empty_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty_len._definition)))
(assert (forall ((A&. Dcr) (A& Type)) (! (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&)) 0) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.empty.? A&. A&))) :qid user_vstd__set__axiom_set_empty_len_60 :skolemid skolem_user_vstd__set__axiom_set_empty_len_60)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_len")
(declare-fun req%vstd!set.axiom_set_insert_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%38 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_insert_len. A&. A& s~2@ a~4@) (=> %%global_location_label%%38 (vstd!set.impl&%0.finite.? A&. A& s~2@))) :pattern ((req%vstd!set.axiom_set_insert_len. A&. A& s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_insert_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_len._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_len")
(declare-fun ens%vstd!set.axiom_set_insert_len. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_len. A&. A& s~2@ a~4@) (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2@ a~4@)) (Add (vstd!set.impl&%0.len.? A&. A& s~2@) (ite (vstd!set.impl&%0.contains.? A&. A& s~2@ a~4@) 0 1)))) :pattern ((ens%vstd!set.axiom_set_insert_len. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s~2$) (= (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$)) (Add (vstd!set.impl&%0.len.? A&. A& s~2$) (ite (vstd!set.impl&%0.contains.? A&. A& s~2$ a~4$) 0 1))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.insert.? A&. A& s~2$ a~4$))) :qid user_vstd__set__axiom_set_insert_len_61 :skolemid skolem_user_vstd__set__axiom_set_insert_len_61)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_len")
(declare-fun req%vstd!set.axiom_set_remove_len. (Dcr Type Poly Poly) Bool)
(declare-const %%global_location_label%%39 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_remove_len. A&. A& s~2@ a~4@) (=> %%global_location_label%%39 (vstd!set.impl&%0.finite.? A&. A& s~2@))) :pattern ((req%vstd!set.axiom_set_remove_len. A&. A& s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_remove_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_len._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_len")
(declare-fun ens%vstd!set.axiom_set_remove_len. (Dcr Type Poly Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_len. A&. A& s~2@ a~4@) (= (vstd!set.impl&%0.len.? A&. A& s~2@) (Add (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2@ a~4@)) (ite (vstd!set.impl&%0.contains.? A&. A& s~2@ a~4@) 1 0)))) :pattern ((ens%vstd!set.axiom_set_remove_len. A&. A& s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A&. A& s~2$) (= (vstd!set.impl&%0.len.? A&. A& s~2$) (Add (vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$)) (ite (vstd!set.impl&%0.contains.? A&. A& s~2$ a~4$) 1 0))))) :pattern ((vstd!set.impl&%0.len.? A&. A& (vstd!set.impl&%0.remove.? A&. A& s~2$ a~4$))) :qid user_vstd__set__axiom_set_remove_len_62 :skolemid skolem_user_vstd__set__axiom_set_remove_len_62)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_choose_len")
(declare-fun req%vstd!set.axiom_set_choose_len. (Dcr Type Poly) Bool)
(declare-const %%global_location_label%%40 Bool)
(declare-const %%global_location_label%%41 Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly)) (! (= (req%vstd!set.axiom_set_choose_len. A&. A& s~2@) (and (=> %%global_location_label%%40 (vstd!set.impl&%0.finite.? A&. A& s~2@)) (=> %%global_location_label%%41 (not (= (vstd!set.impl&%0.len.? A&. A& s~2@) 0))))) :pattern ((req%vstd!set.axiom_set_choose_len. A&. A& s~2@)) :qid internal_req__vstd!set.axiom_set_choose_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_choose_len._definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_choose_len")
(declare-fun ens%vstd!set.axiom_set_choose_len. (Dcr Type Poly) Bool)
(assert (forall ((A&. Dcr) (A& Type) (s~2@ Poly)) (! (= (ens%vstd!set.axiom_set_choose_len. A&. A& s~2@) (vstd!set.impl&%0.contains.? A&. A& s~2@ (vstd!set.impl&%0.choose.? A&. A& s~2@))) :pattern ((ens%vstd!set.axiom_set_choose_len. A&. A& s~2@)) :qid internal_ens__vstd!set.axiom_set_choose_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_choose_len._definition)))
(assert (forall ((A&. Dcr) (A& Type) (s~2$ Poly)) (! (=> (has_type s~2$ (TYPE%vstd!set.Set. A&. A&)) (=> (and (vstd!set.impl&%0.finite.? A&. A& s~2$) (not (= (vstd!set.impl&%0.len.? A&. A& s~2$) 0))) (vstd!set.impl&%0.contains.? A&. A& s~2$ (vstd!set.impl&%0.choose.? A&. A& s~2$)))) :pattern ((vstd!set.impl&%0.len.? A&. A& s~2$) (vstd!set.impl&%0.contains.? A&. A& s~2$ (vstd!set.impl&%0.choose.? A&. A& s~2$))) :qid user_vstd__set__axiom_set_choose_len_63 :skolemid skolem_user_vstd__set__axiom_set_choose_len_63)))
(set-info :comment ";; Function-Axioms crate::arith::are_valid_rns_moduli")
(assert (fuel_bool_default fuel%crate!arith.are_valid_rns_moduli.))
(assert (=> (fuel_bool fuel%crate!arith.are_valid_rns_moduli.) (forall ((rns_moduli~2@ Poly)) (! (= (crate!arith.are_valid_rns_moduli.? rns_moduli~2@) (and (and (> (vstd!seq.Seq.len.? $ INT rns_moduli~2@) 0) (forall ((i~24$ Poly)) (! (=> (has_type i~24$ INT) (=> (and (<= 0 (%I i~24$)) (< (%I i~24$) (vstd!seq.Seq.len.? $ INT rns_moduli~2@))) (> (%I (vstd!seq.Seq.index.? $ INT rns_moduli~2@ i~24$)) 1))) :pattern ((vstd!seq.Seq.index.? $ INT rns_moduli~2@ i~24$)) :qid user_crate__arith__are_valid_rns_moduli_64 :skolemid skolem_user_crate__arith__are_valid_rns_moduli_64))) (crate!arith.are_pairwise_coprime.? rns_moduli~2@))) :pattern ((crate!arith.are_valid_rns_moduli.? rns_moduli~2@)) :qid internal_crate!arith.are_valid_rns_moduli.?_definition :skolemid skolem_internal_crate!arith.are_valid_rns_moduli.?_definition))))
(set-info :comment ";; Function-Axioms crate::arith::product_of")
(assert (fuel_bool_default fuel%crate!arith.product_of.))
(declare-const fuel_nat%crate!arith.product_of. Fuel)
(assert (forall ((s~2@ Poly) (fuel%@ Fuel)) (! (= (crate!arith.rec%product_of.? s~2@ fuel%@) (crate!arith.rec%product_of.? s~2@ zero)) :pattern ((crate!arith.rec%product_of.? s~2@ fuel%@)) :qid internal_crate!arith.product_of._fuel_to_zero_definition :skolemid skolem_internal_crate!arith.product_of._fuel_to_zero_definition)))
(assert (forall ((s~2@ Poly) (fuel%@ Fuel)) (! (= (crate!arith.rec%product_of.? s~2@ (succ fuel%@)) (ite (= (vstd!seq.Seq.len.? $ INT s~2@) 0) 1 (Mul (%I (vstd!seq.Seq.index.? $ INT s~2@ (I 0))) (crate!arith.rec%product_of.? (vstd!seq.Seq.subrange.? $ INT s~2@ (I 1) (I (vstd!seq.Seq.len.? $ INT s~2@))) fuel%@)))) :pattern ((crate!arith.rec%product_of.? s~2@ (succ fuel%@))) :qid internal_crate!arith.product_of._fuel_to_body_definition :skolemid skolem_internal_crate!arith.product_of._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%crate!arith.product_of.) (forall ((s~2@ Poly)) (! (= (crate!arith.product_of.? s~2@) (crate!arith.rec%product_of.? s~2@ (succ fuel_nat%crate!arith.product_of.))) :pattern ((crate!arith.product_of.? s~2@)) :qid internal_crate!arith.product_of.?_definition :skolemid skolem_internal_crate!arith.product_of.?_definition))))
(set-info :comment ";; Function-Axioms crate::semantics::Parameters::valid")
(assert (fuel_bool_default fuel%crate!semantics.impl&%0.valid.))
(assert (=> (fuel_bool fuel%crate!semantics.impl&%0.valid.) (forall ((self~2@ Poly)) (! (= (crate!semantics.impl&%0.valid.? self~2@) (and (and (crate!arith.are_valid_rns_moduli.? (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. self~2@)))) (= (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. self~2@)))) (crate!semantics.Parameters./Parameters/modulus (%Poly%crate!semantics.Parameters. self~2@)))) (= (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. self~2@)) (nClip (Add (crate!semantics.Parameters./Parameters/log_num_tiles (%Poly%crate!semantics.Parameters. self~2@)) (crate!semantics.Parameters./Parameters/log_num_rows (%Poly%crate!semantics.Parameters. self~2@))))))) :pattern ((crate!semantics.impl&%0.valid.? self~2@)) :qid internal_crate!semantics.impl&__0.valid.?_definition :skolemid skolem_internal_crate!semantics.impl&__0.valid.?_definition))))
(set-info :comment ";; Function-Axioms crate::arith::pow2")
(assert (fuel_bool_default fuel%crate!arith.pow2.))
(declare-const fuel_nat%crate!arith.pow2. Fuel)
(assert (forall ((n~2@ Poly) (fuel%@ Fuel)) (! (= (crate!arith.rec%pow2.? n~2@ fuel%@) (crate!arith.rec%pow2.? n~2@ zero)) :pattern ((crate!arith.rec%pow2.? n~2@ fuel%@)) :qid internal_crate!arith.pow2._fuel_to_zero_definition :skolemid skolem_internal_crate!arith.pow2._fuel_to_zero_definition)))
(assert (forall ((n~2@ Poly) (fuel%@ Fuel)) (! (= (crate!arith.rec%pow2.? n~2@ (succ fuel%@)) (ite (= (%I n~2@) 0) 1 (nClip (Mul 2 (crate!arith.rec%pow2.? (I (nClip (Sub (%I n~2@) 1))) fuel%@))))) :pattern ((crate!arith.rec%pow2.? n~2@ (succ fuel%@))) :qid internal_crate!arith.pow2._fuel_to_body_definition :skolemid skolem_internal_crate!arith.pow2._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%crate!arith.pow2.) (forall ((n~2@ Poly)) (! (= (crate!arith.pow2.? n~2@) (crate!arith.rec%pow2.? n~2@ (succ fuel_nat%crate!arith.pow2.))) :pattern ((crate!arith.pow2.? n~2@)) :qid internal_crate!arith.pow2.?_definition :skolemid skolem_internal_crate!arith.pow2.?_definition))))
(assert (forall ((n~2@ Poly)) (! (=> (has_type n~2@ NAT) (<= 0 (crate!arith.pow2.? n~2@))) :pattern ((crate!arith.pow2.? n~2@)) :qid internal_crate!arith.pow2.?_pre_post_definition :skolemid skolem_internal_crate!arith.pow2.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::Polynomial::valid")
(declare-fun req%crate!semantics.Abstract.impl&%0.valid. (Poly Poly) Bool)
(declare-const %%global_location_label%%42 Bool)
(assert (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%0.valid. self~2@ params~4@) (=> %%global_location_label%%42 (crate!semantics.impl&%0.valid.? params~4@))) :pattern ((req%crate!semantics.Abstract.impl&%0.valid. self~2@ params~4@)) :qid internal_req__crate!semantics.Abstract.impl&__0.valid._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__0.valid._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::Polynomial::valid")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%0.valid.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%0.valid.) (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%0.valid.? self~2@ params~4@) (and (and (and (> (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. self~2@)))) 0) (= (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. self~2@)))) (crate!arith.pow2.? (I (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. self~2@)))))) (>= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. self~2@)) (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. params~4@)))) (forall ((i~63$ Poly)) (! (=> (has_type i~63$ INT) (=> (and (<= 0 (%I i~63$)) (< (%I i~63$) (crate!arith.pow2.? (I (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. self~2@)))))) (let ((tmp%%1$ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. self~2@))) i~63$)))) (and (<= 0 tmp%%1$) (< tmp%%1$ (crate!semantics.Parameters./Parameters/modulus (%Poly%crate!semantics.Parameters. params~4@))))))) :pattern ((vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. self~2@))) i~63$)) :qid user_crate__semantics__Abstract__Polynomial__valid_65 :skolemid skolem_user_crate__semantics__Abstract__Polynomial__valid_65)))) :pattern ((crate!semantics.Abstract.impl&%0.valid.? self~2@ params~4@)) :qid internal_crate!semantics.Abstract.impl&__0.valid.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__0.valid.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Parameters::block_size")
(declare-fun req%crate!semantics.impl&%0.block_size. (Poly) Bool)
(declare-const %%global_location_label%%43 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%crate!semantics.impl&%0.block_size. self~2@) (=> %%global_location_label%%43 (crate!semantics.impl&%0.valid.? self~2@))) :pattern ((req%crate!semantics.impl&%0.block_size. self~2@)) :qid internal_req__crate!semantics.impl&__0.block_size._definition :skolemid skolem_internal_req__crate!semantics.impl&__0.block_size._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Parameters::block_size")
(assert (fuel_bool_default fuel%crate!semantics.impl&%0.block_size.))
(assert (=> (fuel_bool fuel%crate!semantics.impl&%0.block_size.) (forall ((self~2@ Poly)) (! (= (crate!semantics.impl&%0.block_size.? self~2@) (crate!arith.pow2.? (I (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. self~2@))))) :pattern ((crate!semantics.impl&%0.block_size.? self~2@)) :qid internal_crate!semantics.impl&__0.block_size.?_definition :skolemid skolem_internal_crate!semantics.impl&__0.block_size.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%crate!semantics.Parameters.) (<= 0 (crate!semantics.impl&%0.block_size.? self~2@))) :pattern ((crate!semantics.impl&%0.block_size.? self~2@)) :qid internal_crate!semantics.impl&__0.block_size.?_pre_post_definition :skolemid skolem_internal_crate!semantics.impl&__0.block_size.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::Polynomial::to_machine")
(declare-fun req%crate!semantics.Abstract.impl&%0.to_machine. (Poly Poly) Bool)
(declare-const %%global_location_label%%44 Bool)
(declare-const %%global_location_label%%45 Bool)
(assert (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%0.to_machine. self~2@ params~4@) (and (=> %%global_location_label%%44 (and (crate!semantics.impl&%0.valid.? params~4@) (crate!semantics.Abstract.impl&%0.valid.? self~2@ params~4@))) (=> %%global_location_label%%45 (>= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. self~2@)) (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. params~4@)))))) :pattern ((req%crate!semantics.Abstract.impl&%0.to_machine. self~2@ params~4@)) :qid internal_req__crate!semantics.Abstract.impl&__0.to_machine._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__0.to_machine._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::Polynomial::to_machine")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%0.to_machine.))
(declare-fun %%lambda%%0 (Poly Poly Dcr Type Poly Int) %%Function%%)
(assert (forall ((%%hole%%0 Poly) (%%hole%%1 Poly) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (%%hole%%5 Int) (k~114$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k~114$) (I (EucMod (%I (vstd!seq.Seq.index.? %%hole%%2 %%hole%%3 %%hole%%4 (I (crate!semantics.block_index_to_coeff_index.? %%hole%%0 %%hole%%1 k~114$)))) %%hole%%5))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k~114$)))))
(declare-fun %%lambda%%1 (Poly Dcr Type Poly Int Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Poly) (%%hole%%1 Dcr) (%%hole%%2 Type) (%%hole%%3 Poly) (%%hole%%4 Int) (%%hole%%5 Dcr) (%%hole%%6 Type) (%%hole%%7 Dcr) (%%hole%%8 Type) (%%hole%%9 Poly) (j~99$ Poly)) (! (= (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9) j~99$) (vstd!seq.Seq.new.? %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 (Poly%fun%1. (mk_fun (%%lambda%%0 %%hole%%0 j~99$ %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4))))) :pattern ((%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9) j~99$)))))
(declare-fun %%lambda%%2 (Dcr Type Poly Poly Dcr Type Poly Dcr Type Dcr Type Poly Dcr Type Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Poly) (%%hole%%4 Dcr) (%%hole%%5 Type) (%%hole%%6 Poly) (%%hole%%7 Dcr) (%%hole%%8 Type) (%%hole%%9 Dcr) (%%hole%%10 Type) (%%hole%%11 Poly) (%%hole%%12 Dcr) (%%hole%%13 Type) (%%hole%%14 Dcr) (%%hole%%15 Type) (%%hole%%16 Poly) (i~81$ Poly)) (! (= (%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16) i~81$) (vstd!seq.Seq.new.? %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16 (Poly%fun%1. (mk_fun (%%lambda%%1 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 (%I (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 i~81$)) %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11))))) :pattern ((%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 %%hole%%13 %%hole%%14 %%hole%%15 %%hole%%16) i~81$)))))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%0.to_machine.) (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%0.to_machine.? self~2@ params~4@) (let ((log_num_blocks~49$ (nClip (Sub (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. self~2@)) (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. params~4@)))))) (let ((block_size~56$ (crate!semantics.impl&%0.block_size.? params~4@))) (crate!semantics.Machine.Polynomial./Polynomial (%I (I log_num_blocks~49$)) (%Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (vstd!seq.Seq.new.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) $ (TYPE%fun%1. $ INT $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))) (I (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. params~4@))))) (Poly%fun%1. (mk_fun (%%lambda%%2 $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. params~4@))) params~4@ $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. self~2@))) $ INT $ (TYPE%fun%1. $ INT $ INT) (I block_size~56$) $ (TYPE%vstd!seq.Seq. $ INT) $ (TYPE%fun%1. $ INT $ (TYPE%vstd!seq.Seq. $ INT)) (I (crate!arith.pow2.? (I log_num_blocks~49$)))))))))))) :pattern ((crate!semantics.Abstract.impl&%0.to_machine.? self~2@ params~4@)) :qid internal_crate!semantics.Abstract.impl&__0.to_machine.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__0.to_machine.?_definition))))
(assert (forall ((self~2@ Poly) (params~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Abstract.Polynomial.) (has_type params~4@ TYPE%crate!semantics.Parameters.)) (has_type (Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Abstract.impl&%0.to_machine.? self~2@ params~4@)) TYPE%crate!semantics.Machine.Polynomial.)) :pattern ((crate!semantics.Abstract.impl&%0.to_machine.? self~2@ params~4@)) :qid internal_crate!semantics.Abstract.impl&__0.to_machine.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__0.to_machine.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::Register::new")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%1.new.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%1.new.) (forall ((name~2@ Poly)) (! (= (crate!semantics.Abstract.impl&%1.new.? name~2@) (crate!semantics.Abstract.Register./Register (%I name~2@))) :pattern ((crate!semantics.Abstract.impl&%1.new.? name~2@)) :qid internal_crate!semantics.Abstract.impl&__1.new.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__1.new.?_definition))))
(assert (forall ((name~2@ Poly)) (! (=> (has_type name~2@ (SINT 32)) (has_type (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? name~2@)) TYPE%crate!semantics.Abstract.Register.)) :pattern ((crate!semantics.Abstract.impl&%1.new.? name~2@)) :qid internal_crate!semantics.Abstract.impl&__1.new.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__1.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::valid")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.valid.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.valid.) (forall ((self~2@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.valid.? self~2@) (and (crate!semantics.impl&%0.valid.? (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))) (forall ((name~16$ Poly)) (! (=> (has_type name~16$ (SINT 32)) (=> (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@)))) name~16$) (crate!semantics.Abstract.impl&%0.valid.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@))) name~16$) (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@)))) name~16$)) :qid user_crate__semantics__Abstract__State__valid_66 :skolemid skolem_user_crate__semantics__Abstract__State__valid_66)))) :pattern ((crate!semantics.Abstract.impl&%2.valid.? self~2@)) :qid internal_crate!semantics.Abstract.impl&__2.valid.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.valid.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::valid_register")
(declare-fun req%crate!semantics.Abstract.impl&%2.valid_register. (Poly Poly) Bool)
(declare-const %%global_location_label%%46 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.valid_register. self~2@ reg~4@) (=> %%global_location_label%%46 (crate!semantics.Abstract.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Abstract.impl&%2.valid_register. self~2@ reg~4@)) :qid internal_req__crate!semantics.Abstract.impl&__2.valid_register._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.valid_register._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::valid_register")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.valid_register.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.valid_register.) (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ reg~4@) (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@)))) (I (crate!semantics.Abstract.Register./Register/name (%Poly%crate!semantics.Abstract.Register. reg~4@))))) :pattern ((crate!semantics.Abstract.impl&%2.valid_register.? self~2@ reg~4@)) :qid internal_crate!semantics.Abstract.impl&__2.valid_register.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.valid_register.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::get")
(declare-fun req%crate!semantics.Abstract.impl&%2.get. (Poly Poly) Bool)
(declare-const %%global_location_label%%47 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.get. self~2@ reg~4@) (=> %%global_location_label%%47 (and (crate!semantics.Abstract.impl&%2.valid.? self~2@) (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ reg~4@)))) :pattern ((req%crate!semantics.Abstract.impl&%2.get. self~2@ reg~4@)) :qid internal_req__crate!semantics.Abstract.impl&__2.get._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.get._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::get")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.get.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.get.) (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@) (%Poly%crate!semantics.Abstract.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@))) (I (crate!semantics.Abstract.Register./Register/name (%Poly%crate!semantics.Abstract.Register. reg~4@)))))) :pattern ((crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@)) :qid internal_crate!semantics.Abstract.impl&__2.get.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.get.?_definition))))
(assert (forall ((self~2@ Poly) (reg~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Abstract.State.) (has_type reg~4@ TYPE%crate!semantics.Abstract.Register.)) (has_type (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@)) TYPE%crate!semantics.Abstract.Polynomial.)) :pattern ((crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@)) :qid internal_crate!semantics.Abstract.impl&__2.get.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.get.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::valid_instruction")
(declare-fun req%crate!semantics.Abstract.impl&%2.valid_instruction. (Poly Poly) Bool)
(declare-const %%global_location_label%%48 Bool)
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.valid_instruction. self~2@ instr~4@) (=> %%global_location_label%%48 (crate!semantics.Abstract.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Abstract.impl&%2.valid_instruction. self~2@ instr~4@)) :qid internal_req__crate!semantics.Abstract.impl&__2.valid_instruction._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.valid_instruction._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::valid_instruction")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.valid_instruction.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.valid_instruction.) (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.valid_instruction.? self~2@ instr~4@) (ite (or ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) ((_ is crate!semantics.Abstract.Instruction./Mul) (%Poly%crate!semantics.Abstract.Instruction. instr~4@))) (let ((log_degree~21$ (ite ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Add/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Mul/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@))))) (let ((r_out~22$ (ite ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Add/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Mul/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@))))) (let ((r_in1~23$ (ite ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Add/_2 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Mul/_2 (%Poly%crate!semantics.Abstract.Instruction. instr~4@))))) (let ((r_in2~24$ (ite ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Add/_3 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (crate!semantics.Abstract.Instruction./Mul/_3 (%Poly%crate!semantics.Abstract.Instruction. instr~4@))))) (and (and (and (and (and (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Abstract.Register. r_out~22$)) (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in1~23$))) (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in2~24$))) (= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_out~22$))))) log_degree~21$)) (= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in1~23$))))) log_degree~21$)) (= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in2~24$))))) log_degree~21$)))))) (let ((log_degree~102$ (crate!semantics.Abstract.Instruction./NTT/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((reg~103$ (crate!semantics.Abstract.Instruction./NTT/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (and (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Abstract.Register. reg~103$)) (= (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. reg~103$))))) log_degree~102$)))))) :pattern ((crate!semantics.Abstract.impl&%2.valid_instruction.? self~2@ instr~4@)) :qid internal_crate!semantics.Abstract.impl&__2.valid_instruction.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.valid_instruction.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::set")
(declare-fun req%crate!semantics.Abstract.impl&%2.set. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%49 Bool)
(declare-const %%global_location_label%%50 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly) (coeffs~6@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.set. self~2@ reg~4@ coeffs~6@) (and (=> %%global_location_label%%49 (and (crate!semantics.Abstract.impl&%2.valid.? self~2@) (crate!semantics.Abstract.impl&%2.valid_register.? self~2@ reg~4@))) (=> %%global_location_label%%50 (= (vstd!seq.Seq.len.? $ INT coeffs~6@) (crate!arith.pow2.? (I (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@)))))))))) :pattern ((req%crate!semantics.Abstract.impl&%2.set. self~2@ reg~4@ coeffs~6@)) :qid internal_req__crate!semantics.Abstract.impl&__2.set._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.set._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::set")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.set.))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.set.) (forall ((self~2@ Poly) (reg~4@ Poly) (coeffs~6@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.set.? self~2@ reg~4@ coeffs~6@) (crate!semantics.Abstract.State./State (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))) (%Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (vstd!map.impl&%0.insert.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@))) (I (crate!semantics.Abstract.Register./Register/name (%Poly%crate!semantics.Abstract.Register. reg~4@))) (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.Polynomial./Polynomial (%I (I (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. (crate!semantics.Abstract.impl&%2.get.? self~2@ reg~4@)))))) (%Poly%vstd!seq.Seq<int.>. coeffs~6@))))))) :pattern ((crate!semantics.Abstract.impl&%2.set.? self~2@ reg~4@ coeffs~6@)) :qid internal_crate!semantics.Abstract.impl&__2.set.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.set.?_definition))))
(assert (forall ((self~2@ Poly) (reg~4@ Poly) (coeffs~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Abstract.State.) (has_type reg~4@ TYPE%crate!semantics.Abstract.Register.) (has_type coeffs~6@ (TYPE%vstd!seq.Seq. $ INT))) (has_type (Poly%crate!semantics.Abstract.State. (crate!semantics.Abstract.impl&%2.set.? self~2@ reg~4@ coeffs~6@)) TYPE%crate!semantics.Abstract.State.)) :pattern ((crate!semantics.Abstract.impl&%2.set.? self~2@ reg~4@ coeffs~6@)) :qid internal_crate!semantics.Abstract.impl&__2.set.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.set.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::step")
(declare-fun req%crate!semantics.Abstract.impl&%2.step. (Poly Poly) Bool)
(declare-const %%global_location_label%%51 Bool)
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.step. self~2@ instr~4@) (=> %%global_location_label%%51 (and (crate!semantics.Abstract.impl&%2.valid.? self~2@) (crate!semantics.Abstract.impl&%2.valid_instruction.? self~2@ instr~4@)))) :pattern ((req%crate!semantics.Abstract.impl&%2.step. self~2@ instr~4@)) :qid internal_req__crate!semantics.Abstract.impl&__2.step._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.step._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::step")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.step.))
(declare-fun %%lambda%%3 (Dcr Type Poly Dcr Type Poly Int) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Poly) (%%hole%%6 Int) (i~76$ Poly)) (! (= (%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) i~76$) (I (EucMod (Add (%I (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 i~76$)) (%I (vstd!seq.Seq.index.? %%hole%%3 %%hole%%4 %%hole%%5 i~76$))) %%hole%%6))) :pattern ((%%apply%%0 (%%lambda%%3 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) i~76$)))))
(declare-fun %%lambda%%4 (Dcr Type Poly Dcr Type Poly Int) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Dcr) (%%hole%%4 Type) (%%hole%%5 Poly) (%%hole%%6 Int) (i~152$ Poly)) (! (= (%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) i~152$) (I (EucMod (Mul (%I (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 i~152$)) (%I (vstd!seq.Seq.index.? %%hole%%3 %%hole%%4 %%hole%%5 i~152$))) %%hole%%6))) :pattern ((%%apply%%0 (%%lambda%%4 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) i~152$)))))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.step.) (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.step.? self~2@ instr~4@) (ite ((_ is crate!semantics.Abstract.Instruction./Add) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (let ((log_degree~28$ (crate!semantics.Abstract.Instruction./Add/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_out~29$ (crate!semantics.Abstract.Instruction./Add/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_in1~30$ (crate!semantics.Abstract.Instruction./Add/_2 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_in2~31$ (crate!semantics.Abstract.Instruction./Add/_3 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((poly_in1~43$ (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in1~30$)))) (let ((poly_in2~52$ (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in2~31$)))) (crate!semantics.Abstract.impl&%2.set.? self~2@ (Poly%crate!semantics.Abstract.Register. r_out~29$) (vstd!seq.Seq.new.? $ INT $ (TYPE%fun%1. $ INT $ INT) (I (crate!arith.pow2.? (I log_degree~28$))) (Poly%fun%1. (mk_fun (%%lambda%%3 $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly_in1~43$)))) $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly_in2~52$)))) (crate!semantics.Parameters./Parameters/modulus (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))))))))))))))) (ite ((_ is crate!semantics.Abstract.Instruction./Mul) (%Poly%crate!semantics.Abstract.Instruction. instr~4@)) (let ((log_degree~104$ (crate!semantics.Abstract.Instruction./Mul/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_out~105$ (crate!semantics.Abstract.Instruction./Mul/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_in1~106$ (crate!semantics.Abstract.Instruction./Mul/_2 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((r_in2~107$ (crate!semantics.Abstract.Instruction./Mul/_3 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((poly_in1~119$ (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in1~106$)))) (let ((poly_in2~128$ (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. r_in2~107$)))) (crate!semantics.Abstract.impl&%2.set.? self~2@ (Poly%crate!semantics.Abstract.Register. r_out~105$) (vstd!seq.Seq.new.? $ INT $ (TYPE%fun%1. $ INT $ INT) (I (crate!arith.pow2.? (I log_degree~104$))) (Poly%fun%1. (mk_fun (%%lambda%%4 $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly_in1~119$)))) $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly_in2~128$)))) (crate!semantics.Parameters./Parameters/modulus (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))))))))))))))) (let ((log_degree~180$ (crate!semantics.Abstract.Instruction./NTT/_0 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((reg~181$ (crate!semantics.Abstract.Instruction./NTT/_1 (%Poly%crate!semantics.Abstract.Instruction. instr~4@)))) (let ((poly~193$ (crate!semantics.Abstract.impl&%2.get.? self~2@ (Poly%crate!semantics.Abstract.Register. reg~181$)))) (crate!semantics.Abstract.impl&%2.set.? self~2@ (Poly%crate!semantics.Abstract.Register. reg~181$) (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.ntt.? (I log_degree~180$) (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly~193$))))))))))))) :pattern ((crate!semantics.Abstract.impl&%2.step.? self~2@ instr~4@)) :qid internal_crate!semantics.Abstract.impl&__2.step.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.step.?_definition))))
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Abstract.State.) (has_type instr~4@ TYPE%crate!semantics.Abstract.Instruction.)) (has_type (Poly%crate!semantics.Abstract.State. (crate!semantics.Abstract.impl&%2.step.? self~2@ instr~4@)) TYPE%crate!semantics.Abstract.State.)) :pattern ((crate!semantics.Abstract.impl&%2.step.? self~2@ instr~4@)) :qid internal_crate!semantics.Abstract.impl&__2.step.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.step.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::State::to_machine")
(declare-fun req%crate!semantics.Abstract.impl&%2.to_machine. (Poly) Bool)
(declare-const %%global_location_label%%52 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%crate!semantics.Abstract.impl&%2.to_machine. self~2@) (=> %%global_location_label%%52 (crate!semantics.Abstract.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Abstract.impl&%2.to_machine. self~2@)) :qid internal_req__crate!semantics.Abstract.impl&__2.to_machine._definition :skolemid skolem_internal_req__crate!semantics.Abstract.impl&__2.to_machine._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::State::to_machine")
(assert (fuel_bool_default fuel%crate!semantics.Abstract.impl&%2.to_machine.))
(declare-fun %%lambda%%5 (Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (name~34$ Poly)) (! (= (%%apply%%0 (%%lambda%%5 %%hole%%0 %%hole%%1 %%hole%%2) name~34$) (B (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 name~34$))) :pattern ((%%apply%%0 (%%lambda%%5 %%hole%%0 %%hole%%1 %%hole%%2) name~34$)))))
(declare-fun %%lambda%%6 (Dcr Type Dcr Type Poly Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Dcr) (%%hole%%3 Type) (%%hole%%4 Poly) (%%hole%%5 Poly) (name~53$ Poly)) (! (= (%%apply%%0 (%%lambda%%6 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) name~53$) (Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Abstract.impl&%0.to_machine.? (vstd!map.impl&%0.index.? %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 name~53$) %%hole%%5))) :pattern ((%%apply%%0 (%%lambda%%6 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) name~53$)))))
(assert (=> (fuel_bool fuel%crate!semantics.Abstract.impl&%2.to_machine.) (forall ((self~2@ Poly)) (! (= (crate!semantics.Abstract.impl&%2.to_machine.? self~2@) (crate!semantics.Machine.State./State (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))) (%Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (vstd!map.impl&%0.new.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. $ (TYPE%fun%1. $ (SINT 32) $ BOOL) $ (TYPE%fun%1. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.) (Poly%fun%1. (mk_fun (%%lambda%%5 $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@))))))) (Poly%fun%1. (mk_fun (%%lambda%%6 $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. self~2@))) (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. self~2@)))))))))) :pattern ((crate!semantics.Abstract.impl&%2.to_machine.? self~2@)) :qid internal_crate!semantics.Abstract.impl&__2.to_machine.?_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.to_machine.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%crate!semantics.Abstract.State.) (has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Abstract.impl&%2.to_machine.? self~2@)) TYPE%crate!semantics.Machine.State.)) :pattern ((crate!semantics.Abstract.impl&%2.to_machine.? self~2@)) :qid internal_crate!semantics.Abstract.impl&__2.to_machine.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Abstract.impl&__2.to_machine.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::arith::lemma_pow2_positive")
(declare-fun ens%crate!arith.lemma_pow2_positive. (Int) Bool)
(assert (forall ((n~2@ Int)) (! (= (ens%crate!arith.lemma_pow2_positive. n~2@) (> (crate!arith.pow2.? (I n~2@)) 0)) :pattern ((ens%crate!arith.lemma_pow2_positive. n~2@)) :qid internal_ens__crate!arith.lemma_pow2_positive._definition :skolemid skolem_internal_ens__crate!arith.lemma_pow2_positive._definition)))
(set-info :comment ";; Function-Specs crate::semantics::Abstract::lemma_block_index_to_coeff_index_in_bound")
(declare-fun req%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. (crate!semantics.Parameters. crate!semantics.Abstract.Polynomial. Int Int) Bool)
(declare-const %%global_location_label%%53 Bool)
(declare-const %%global_location_label%%54 Bool)
(declare-const %%global_location_label%%55 Bool)
(assert (forall ((params~2@ crate!semantics.Parameters.) (poly~4@ crate!semantics.Abstract.Polynomial.) (block_index~6@ Int) (row_tile_index~8@ Int)) (! (= (req%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~2@ poly~4@ block_index~6@ row_tile_index~8@) (and (=> %%global_location_label%%53 (crate!semantics.Abstract.impl&%0.valid.? (Poly%crate!semantics.Abstract.Polynomial. poly~4@) (Poly%crate!semantics.Parameters. params~2@))) (=> %%global_location_label%%54 (and (<= 0 block_index~6@) (< block_index~6@ (crate!arith.pow2.? (I (nClip (Sub (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly~4@))) (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. params~2@)))))))))) (=> %%global_location_label%%55 (and (<= 0 row_tile_index~8@) (< row_tile_index~8@ (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. params~2@))))))) :pattern ((req%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~2@ poly~4@ block_index~6@ row_tile_index~8@)) :qid internal_req__crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound._definition :skolemid skolem_internal_req__crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Abstract::lemma_block_index_to_coeff_index_in_bound")
(declare-fun ens%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. (crate!semantics.Parameters. crate!semantics.Abstract.Polynomial. Int Int) Bool)
(assert (forall ((params~2@ crate!semantics.Parameters.) (poly~4@ crate!semantics.Abstract.Polynomial.) (block_index~6@ Int) (row_tile_index~8@ Int)) (! (= (ens%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~2@ poly~4@ block_index~6@ row_tile_index~8@) (let ((tmp%%1$ (crate!semantics.block_index_to_coeff_index.? (Poly%crate!semantics.Parameters. params~2@) (I block_index~6@) (I row_tile_index~8@)))) (and (<= 0 tmp%%1$) (< tmp%%1$ (crate!arith.pow2.? (I (crate!semantics.Abstract.Polynomial./Polynomial/log_degree (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly~4@))))))))) :pattern ((ens%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~2@ poly~4@ block_index~6@ row_tile_index~8@)) :qid internal_ens__crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound._definition :skolemid skolem_internal_ens__crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::Polynomial::num_blocks")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%0.num_blocks.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%0.num_blocks.) (forall ((self~2@ Poly)) (! (= (crate!semantics.Machine.impl&%0.num_blocks.? self~2@) (crate!arith.pow2.? (I (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. self~2@))))) :pattern ((crate!semantics.Machine.impl&%0.num_blocks.? self~2@)) :qid internal_crate!semantics.Machine.impl&__0.num_blocks.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__0.num_blocks.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%crate!semantics.Machine.Polynomial.) (<= 0 (crate!semantics.Machine.impl&%0.num_blocks.? self~2@))) :pattern ((crate!semantics.Machine.impl&%0.num_blocks.? self~2@)) :qid internal_crate!semantics.Machine.impl&__0.num_blocks.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__0.num_blocks.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::Polynomial::valid")
(declare-fun req%crate!semantics.Machine.impl&%0.valid. (Poly Poly) Bool)
(declare-const %%global_location_label%%56 Bool)
(assert (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%0.valid. self~2@ params~4@) (=> %%global_location_label%%56 (crate!semantics.impl&%0.valid.? params~4@))) :pattern ((req%crate!semantics.Machine.impl&%0.valid. self~2@ params~4@)) :qid internal_req__crate!semantics.Machine.impl&__0.valid._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__0.valid._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::Polynomial::valid")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%0.valid.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%0.valid.) (forall ((self~2@ Poly) (params~4@ Poly)) (! (= (crate!semantics.Machine.impl&%0.valid.? self~2@ params~4@) (and (and (and (= (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@)))) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. params~4@))))) (forall ((i~41$ Poly)) (! (=> (has_type i~41$ INT) (=> (and (<= 0 (%I i~41$)) (< (%I i~41$) (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@)))))) (= (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~41$)) (crate!semantics.Machine.impl&%0.num_blocks.? self~2@)))) :pattern ((vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~41$))) :qid user_crate__semantics__Machine__Polynomial__valid_67 :skolemid skolem_user_crate__semantics__Machine__Polynomial__valid_67))) (forall ((i~107$ Poly) (j~109$ Poly)) (! (=> (and (has_type i~107$ INT) (has_type j~109$ INT)) (=> (and (and (<= 0 (%I i~107$)) (< (%I i~107$) (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@)))))) (and (<= 0 (%I j~109$)) (< (%I j~109$) (crate!semantics.Machine.impl&%0.num_blocks.? self~2@)))) (= (vstd!seq.Seq.len.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~107$) j~109$)) (crate!semantics.impl&%0.block_size.? params~4@)))) :pattern ((vstd!seq.Seq.len.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~107$) j~109$))) :qid user_crate__semantics__Machine__Polynomial__valid_68 :skolemid skolem_user_crate__semantics__Machine__Polynomial__valid_68))) (forall ((i~214$ Poly) (j~216$ Poly) (k~218$ Poly)) (! (=> (and (has_type i~214$ INT) (has_type j~216$ INT) (has_type k~218$ INT)) (=> (and (and (and (<= 0 (%I i~214$)) (< (%I i~214$) (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@)))))) (and (<= 0 (%I j~216$)) (< (%I j~216$) (crate!semantics.Machine.impl&%0.num_blocks.? self~2@)))) (and (<= 0 (%I k~218$)) (< (%I k~218$) (crate!semantics.impl&%0.block_size.? params~4@)))) (let ((tmp%%1$ (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~214$) j~216$) k~218$)))) (and (<= 0 tmp%%1$) (< tmp%%1$ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. params~4@))) i~214$))))))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. self~2@))) i~214$) j~216$) k~218$)) :qid user_crate__semantics__Machine__Polynomial__valid_69 :skolemid skolem_user_crate__semantics__Machine__Polynomial__valid_69)))) :pattern ((crate!semantics.Machine.impl&%0.valid.? self~2@ params~4@)) :qid internal_crate!semantics.Machine.impl&__0.valid.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__0.valid.?_definition))))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::Register::new")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%1.new.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%1.new.) (forall ((name~2@ Poly) (rns_index~4@ Poly) (block_index~6@ Poly)) (! (= (crate!semantics.Machine.impl&%1.new.? name~2@ rns_index~4@ block_index~6@) (crate!semantics.Machine.Register./Register (%I name~2@) (%I rns_index~4@) (%I block_index~6@))) :pattern ((crate!semantics.Machine.impl&%1.new.? name~2@ rns_index~4@ block_index~6@)) :qid internal_crate!semantics.Machine.impl&__1.new.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__1.new.?_definition))))
(assert (forall ((name~2@ Poly) (rns_index~4@ Poly) (block_index~6@ Poly)) (! (=> (and (has_type name~2@ (SINT 32)) (has_type rns_index~4@ INT) (has_type block_index~6@ INT)) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.impl&%1.new.? name~2@ rns_index~4@ block_index~6@)) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.Machine.impl&%1.new.? name~2@ rns_index~4@ block_index~6@)) :qid internal_crate!semantics.Machine.impl&__1.new.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__1.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::valid")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.valid.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.valid.) (forall ((self~2@ Poly)) (! (= (crate!semantics.Machine.impl&%2.valid.? self~2@) (and (crate!semantics.impl&%0.valid.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))) (forall ((name~16$ Poly)) (! (=> (has_type name~16$ (SINT 32)) (=> (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@)))) name~16$) (crate!semantics.Machine.impl&%0.valid.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) name~16$) (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@)))) name~16$)) :qid user_crate__semantics__Machine__State__valid_70 :skolemid skolem_user_crate__semantics__Machine__State__valid_70)))) :pattern ((crate!semantics.Machine.impl&%2.valid.? self~2@)) :qid internal_crate!semantics.Machine.impl&__2.valid.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.valid.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::valid_register")
(declare-fun req%crate!semantics.Machine.impl&%2.valid_register. (Poly Poly) Bool)
(declare-const %%global_location_label%%57 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.valid_register. self~2@ reg~4@) (=> %%global_location_label%%57 (crate!semantics.Machine.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Machine.impl&%2.valid_register. self~2@ reg~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.valid_register._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.valid_register._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::valid_register")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.valid_register.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.valid_register.) (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.valid_register.? self~2@ reg~4@) (and (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@)))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@)))) (let ((tmp%%1$ (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. reg~4@)))) (and (<= 0 tmp%%1$) (< tmp%%1$ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@))))))))))) (let ((tmp%%2$ (crate!semantics.Machine.Register./Register/block_index (%Poly%crate!semantics.Machine.Register. reg~4@)))) (and (<= 0 tmp%%2$) (< tmp%%2$ (crate!arith.pow2.? (I (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@))))))))))))) :pattern ((crate!semantics.Machine.impl&%2.valid_register.? self~2@ reg~4@)) :qid internal_crate!semantics.Machine.impl&__2.valid_register.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.valid_register.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::valid_instruction")
(declare-fun req%crate!semantics.Machine.impl&%2.valid_instruction. (Poly Poly) Bool)
(declare-const %%global_location_label%%58 Bool)
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.valid_instruction. self~2@ instr~4@) (=> %%global_location_label%%58 (crate!semantics.Machine.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Machine.impl&%2.valid_instruction. self~2@ instr~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.valid_instruction._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.valid_instruction._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::valid_instruction")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.valid_instruction.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.valid_instruction.) (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.valid_instruction.? self~2@ instr~4@) (ite ((_ is crate!semantics.Machine.Instruction./Add) (%Poly%crate!semantics.Machine.Instruction. instr~4@)) (let ((r_out~21$ (crate!semantics.Machine.Instruction./Add/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in1~22$ (crate!semantics.Machine.Instruction./Add/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in2~23$ (crate!semantics.Machine.Instruction./Add/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (and (and (and (and (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_out~21$)) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in1~22$))) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in2~23$))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~21$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in1~22$))))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~21$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in2~23$)))))))) (ite ((_ is crate!semantics.Machine.Instruction./Mul) (%Poly%crate!semantics.Machine.Instruction. instr~4@)) (let ((r_out~72$ (crate!semantics.Machine.Instruction./Mul/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in1~73$ (crate!semantics.Machine.Instruction./Mul/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in2~74$ (crate!semantics.Machine.Instruction./Mul/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (and (and (and (and (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_out~72$)) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in1~73$))) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in2~74$))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~72$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in1~73$))))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~72$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in2~74$)))))))) (let ((r_out_bot~123$ (crate!semantics.Machine.Instruction./NTTStage/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_out_top~124$ (crate!semantics.Machine.Instruction./NTTStage/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in_bot~125$ (crate!semantics.Machine.Instruction./NTTStage/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in_top~126$ (crate!semantics.Machine.Instruction./NTTStage/_3 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((log_degree~127$ (crate!semantics.Machine.Instruction./NTTStage/_4 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((stage_num~128$ (crate!semantics.Machine.Instruction./NTTStage/_5 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (and (and (and (and (and (and (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_out_bot~123$)) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_out_top~124$))) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in_bot~125$))) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ (Poly%crate!semantics.Machine.Register. r_in_top~126$))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out_bot~123$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out_top~124$))))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out_bot~123$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in_bot~125$))))) (= (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out_bot~123$))) (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_in_top~126$)))))))))))))) :pattern ((crate!semantics.Machine.impl&%2.valid_instruction.? self~2@ instr~4@)) :qid internal_crate!semantics.Machine.impl&__2.valid_instruction.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.valid_instruction.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::valid_instructions")
(declare-fun req%crate!semantics.Machine.impl&%2.valid_instructions. (Poly Poly) Bool)
(declare-const %%global_location_label%%59 Bool)
(assert (forall ((self~2@ Poly) (instrs~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.valid_instructions. self~2@ instrs~4@) (=> %%global_location_label%%59 (crate!semantics.Machine.impl&%2.valid.? self~2@))) :pattern ((req%crate!semantics.Machine.impl&%2.valid_instructions. self~2@ instrs~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.valid_instructions._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.valid_instructions._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::valid_instructions")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.valid_instructions.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.valid_instructions.) (forall ((self~2@ Poly) (instrs~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.valid_instructions.? self~2@ instrs~4@) (forall ((i~23$ Poly)) (! (=> (has_type i~23$ INT) (=> (and (<= 0 (%I i~23$)) (< (%I i~23$) (vstd!seq.Seq.len.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@))) (crate!semantics.Machine.impl&%2.valid_instruction.? self~2@ (vstd!seq.Seq.index.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@ i~23$)))) :pattern ((vstd!seq.Seq.index.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@ i~23$)) :qid user_crate__semantics__Machine__State__valid_instructions_71 :skolemid skolem_user_crate__semantics__Machine__State__valid_instructions_71))) :pattern ((crate!semantics.Machine.impl&%2.valid_instructions.? self~2@ instrs~4@)) :qid internal_crate!semantics.Machine.impl&__2.valid_instructions.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.valid_instructions.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::get")
(declare-fun req%crate!semantics.Machine.impl&%2.get. (Poly Poly) Bool)
(declare-const %%global_location_label%%60 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.get. self~2@ reg~4@) (=> %%global_location_label%%60 (and (crate!semantics.Machine.impl&%2.valid.? self~2@) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ reg~4@)))) :pattern ((req%crate!semantics.Machine.impl&%2.get. self~2@ reg~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.get._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.get._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::get")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.get.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.get.) (forall ((self~2@ Poly) (reg~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.get.? self~2@ reg~4@) (%Poly%vstd!seq.Seq<int.>. (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@))))))) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. reg~4@)))) (I (crate!semantics.Machine.Register./Register/block_index (%Poly%crate!semantics.Machine.Register. reg~4@)))))) :pattern ((crate!semantics.Machine.impl&%2.get.? self~2@ reg~4@)) :qid internal_crate!semantics.Machine.impl&__2.get.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.get.?_definition))))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::set")
(declare-fun req%crate!semantics.Machine.impl&%2.set. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%61 Bool)
(declare-const %%global_location_label%%62 Bool)
(assert (forall ((self~2@ Poly) (reg~4@ Poly) (block~6@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.set. self~2@ reg~4@ block~6@) (and (=> %%global_location_label%%61 (and (crate!semantics.Machine.impl&%2.valid.? self~2@) (crate!semantics.Machine.impl&%2.valid_register.? self~2@ reg~4@))) (=> %%global_location_label%%62 (= (vstd!seq.Seq.len.? $ INT block~6@) (crate!arith.pow2.? (I (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@))))))))))) :pattern ((req%crate!semantics.Machine.impl&%2.set. self~2@ reg~4@ block~6@)) :qid internal_req__crate!semantics.Machine.impl&__2.set._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.set._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::set")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.set.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.set.) (forall ((self~2@ Poly) (reg~4@ Poly) (block~6@ Poly)) (! (= (crate!semantics.Machine.impl&%2.set.? self~2@ reg~4@ block~6@) (crate!semantics.Machine.State./State (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))) (%Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (vstd!map.impl&%0.insert.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@))) (Poly%crate!semantics.Machine.Polynomial. (crate!semantics.Machine.Polynomial./Polynomial (%I (I (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@)))))))) (%Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (vstd!seq.Seq.update.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@))))))) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. reg~4@))) (vstd!seq.Seq.update.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. self~2@))) (I (crate!semantics.Machine.Register./Register/name (%Poly%crate!semantics.Machine.Register. reg~4@))))))) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. reg~4@)))) (I (crate!semantics.Machine.Register./Register/block_index (%Poly%crate!semantics.Machine.Register. reg~4@))) block~6@))))))))) :pattern ((crate!semantics.Machine.impl&%2.set.? self~2@ reg~4@ block~6@)) :qid internal_crate!semantics.Machine.impl&__2.set.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.set.?_definition))))
(assert (forall ((self~2@ Poly) (reg~4@ Poly) (block~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Machine.State.) (has_type reg~4@ TYPE%crate!semantics.Machine.Register.) (has_type block~6@ (TYPE%vstd!seq.Seq. $ INT))) (has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.set.? self~2@ reg~4@ block~6@)) TYPE%crate!semantics.Machine.State.)) :pattern ((crate!semantics.Machine.impl&%2.set.? self~2@ reg~4@ block~6@)) :qid internal_crate!semantics.Machine.impl&__2.set.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.set.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::ntt_stage_block")
(assert (forall ((params~2@ Poly) (log_degree~4@ Poly) (stage_num~6@ Poly) (residue_num~8@ Poly) (in_bot~10@ Poly) (in_top~12@ Poly)) (! (=> (and (has_type params~2@ TYPE%crate!semantics.Parameters.) (has_type log_degree~4@ NAT) (has_type stage_num~6@ NAT) (has_type residue_num~8@ INT) (has_type in_bot~10@ (TYPE%vstd!seq.Seq. $ INT)) (has_type in_top~12@ (TYPE%vstd!seq.Seq. $ INT))) (has_type (Poly%tuple%2. (crate!semantics.Machine.ntt_stage_block.? params~2@ log_degree~4@ stage_num~6@ residue_num~8@ in_bot~10@ in_top~12@)) (TYPE%tuple%2. $ (TYPE%vstd!seq.Seq. $ INT) $ (TYPE%vstd!seq.Seq. $ INT)))) :pattern ((crate!semantics.Machine.ntt_stage_block.? params~2@ log_degree~4@ stage_num~6@ residue_num~8@ in_bot~10@ in_top~12@)) :qid internal_crate!semantics.Machine.ntt_stage_block.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.ntt_stage_block.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::step")
(declare-fun req%crate!semantics.Machine.impl&%2.step. (Poly Poly) Bool)
(declare-const %%global_location_label%%63 Bool)
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.step. self~2@ instr~4@) (=> %%global_location_label%%63 (and (crate!semantics.Machine.impl&%2.valid.? self~2@) (crate!semantics.Machine.impl&%2.valid_instruction.? self~2@ instr~4@)))) :pattern ((req%crate!semantics.Machine.impl&%2.step. self~2@ instr~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.step._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.step._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::step")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.step.))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.step.) (forall ((self~2@ Poly) (instr~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.step.? self~2@ instr~4@) (ite ((_ is crate!semantics.Machine.Instruction./Add) (%Poly%crate!semantics.Machine.Instruction. instr~4@)) (let ((r_out~28$ (crate!semantics.Machine.Instruction./Add/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in1~29$ (crate!semantics.Machine.Instruction./Add/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in2~30$ (crate!semantics.Machine.Instruction./Add/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((poly_in1~42$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in1~29$)))) (let ((poly_in2~51$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in2~30$)))) (crate!semantics.Machine.impl&%2.set.? self~2@ (Poly%crate!semantics.Machine.Register. r_out~28$) (vstd!seq.Seq.new.? $ INT $ (TYPE%fun%1. $ INT $ INT) (I (crate!arith.pow2.? (I (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))))))) (Poly%fun%1. (mk_fun (%%lambda%%3 $ INT (Poly%vstd!seq.Seq<int.>. poly_in1~42$) $ INT (Poly%vstd!seq.Seq<int.>. poly_in2~51$) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))))) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~28$)))))))))))))))) (ite ((_ is crate!semantics.Machine.Instruction./Mul) (%Poly%crate!semantics.Machine.Instruction. instr~4@)) (let ((r_out~108$ (crate!semantics.Machine.Instruction./Mul/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in1~109$ (crate!semantics.Machine.Instruction./Mul/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in2~110$ (crate!semantics.Machine.Instruction./Mul/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((poly_in1~122$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in1~109$)))) (let ((poly_in2~131$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in2~110$)))) (crate!semantics.Machine.impl&%2.set.? self~2@ (Poly%crate!semantics.Machine.Register. r_out~108$) (vstd!seq.Seq.new.? $ INT $ (TYPE%fun%1. $ INT $ INT) (I (crate!arith.pow2.? (I (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))))))) (Poly%fun%1. (mk_fun (%%lambda%%4 $ INT (Poly%vstd!seq.Seq<int.>. poly_in1~122$) $ INT (Poly%vstd!seq.Seq<int.>. poly_in2~131$) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@)))))) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out~108$)))))))))))))))) (let ((r_out_bot~188$ (crate!semantics.Machine.Instruction./NTTStage/_0 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_out_top~189$ (crate!semantics.Machine.Instruction./NTTStage/_1 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in_bot~190$ (crate!semantics.Machine.Instruction./NTTStage/_2 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((r_in_top~191$ (crate!semantics.Machine.Instruction./NTTStage/_3 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((log_degree~192$ (crate!semantics.Machine.Instruction./NTTStage/_4 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((stage_num~193$ (crate!semantics.Machine.Instruction./NTTStage/_5 (%Poly%crate!semantics.Machine.Instruction. instr~4@)))) (let ((poly_in_bot~205$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in_bot~190$)))) (let ((poly_in_top~214$ (crate!semantics.Machine.impl&%2.get.? self~2@ (Poly%crate!semantics.Machine.Register. r_in_top~191$)))) (let ((tmp%%1$ (crate!semantics.Machine.ntt_stage_block.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. self~2@))) (I log_degree~192$) (I stage_num~193$) (I (crate!semantics.Machine.Register./Register/rns_index (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. r_out_bot~188$)))) (Poly%vstd!seq.Seq<int.>. poly_in_bot~205$) (Poly%vstd!seq.Seq<int.>. poly_in_top~214$)))) (let ((poly_out_bot~234$ (%Poly%vstd!seq.Seq<int.>. (tuple%2./tuple%2/field%0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (let ((poly_out_top~235$ (%Poly%vstd!seq.Seq<int.>. (tuple%2./tuple%2/field%1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (crate!semantics.Machine.impl&%2.set.? (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.set.? self~2@ (Poly%crate!semantics.Machine.Register. r_out_bot~188$) (Poly%vstd!seq.Seq<int.>. poly_out_bot~234$))) (Poly%crate!semantics.Machine.Register. r_out_top~189$) (Poly%vstd!seq.Seq<int.>. poly_out_top~235$)))))))))))))))) :pattern ((crate!semantics.Machine.impl&%2.step.? self~2@ instr~4@)) :qid internal_crate!semantics.Machine.impl&__2.step.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.step.?_definition))))
(assert (forall ((self~2@ Poly) (instr~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Machine.State.) (has_type instr~4@ TYPE%crate!semantics.Machine.Instruction.)) (has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.step.? self~2@ instr~4@)) TYPE%crate!semantics.Machine.State.)) :pattern ((crate!semantics.Machine.impl&%2.step.? self~2@ instr~4@)) :qid internal_crate!semantics.Machine.impl&__2.step.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.step.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::steps")
(declare-fun req%crate!semantics.Machine.impl&%2.steps. (Poly Poly) Bool)
(declare-const %%global_location_label%%64 Bool)
(assert (forall ((self~2@ Poly) (instrs~4@ Poly)) (! (= (req%crate!semantics.Machine.impl&%2.steps. self~2@ instrs~4@) (=> %%global_location_label%%64 (and (crate!semantics.Machine.impl&%2.valid.? self~2@) (crate!semantics.Machine.impl&%2.valid_instructions.? self~2@ instrs~4@)))) :pattern ((req%crate!semantics.Machine.impl&%2.steps. self~2@ instrs~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.steps._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.steps._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::steps")
(assert (fuel_bool_default fuel%crate!semantics.Machine.impl&%2.steps.))
(declare-const fuel_nat%crate!semantics.Machine.impl&%2.steps. Fuel)
(assert (forall ((self~2@ Poly) (instrs~4@ Poly) (fuel%@ Fuel)) (! (= (crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ fuel%@) (crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ zero)) :pattern ((crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ fuel%@)) :qid internal_crate!semantics.Machine.impl&__2.steps._fuel_to_zero_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.steps._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (instrs~4@ Poly) (fuel%@ Fuel)) (! (= (crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ (succ fuel%@)) (ite (= (vstd!seq.Seq.len.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@) 0) (%Poly%crate!semantics.Machine.State. self~2@) (let ((next~71$ (crate!semantics.Machine.impl&%2.step.? self~2@ (vstd!seq.Seq.index.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@ (I 0))))) (crate!semantics.Machine.impl&%2.rec%steps.? (Poly%crate!semantics.Machine.State. next~71$) (vstd!seq.Seq.subrange.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@ (I 1) (I (vstd!seq.Seq.len.? $ TYPE%crate!semantics.Machine.Instruction. instrs~4@))) fuel%@)))) :pattern ((crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ (succ fuel%@))) :qid internal_crate!semantics.Machine.impl&__2.steps._fuel_to_body_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.steps._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%crate!semantics.Machine.impl&%2.steps.) (forall ((self~2@ Poly) (instrs~4@ Poly)) (! (= (crate!semantics.Machine.impl&%2.steps.? self~2@ instrs~4@) (crate!semantics.Machine.impl&%2.rec%steps.? self~2@ instrs~4@ (succ fuel_nat%crate!semantics.Machine.impl&%2.steps.))) :pattern ((crate!semantics.Machine.impl&%2.steps.? self~2@ instrs~4@)) :qid internal_crate!semantics.Machine.impl&__2.steps.?_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.steps.?_definition))))
(assert (forall ((self~2@ Poly) (instrs~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%crate!semantics.Machine.State.) (has_type instrs~4@ (TYPE%vstd!seq.Seq. $ TYPE%crate!semantics.Machine.Instruction.))) (has_type (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.steps.? self~2@ instrs~4@)) TYPE%crate!semantics.Machine.State.)) :pattern ((crate!semantics.Machine.impl&%2.steps.? self~2@ instrs~4@)) :qid internal_crate!semantics.Machine.impl&__2.steps.?_pre_post_definition :skolemid skolem_internal_crate!semantics.Machine.impl&__2.steps.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::lemma_steps_preserve_parameters")
(declare-fun ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_parameters. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_parameters. self~2@ instrs~4@) (= (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs~4@))))) (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. self~2@))))) :pattern ((ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_parameters. self~2@ instrs~4@)) :qid internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_parameters._definition :skolemid skolem_internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_parameters._definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::lemma_steps_preserve_validity")
(declare-fun req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(declare-const %%global_location_label%%65 Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. self~2@ instrs~4@) (=> %%global_location_label%%65 (and (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. self~2@)) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs~4@))))) :pattern ((req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. self~2@ instrs~4@)) :qid internal_req__crate!semantics.Machine.impl&__2.lemma_steps_preserve_validity._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.lemma_steps_preserve_validity._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::lemma_steps_preserve_validity")
(declare-fun ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. self~2@ instrs~4@) (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs~4@))))) :pattern ((ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_validity. self~2@ instrs~4@)) :qid internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_validity._definition :skolemid skolem_internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_validity._definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::lemma_steps_preserve_instruction_validity")
(declare-fun req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(declare-const %%global_location_label%%66 Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs1~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) (instrs2~6@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. self~2@ instrs1~4@ instrs2~6@) (=> %%global_location_label%%66 (and (and (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. self~2@)) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs1~4@))) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs2~6@))))) :pattern ((req%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. self~2@ instrs1~4@ instrs2~6@)) :qid internal_req__crate!semantics.Machine.impl&__2.lemma_steps_preserve_instruction_validity._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.lemma_steps_preserve_instruction_validity._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::lemma_steps_preserve_instruction_validity")
(declare-fun ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs1~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) (instrs2~6@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. self~2@ instrs1~4@ instrs2~6@) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs1~4@))) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs2~6@))) :pattern ((ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_instruction_validity. self~2@ instrs1~4@ instrs2~6@)) :qid internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_instruction_validity._definition :skolemid skolem_internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_preserve_instruction_validity._definition)))
(set-info :comment ";; Function-Specs crate::semantics::Machine::State::lemma_steps_additive")
(declare-fun req%crate!semantics.Machine.impl&%2.lemma_steps_additive. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(declare-const %%global_location_label%%67 Bool)
(declare-const %%global_location_label%%68 Bool)
(declare-const %%global_location_label%%69 Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs1~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) (instrs2~6@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (req%crate!semantics.Machine.impl&%2.lemma_steps_additive. self~2@ instrs1~4@ instrs2~6@) (and (=> %%global_location_label%%67 (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. self~2@))) (=> %%global_location_label%%68 (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs1~4@))) (=> %%global_location_label%%69 (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs2~6@))))) :pattern ((req%crate!semantics.Machine.impl&%2.lemma_steps_additive. self~2@ instrs1~4@ instrs2~6@)) :qid internal_req__crate!semantics.Machine.impl&__2.lemma_steps_additive._definition :skolemid skolem_internal_req__crate!semantics.Machine.impl&__2.lemma_steps_additive._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Machine::State::lemma_steps_additive")
(declare-fun ens%crate!semantics.Machine.impl&%2.lemma_steps_additive. (crate!semantics.Machine.State. vstd!seq.Seq<crate!semantics.Machine.Instruction.>. vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) Bool)
(assert (forall ((self~2@ crate!semantics.Machine.State.) (instrs1~4@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.) (instrs2~6@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)) (! (= (ens%crate!semantics.Machine.impl&%2.lemma_steps_additive. self~2@ instrs1~4@ instrs2~6@) (= (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. self~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs1~4@))) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs2~6@)) (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. self~2@) (vstd!seq.Seq.add.? $ TYPE%crate!semantics.Machine.Instruction. (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs1~4@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs2~6@))))) :pattern ((ens%crate!semantics.Machine.impl&%2.lemma_steps_additive. self~2@ instrs1~4@ instrs2~6@)) :qid internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_additive._definition :skolemid skolem_internal_ens__crate!semantics.Machine.impl&__2.lemma_steps_additive._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::MachineImplementation::Register::to_machine")
(assert (fuel_bool_default fuel%crate!semantics.MachineImplementation.impl&%0.to_machine.))
(assert (=> (fuel_bool fuel%crate!semantics.MachineImplementation.impl&%0.to_machine.) (forall ((self~2@ Poly)) (! (= (crate!semantics.MachineImplementation.impl&%0.to_machine.? self~2@) (crate!semantics.Machine.Register./Register (%I (I (crate!semantics.MachineImplementation.Register./Register/name (%Poly%crate!semantics.MachineImplementation.Register. self~2@)))) (%I (I (crate!semantics.MachineImplementation.Register./Register/rns_index (%Poly%crate!semantics.MachineImplementation.Register. self~2@)))) (%I (I (crate!semantics.MachineImplementation.Register./Register/block_index (%Poly%crate!semantics.MachineImplementation.Register. self~2@)))))) :pattern ((crate!semantics.MachineImplementation.impl&%0.to_machine.? self~2@)) :qid internal_crate!semantics.MachineImplementation.impl&__0.to_machine.?_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.impl&__0.to_machine.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%crate!semantics.MachineImplementation.Register.) (has_type (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? self~2@)) TYPE%crate!semantics.Machine.Register.)) :pattern ((crate!semantics.MachineImplementation.impl&%0.to_machine.? self~2@)) :qid internal_crate!semantics.MachineImplementation.impl&__0.to_machine.?_pre_post_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.impl&__0.to_machine.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms crate::semantics::MachineImplementation::Instruction::to_machine")
(assert (fuel_bool_default fuel%crate!semantics.MachineImplementation.impl&%1.to_machine.))
(assert (=> (fuel_bool fuel%crate!semantics.MachineImplementation.impl&%1.to_machine.) (forall ((self~2@ Poly)) (! (= (crate!semantics.MachineImplementation.impl&%1.to_machine.? self~2@) (ite ((_ is crate!semantics.MachineImplementation.Instruction./Add) (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)) (let ((r_out~8$ (crate!semantics.MachineImplementation.Instruction./Add/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (let ((r_in1~9$ (crate!semantics.MachineImplementation.Instruction./Add/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (let ((r_in2~10$ (crate!semantics.MachineImplementation.Instruction./Add/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (crate!semantics.Machine.Instruction./Add (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_out~8$)))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_in1~9$)))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_in2~10$)))))))) (let ((r_out~32$ (crate!semantics.MachineImplementation.Instruction./Mul/_0 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (let ((r_in1~33$ (crate!semantics.MachineImplementation.Instruction./Mul/_1 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (let ((r_in2~34$ (crate!semantics.MachineImplementation.Instruction./Mul/_2 (%Poly%crate!semantics.MachineImplementation.Instruction. self~2@)))) (crate!semantics.Machine.Instruction./Mul (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_out~32$)))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_in1~33$)))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.MachineImplementation.impl&%0.to_machine.? (Poly%crate!semantics.MachineImplementation.Register. r_in2~34$)))))))))) :pattern ((crate!semantics.MachineImplementation.impl&%1.to_machine.? self~2@)) :qid internal_crate!semantics.MachineImplementation.impl&__1.to_machine.?_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.impl&__1.to_machine.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%crate!semantics.MachineImplementation.Instruction.) (has_type (Poly%crate!semantics.Machine.Instruction. (crate!semantics.MachineImplementation.impl&%1.to_machine.? self~2@)) TYPE%crate!semantics.Machine.Instruction.)) :pattern ((crate!semantics.MachineImplementation.impl&%1.to_machine.? self~2@)) :qid internal_crate!semantics.MachineImplementation.impl&__1.to_machine.?_pre_post_definition :skolemid skolem_internal_crate!semantics.MachineImplementation.impl&__1.to_machine.?_pre_post_definition)))
(set-info :comment ";; Function-Termination crate::kernel_add::AddKernel::spec_generate_block")
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::spec_generate_block")
(assert (fuel_bool_default fuel%crate!kernel_add.AddKernel.spec_generate_block.))
(declare-const fuel_nat%crate!kernel_add.AddKernel.spec_generate_block. Fuel)
(assert (forall ((rns_index~2@ Poly) (num_blocks~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly) (fuel%@ Fuel)) (! (= (crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ fuel%@) (crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ zero)) :pattern ((crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ fuel%@)) :qid internal_crate!kernel_add.AddKernel.spec_generate_block._fuel_to_zero_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate_block._fuel_to_zero_definition)))
(assert (forall ((rns_index~2@ Poly) (num_blocks~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly) (fuel%@ Fuel)) (! (= (crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel%@)) (%Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (ite (= (%I num_blocks~4@) 0) (vstd!seq.Seq.empty.? $ TYPE%crate!semantics.Machine.Instruction.) (vstd!seq.Seq.add.? $ TYPE%crate!semantics.Machine.Instruction. (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ (I (nClip (Sub (%I num_blocks~4@) 1))) r_out~6@ r_in1~8@ r_in2~10@ fuel%@)) (vstd!seq.Seq.push.? $ TYPE%crate!semantics.Machine.Instruction. (vstd!seq.Seq.empty.? $ TYPE%crate!semantics.Machine.Instruction.) (Poly%crate!semantics.Machine.Instruction. (crate!semantics.Machine.Instruction./Add (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.impl&%1.new.? r_out~6@ rns_index~2@ (I (Sub (%I num_blocks~4@) 1))))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.impl&%1.new.? r_in1~8@ rns_index~2@ (I (Sub (%I num_blocks~4@) 1))))) (%Poly%crate!semantics.Machine.Register. (Poly%crate!semantics.Machine.Register. (crate!semantics.Machine.impl&%1.new.? r_in2~10@ rns_index~2@ (I (Sub (%I num_blocks~4@) 1)))))))))))) :pattern ((crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel%@))) :qid internal_crate!kernel_add.AddKernel.spec_generate_block._fuel_to_body_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate_block._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%crate!kernel_add.AddKernel.spec_generate_block.) (forall ((rns_index~2@ Poly) (num_blocks~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly)) (! (= (crate!kernel_add.AddKernel.spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@) (crate!kernel_add.AddKernel.rec%spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel_nat%crate!kernel_add.AddKernel.spec_generate_block.))) :pattern ((crate!kernel_add.AddKernel.spec_generate_block.? rns_index~2@ num_blocks~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_crate!kernel_add.AddKernel.spec_generate_block.?_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate_block.?_definition))))
(set-info :comment ";; Function-Termination crate::kernel_add::AddKernel::spec_generate")
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::spec_generate")
(assert (fuel_bool_default fuel%crate!kernel_add.AddKernel.spec_generate.))
(declare-const fuel_nat%crate!kernel_add.AddKernel.spec_generate. Fuel)
(assert (forall ((log_num_blocks~2@ Poly) (num_rns_terms~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly) (fuel%@ Fuel)) (! (= (crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ fuel%@) (crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ zero)) :pattern ((crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ fuel%@)) :qid internal_crate!kernel_add.AddKernel.spec_generate._fuel_to_zero_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate._fuel_to_zero_definition)))
(assert (forall ((log_num_blocks~2@ Poly) (num_rns_terms~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly) (fuel%@ Fuel)) (! (= (crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel%@)) (%Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (ite (= (%I num_rns_terms~4@) 0) (vstd!seq.Seq.empty.? $ TYPE%crate!semantics.Machine.Instruction.) (vstd!seq.Seq.add.? $ TYPE%crate!semantics.Machine.Instruction. (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ (I (nClip (Sub (%I num_rns_terms~4@) 1))) r_out~6@ r_in1~8@ r_in2~10@ fuel%@)) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (crate!kernel_add.AddKernel.spec_generate_block.? (I (Sub (%I num_rns_terms~4@) 1)) (I (crate!arith.pow2.? log_num_blocks~2@)) r_out~6@ r_in1~8@ r_in2~10@)))))) :pattern ((crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel%@))) :qid internal_crate!kernel_add.AddKernel.spec_generate._fuel_to_body_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%crate!kernel_add.AddKernel.spec_generate.) (forall ((log_num_blocks~2@ Poly) (num_rns_terms~4@ Poly) (r_out~6@ Poly) (r_in1~8@ Poly) (r_in2~10@ Poly)) (! (= (crate!kernel_add.AddKernel.spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@) (crate!kernel_add.AddKernel.rec%spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@ (succ fuel_nat%crate!kernel_add.AddKernel.spec_generate.))) :pattern ((crate!kernel_add.AddKernel.spec_generate.? log_num_blocks~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_crate!kernel_add.AddKernel.spec_generate.?_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.spec_generate.?_definition))))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::parameters")
(assert (fuel_bool_default fuel%crate!kernel_add.AddKernel.parameters.))
(assert (=> (fuel_bool fuel%crate!kernel_add.AddKernel.parameters.) (forall ((rns_moduli~2@ Poly) (log_block_size~4@ Poly)) (! (= (crate!kernel_add.AddKernel.parameters.? rns_moduli~2@ log_block_size~4@) (crate!semantics.Parameters./Parameters (%Poly%vstd!seq.Seq<int.>. rns_moduli~2@) (%I (I (crate!arith.product_of.? rns_moduli~2@))) (%I log_block_size~4@) (%I (I 0)) (%I log_block_size~4@))) :pattern ((crate!kernel_add.AddKernel.parameters.? rns_moduli~2@ log_block_size~4@)) :qid internal_crate!kernel_add.AddKernel.parameters.?_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.parameters.?_definition))))
(assert (forall ((rns_moduli~2@ Poly) (log_block_size~4@ Poly)) (! (=> (and (has_type rns_moduli~2@ (TYPE%vstd!seq.Seq. $ INT)) (has_type log_block_size~4@ NAT)) (has_type (Poly%crate!semantics.Parameters. (crate!kernel_add.AddKernel.parameters.? rns_moduli~2@ log_block_size~4@)) TYPE%crate!semantics.Parameters.)) :pattern ((crate!kernel_add.AddKernel.parameters.? rns_moduli~2@ log_block_size~4@)) :qid internal_crate!kernel_add.AddKernel.parameters.?_pre_post_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.parameters.?_pre_post_definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::lemma_spec_generate_block_valid_instructions")
(declare-fun req%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. (crate!semantics.Machine.State. Int Int Int Int Int) Bool)
(declare-const %%global_location_label%%70 Bool)
(declare-const %%global_location_label%%71 Bool)
(declare-const %%global_location_label%%72 Bool)
(declare-const %%global_location_label%%73 Bool)
(declare-const %%global_location_label%%74 Bool)
(declare-const %%global_location_label%%75 Bool)
(declare-const %%global_location_label%%76 Bool)
(declare-const %%global_location_label%%77 Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (rns_index~4@ Int) (num_blocks~6@ Int) (r_out~8@ Int) (r_in1~10@ Int) (r_in2~12@ Int)) (! (= (req%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@) (and (=> %%global_location_label%%70 (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. init_state~2@))) (=> %%global_location_label%%71 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_out~8@))) (=> %%global_location_label%%72 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in1~10@))) (=> %%global_location_label%%73 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in2~12@))) (=> %%global_location_label%%74 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~10@)))))) (=> %%global_location_label%%75 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~12@)))))) (=> %%global_location_label%%76 (and (<= 0 rns_index~4@) (< rns_index~4@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))))))) (=> %%global_location_label%%77 (and (<= 0 num_blocks~6@) (<= num_blocks~6@ (crate!semantics.Machine.impl&%0.num_blocks.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))))))) :pattern ((req%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@)) :qid internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::lemma_spec_generate_block_valid_instructions")
(declare-fun ens%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. (crate!semantics.Machine.State. Int Int Int Int Int) Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (rns_index~4@ Int) (num_blocks~6@ Int) (r_out~8@ Int) (r_in1~10@ Int) (r_in2~12@ Int)) (! (= (ens%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. init_state~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (crate!kernel_add.AddKernel.spec_generate_block.? (I rns_index~4@) (I num_blocks~6@) (I r_out~8@) (I r_in1~10@) (I r_in2~12@))))) :pattern ((ens%crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@)) :qid internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_block_valid_instructions._definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::lemma_spec_generate_block")
(declare-fun req%crate!kernel_add.AddKernel.lemma_spec_generate_block. (crate!semantics.Machine.State. Int Int Int Int Int) Bool)
(declare-const %%global_location_label%%78 Bool)
(declare-const %%global_location_label%%79 Bool)
(declare-const %%global_location_label%%80 Bool)
(declare-const %%global_location_label%%81 Bool)
(declare-const %%global_location_label%%82 Bool)
(declare-const %%global_location_label%%83 Bool)
(declare-const %%global_location_label%%84 Bool)
(declare-const %%global_location_label%%85 Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (rns_index~4@ Int) (num_blocks~6@ Int) (r_out~8@ Int) (r_in1~10@ Int) (r_in2~12@ Int)) (! (= (req%crate!kernel_add.AddKernel.lemma_spec_generate_block. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@) (and (=> %%global_location_label%%78 (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. init_state~2@))) (=> %%global_location_label%%79 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_out~8@))) (=> %%global_location_label%%80 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in1~10@))) (=> %%global_location_label%%81 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in2~12@))) (=> %%global_location_label%%82 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~10@)))))) (=> %%global_location_label%%83 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~12@)))))) (=> %%global_location_label%%84 (and (<= 0 rns_index~4@) (< rns_index~4@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))))))) (=> %%global_location_label%%85 (and (<= 0 num_blocks~6@) (<= num_blocks~6@ (crate!semantics.Machine.impl&%0.num_blocks.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))))))) :pattern ((req%crate!kernel_add.AddKernel.lemma_spec_generate_block. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@)) :qid internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_block._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_block._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::lemma_spec_generate_block")
(declare-fun ens%crate!kernel_add.AddKernel.lemma_spec_generate_block. (crate!semantics.Machine.State. Int Int Int Int Int) Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (rns_index~4@ Int) (num_blocks~6@ Int) (r_out~8@ Int) (r_in1~10@ Int) (r_in2~12@ Int)) (! (= (ens%crate!kernel_add.AddKernel.lemma_spec_generate_block. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@) (let ((instrs~186$ (crate!kernel_add.AddKernel.spec_generate_block.? (I rns_index~4@) (I num_blocks~6@) (I r_out~8@) (I r_in1~10@) (I r_in2~12@)))) (let ((final_state~195$ (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. init_state~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs~186$)))) (and (and (and (and (and (and (and (and (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. final_state~195$)) (or (= r_in1~10@ r_out~8@) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_in1~10@)) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~10@))))) (or (= r_in2~12@ r_out~8@) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_in2~12@)) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~12@))))) (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@)))))) (forall ((j~294$ Poly) (k~296$ Poly)) (! (=> (and (has_type j~294$ INT) (has_type k~296$ INT)) (=> (and (and (<= 0 (%I j~294$)) (< (%I j~294$) num_blocks~6@)) (and (<= 0 (%I k~296$)) (< (%I k~296$) (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))) (= (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) (I rns_index~4@)) j~294$) k~296$)) (EucMod (Add (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~10@))))) (I rns_index~4@)) j~294$) k~296$)) (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~12@))))) (I rns_index~4@)) j~294$) k~296$))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))) (I rns_index~4@))))))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) (I rns_index~4@)) j~294$) k~296$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_block_72 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_block_72))) (forall ((j~454$ Poly) (k~456$ Poly)) (! (=> (and (has_type j~454$ INT) (has_type k~456$ INT)) (=> (and (and (<= num_blocks~6@ (%I j~454$)) (< (%I j~454$) (crate!semantics.Machine.impl&%0.num_blocks.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) (and (<= 0 (%I k~456$)) (< (%I k~456$) (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))) (= (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) (I rns_index~4@)) j~454$) k~456$) (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@))))) (I rns_index~4@)) j~454$) k~456$)))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) (I rns_index~4@)) j~454$) k~456$)) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@))))) (I rns_index~4@)) j~454$) k~456$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_block_73 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_block_73))) (forall ((i~585$ Poly) (j~587$ Poly) (k~589$ Poly)) (! (=> (and (has_type i~585$ INT) (has_type j~587$ INT) (has_type k~589$ INT)) (=> (and (and (and (and (<= 0 (%I i~585$)) (< (%I i~585$) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))))) (not (= (%I i~585$) rns_index~4@))) (and (<= 0 (%I j~587$)) (< (%I j~587$) (crate!semantics.Machine.impl&%0.num_blocks.? (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@)))))) (and (<= 0 (%I k~589$)) (< (%I k~589$) (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))) (= (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) i~585$) j~587$) k~589$) (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@))))) i~585$) j~587$) k~589$)))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) (I r_out~8@))))) i~585$) j~587$) k~589$)) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~8@))))) i~585$) j~587$) k~589$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_block_74 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_block_74))) (forall ((name~770$ Poly)) (! (=> (has_type name~770$ (SINT 32)) (=> (and (and (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$))))) name~770$) (not (= (%I name~770$) r_out~8@))) (not (= (%I name~770$) r_in1~10@))) (not (= (%I name~770$) r_in2~12@))) (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~770$) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$)))) name~770$) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) name~770$))))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$))))) name~770$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_block_75 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_block_75))) (forall ((name~856$ Poly)) (! (=> (has_type name~856$ (SINT 32)) (=> (not (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$))))) name~856$)) (not (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~856$)))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~195$))))) name~856$)) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~856$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_block_76 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_block_76)))))) :pattern ((ens%crate!kernel_add.AddKernel.lemma_spec_generate_block. init_state~2@ rns_index~4@ num_blocks~6@ r_out~8@ r_in1~10@ r_in2~12@)) :qid internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_block._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_block._definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::lemma_spec_generate_valid_instructions")
(declare-fun req%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. (crate!semantics.Machine.State. Int Int Int Int) Bool)
(declare-const %%global_location_label%%86 Bool)
(declare-const %%global_location_label%%87 Bool)
(declare-const %%global_location_label%%88 Bool)
(declare-const %%global_location_label%%89 Bool)
(declare-const %%global_location_label%%90 Bool)
(declare-const %%global_location_label%%91 Bool)
(declare-const %%global_location_label%%92 Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (num_rns_terms~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (req%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@) (and (=> %%global_location_label%%86 (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. init_state~2@))) (=> %%global_location_label%%87 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_out~6@))) (=> %%global_location_label%%88 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in1~8@))) (=> %%global_location_label%%89 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in2~10@))) (=> %%global_location_label%%90 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@)))))) (=> %%global_location_label%%91 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~10@)))))) (=> %%global_location_label%%92 (and (<= 0 num_rns_terms~4@) (<= num_rns_terms~4@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))))))))) :pattern ((req%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::lemma_spec_generate_valid_instructions")
(declare-fun ens%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. (crate!semantics.Machine.State. Int Int Int Int) Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (num_rns_terms~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (ens%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@) (crate!semantics.Machine.impl&%2.valid_instructions.? (Poly%crate!semantics.Machine.State. init_state~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (crate!kernel_add.AddKernel.spec_generate.? (I (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@))))) (I num_rns_terms~4@) (I r_out~6@) (I r_in1~8@) (I r_in2~10@))))) :pattern ((ens%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions._definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::lemma_spec_generate")
(declare-fun req%crate!kernel_add.AddKernel.lemma_spec_generate. (crate!semantics.Machine.State. Int Int Int Int) Bool)
(declare-const %%global_location_label%%93 Bool)
(declare-const %%global_location_label%%94 Bool)
(declare-const %%global_location_label%%95 Bool)
(declare-const %%global_location_label%%96 Bool)
(declare-const %%global_location_label%%97 Bool)
(declare-const %%global_location_label%%98 Bool)
(declare-const %%global_location_label%%99 Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (num_rns_terms~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (req%crate!kernel_add.AddKernel.lemma_spec_generate. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@) (and (=> %%global_location_label%%93 (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. init_state~2@))) (=> %%global_location_label%%94 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_out~6@))) (=> %%global_location_label%%95 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in1~8@))) (=> %%global_location_label%%96 (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) (I r_in2~10@))) (=> %%global_location_label%%97 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@)))))) (=> %%global_location_label%%98 (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~10@)))))) (=> %%global_location_label%%99 (and (<= 0 num_rns_terms~4@) (<= num_rns_terms~4@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))))))))) :pattern ((req%crate!kernel_add.AddKernel.lemma_spec_generate. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_req__crate!kernel_add.AddKernel.lemma_spec_generate._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.lemma_spec_generate._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::lemma_spec_generate")
(declare-fun ens%crate!kernel_add.AddKernel.lemma_spec_generate. (crate!semantics.Machine.State. Int Int Int Int) Bool)
(assert (forall ((init_state~2@ crate!semantics.Machine.State.) (num_rns_terms~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (ens%crate!kernel_add.AddKernel.lemma_spec_generate. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@) (let ((log_num_blocks~142$ (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@)))))) (let ((instrs~158$ (crate!kernel_add.AddKernel.spec_generate.? (I log_num_blocks~142$) (I num_rns_terms~4@) (I r_out~6@) (I r_in1~8@) (I r_in2~10@)))) (let ((final_state~167$ (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. init_state~2@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. instrs~158$)))) (and (and (and (and (and (and (and (crate!semantics.Machine.impl&%2.valid.? (Poly%crate!semantics.Machine.State. final_state~167$)) (or (= r_in1~8@ r_out~6@) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_in1~8@)) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@))))) (or (= r_in2~10@ r_out~6@) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_in2~10@)) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~10@))))) (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_out~6@)))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@)))))) (forall ((i~265$ Poly) (j~267$ Poly) (k~269$ Poly)) (! (=> (and (has_type i~265$ INT) (has_type j~267$ INT) (has_type k~269$ INT)) (=> (and (and (and (<= 0 (%I i~265$)) (< (%I i~265$) num_rns_terms~4@)) (and (<= 0 (%I j~267$)) (< (%I j~267$) (crate!arith.pow2.? (I log_num_blocks~142$))))) (and (<= 0 (%I k~269$)) (< (%I k~269$) (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))) (= (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_out~6@))))) i~265$) j~267$) k~269$)) (EucMod (Add (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in1~8@))))) i~265$) j~267$) k~269$)) (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_in2~10@))))) i~265$) j~267$) k~269$))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))))) i~265$)))))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_out~6@))))) i~265$) j~267$) k~269$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_77 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_77))) (forall ((i~463$ Poly) (j~465$ Poly) (k~467$ Poly)) (! (=> (and (has_type i~463$ INT) (has_type j~465$ INT) (has_type k~467$ INT)) (=> (and (and (and (<= num_rns_terms~4@ (%I i~463$)) (< (%I i~463$) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))))) (and (<= 0 (%I j~465$)) (< (%I j~465$) (crate!arith.pow2.? (I log_num_blocks~142$))))) (and (<= 0 (%I k~467$)) (< (%I k~467$) (crate!semantics.impl&%0.block_size.? (Poly%crate!semantics.Parameters. (crate!semantics.Machine.State./State/params (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))))))) (= (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_out~6@))))) i~463$) j~465$) k~467$) (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@))))) i~463$) j~465$) k~467$)))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) (I r_out~6@))))) i~463$) j~465$) k~467$)) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) (I r_out~6@))))) i~463$) j~465$) k~467$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_78 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_78))) (forall ((name~629$ Poly)) (! (=> (has_type name~629$ (SINT 32)) (=> (and (and (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$))))) name~629$) (not (= (%I name~629$) r_out~6@))) (not (= (%I name~629$) r_in1~8@))) (not (= (%I name~629$) r_in2~10@))) (and (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~629$) (= (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$)))) name~629$) (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@)))) name~629$))))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$))))) name~629$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_79 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_79))) (forall ((name~715$ Poly)) (! (=> (has_type name~715$ (SINT 32)) (=> (not (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$))))) name~715$)) (not (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~715$)))) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. final_state~167$))))) name~715$)) :pattern ((vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. init_state~2@))))) name~715$)) :qid user_crate__kernel_add__AddKernel__lemma_spec_generate_80 :skolemid skolem_user_crate__kernel_add__AddKernel__lemma_spec_generate_80))))))) :pattern ((ens%crate!kernel_add.AddKernel.lemma_spec_generate. init_state~2@ num_rns_terms~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.lemma_spec_generate._definition)))
(set-info :comment ";; Function-Specs crate::semantics::Parameters::lemma_modulus_greater_than_one")
(declare-fun req%crate!semantics.impl&%0.lemma_modulus_greater_than_one. (crate!semantics.Parameters.) Bool)
(declare-const %%global_location_label%%100 Bool)
(assert (forall ((self~2@ crate!semantics.Parameters.)) (! (= (req%crate!semantics.impl&%0.lemma_modulus_greater_than_one. self~2@) (=> %%global_location_label%%100 (crate!semantics.impl&%0.valid.? (Poly%crate!semantics.Parameters. self~2@)))) :pattern ((req%crate!semantics.impl&%0.lemma_modulus_greater_than_one. self~2@)) :qid internal_req__crate!semantics.impl&__0.lemma_modulus_greater_than_one._definition :skolemid skolem_internal_req__crate!semantics.impl&__0.lemma_modulus_greater_than_one._definition)))
(set-info :comment ";; Function-Axioms crate::semantics::Parameters::lemma_modulus_greater_than_one")
(declare-fun ens%crate!semantics.impl&%0.lemma_modulus_greater_than_one. (crate!semantics.Parameters.) Bool)
(assert (forall ((self~2@ crate!semantics.Parameters.)) (! (= (ens%crate!semantics.impl&%0.lemma_modulus_greater_than_one. self~2@) (> (crate!semantics.Parameters./Parameters/modulus (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. self~2@))) 1)) :pattern ((ens%crate!semantics.impl&%0.lemma_modulus_greater_than_one. self~2@)) :qid internal_ens__crate!semantics.impl&__0.lemma_modulus_greater_than_one._definition :skolemid skolem_internal_ens__crate!semantics.impl&__0.lemma_modulus_greater_than_one._definition)))
(set-info :comment ";; Function-Specs crate::arith::lemma_chinese_remainder_theorem")
(declare-fun req%crate!arith.lemma_chinese_remainder_theorem. (vstd!seq.Seq<int.>. Int Int) Bool)
(declare-const %%global_location_label%%101 Bool)
(declare-const %%global_location_label%%102 Bool)
(declare-const %%global_location_label%%103 Bool)
(assert (forall ((rns_moduli~2@ vstd!seq.Seq<int.>.) (m~4@ Int) (n~6@ Int)) (! (= (req%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~2@ m~4@ n~6@) (and (=> %%global_location_label%%101 (crate!arith.are_valid_rns_moduli.? (Poly%vstd!seq.Seq<int.>. rns_moduli~2@))) (=> %%global_location_label%%102 (and (<= 0 m~4@) (< m~4@ (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. rns_moduli~2@))))) (=> %%global_location_label%%103 (and (<= 0 n~6@) (< n~6@ (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. rns_moduli~2@))))))) :pattern ((req%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~2@ m~4@ n~6@)) :qid internal_req__crate!arith.lemma_chinese_remainder_theorem._definition :skolemid skolem_internal_req__crate!arith.lemma_chinese_remainder_theorem._definition)))
(set-info :comment ";; Function-Axioms crate::arith::lemma_chinese_remainder_theorem")
(declare-fun ens%crate!arith.lemma_chinese_remainder_theorem. (vstd!seq.Seq<int.>. Int Int) Bool)
(assert (forall ((rns_moduli~2@ vstd!seq.Seq<int.>.) (m~4@ Int) (n~6@ Int)) (! (= (ens%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~2@ m~4@ n~6@) (forall ((i~98$ Poly)) (! (=> (has_type i~98$ INT) (=> (and (<= 0 (%I i~98$)) (< (%I i~98$) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@)))) (and (= (EucMod (EucMod (Add m~4@ n~6@) (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. rns_moduli~2@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$))) (EucMod (Add (EucMod m~4@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$))) (EucMod n~6@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$)))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$)))) (= (EucMod (EucMod (Mul m~4@ n~6@) (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. rns_moduli~2@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$))) (EucMod (Mul (EucMod m~4@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$))) (EucMod n~6@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$)))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$))))))) :pattern ((vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~2@) i~98$)) :qid user_crate__arith__lemma_chinese_remainder_theorem_81 :skolemid skolem_user_crate__arith__lemma_chinese_remainder_theorem_81))) :pattern ((ens%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~2@ m~4@ n~6@)) :qid internal_ens__crate!arith.lemma_chinese_remainder_theorem._definition :skolemid skolem_internal_ens__crate!arith.lemma_chinese_remainder_theorem._definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::correctness")
(declare-fun req%crate!kernel_add.AddKernel.correctness. (crate!semantics.Abstract.State. Int Int Int Int) Bool)
(declare-const %%global_location_label%%104 Bool)
(declare-const %%global_location_label%%105 Bool)
(assert (forall ((init_state~2@ crate!semantics.Abstract.State.) (log_degree~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (req%crate!kernel_add.AddKernel.correctness. init_state~2@ log_degree~4@ r_out~6@ r_in1~8@ r_in2~10@) (and (=> %%global_location_label%%104 (crate!semantics.Abstract.impl&%2.valid.? (Poly%crate!semantics.Abstract.State. init_state~2@))) (=> %%global_location_label%%105 (crate!semantics.Abstract.impl&%2.valid_instruction.? (Poly%crate!semantics.Abstract.State. init_state~2@) (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Add (%I (I log_degree~4@)) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_out~6@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in1~8@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in2~10@)))))))))) :pattern ((req%crate!kernel_add.AddKernel.correctness. init_state~2@ log_degree~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_req__crate!kernel_add.AddKernel.correctness._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.correctness._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::correctness")
(declare-fun ens%crate!kernel_add.AddKernel.correctness. (crate!semantics.Abstract.State. Int Int Int Int) Bool)
(assert (forall ((init_state~2@ crate!semantics.Abstract.State.) (log_degree~4@ Int) (r_out~6@ Int) (r_in1~8@ Int) (r_in2~10@ Int)) (! (= (ens%crate!kernel_add.AddKernel.correctness. init_state~2@ log_degree~4@ r_out~6@ r_in1~8@ r_in2~10@) (let ((abstract_instr~97$ (crate!semantics.Abstract.Instruction./Add (%I (I log_degree~4@)) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_out~6@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in1~8@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in2~10@))))))) (let ((machine_instrs~131$ (crate!kernel_add.AddKernel.spec_generate.? (I (nClip (Sub log_degree~4@ (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@))))))))) (I (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@))))))))) (I r_out~6@) (I r_in1~8@) (I r_in2~10@)))) (let ((abstract_state~140$ (crate!semantics.Abstract.impl&%2.step.? (Poly%crate!semantics.Abstract.State. init_state~2@) (Poly%crate!semantics.Abstract.Instruction. abstract_instr~97$)))) (let ((machine_state~151$ (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. init_state~2@))) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. machine_instrs~131$)))) (= (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. abstract_state~140$)) machine_state~151$)))))) :pattern ((ens%crate!kernel_add.AddKernel.correctness. init_state~2@ log_degree~4@ r_out~6@ r_in1~8@ r_in2~10@)) :qid internal_ens__crate!kernel_add.AddKernel.correctness._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.correctness._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::impl_instrs_to_machine_instrs")
(assert (fuel_bool_default fuel%crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.))
(declare-fun %%lambda%%7 (Dcr Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Dcr) (%%hole%%1 Type) (%%hole%%2 Poly) (i~19$ Poly)) (! (= (%%apply%%0 (%%lambda%%7 %%hole%%0 %%hole%%1 %%hole%%2) i~19$) (Poly%crate!semantics.Machine.Instruction. (crate!semantics.MachineImplementation.impl&%1.to_machine.? (vstd!seq.Seq.index.? %%hole%%0 %%hole%%1 %%hole%%2 i~19$)))) :pattern ((%%apply%%0 (%%lambda%%7 %%hole%%0 %%hole%%1 %%hole%%2) i~19$)))))
(assert (=> (fuel_bool fuel%crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.) (forall ((instrs~2@ Poly)) (! (= (crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.? instrs~2@) (%Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. (vstd!seq.Seq.new.? $ TYPE%crate!semantics.Machine.Instruction. $ (TYPE%fun%1. $ INT $ TYPE%crate!semantics.Machine.Instruction.) (I (vstd!seq.Seq.len.? $ TYPE%crate!semantics.MachineImplementation.Instruction. instrs~2@)) (Poly%fun%1. (mk_fun (%%lambda%%7 $ TYPE%crate!semantics.MachineImplementation.Instruction. instrs~2@)))))) :pattern ((crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.? instrs~2@)) :qid internal_crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.?_definition :skolemid skolem_internal_crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.?_definition))))
(set-info :comment ";; Function-Specs crate::arith::pow2_impl")
(declare-fun req%crate!arith.pow2_impl. (Int) Bool)
(declare-const %%global_location_label%%106 Bool)
(assert (forall ((n~2@ Int)) (! (= (req%crate!arith.pow2_impl. n~2@) (=> %%global_location_label%%106 (<= n~2@ 31))) :pattern ((req%crate!arith.pow2_impl. n~2@)) :qid internal_req__crate!arith.pow2_impl._definition :skolemid skolem_internal_req__crate!arith.pow2_impl._definition)))
(set-info :comment ";; Function-Axioms crate::arith::pow2_impl")
(declare-fun ens%crate!arith.pow2_impl. (Int Int) Bool)
(assert (forall ((n~2@ Int) (r~27@ Int)) (! (= (ens%crate!arith.pow2_impl. n~2@ r~27@) (and (uInv 32 r~27@) (= r~27@ (crate!arith.pow2.? (I n~2@))))) :pattern ((ens%crate!arith.pow2_impl. n~2@ r~27@)) :qid internal_ens__crate!arith.pow2_impl._definition :skolemid skolem_internal_ens__crate!arith.pow2_impl._definition)))
(set-info :comment ";; Function-Specs crate::kernel_add::AddKernel::generate")
(declare-fun req%crate!kernel_add.AddKernel.generate. (Int Int Int Int Int) Bool)
(declare-const %%global_location_label%%107 Bool)
(declare-const %%global_location_label%%108 Bool)
(assert (forall ((r_out~2@ Int) (r_in1~4@ Int) (r_in2~6@ Int) (num_rns_terms~8@ Int) (log_num_blocks~10@ Int)) (! (= (req%crate!kernel_add.AddKernel.generate. r_out~2@ r_in1~4@ r_in2~6@ num_rns_terms~8@ log_num_blocks~10@) (and (=> %%global_location_label%%107 (> num_rns_terms~8@ 0)) (=> %%global_location_label%%108 (<= log_num_blocks~10@ 31)))) :pattern ((req%crate!kernel_add.AddKernel.generate. r_out~2@ r_in1~4@ r_in2~6@ num_rns_terms~8@ log_num_blocks~10@)) :qid internal_req__crate!kernel_add.AddKernel.generate._definition :skolemid skolem_internal_req__crate!kernel_add.AddKernel.generate._definition)))
(set-info :comment ";; Function-Axioms crate::kernel_add::AddKernel::generate")
(declare-fun ens%crate!kernel_add.AddKernel.generate. (Int Int Int Int Int alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.) Bool)
(assert (forall ((r_out~2@ Int) (r_in1~4@ Int) (r_in2~6@ Int) (num_rns_terms~8@ Int) (log_num_blocks~10@ Int) (r~45@ alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>.)) (! (= (ens%crate!kernel_add.AddKernel.generate. r_out~2@ r_in1~4@ r_in2~6@ num_rns_terms~8@ log_num_blocks~10@ r~45@) (= (crate!kernel_add.AddKernel.impl_instrs_to_machine_instrs.? (vstd!std_specs.vec.VecAdditionalSpecFns.view.? $ (TYPE%alloc!vec.Vec. $ TYPE%crate!semantics.MachineImplementation.Instruction. $ TYPE%alloc!alloc.Global.) $ TYPE%crate!semantics.MachineImplementation.Instruction. (Poly%alloc!vec.Vec<crate!semantics.MachineImplementation.Instruction./alloc!alloc.Global.>. r~45@))) (crate!kernel_add.AddKernel.spec_generate.? (I log_num_blocks~10@) (I num_rns_terms~8@) (I r_out~2@) (I r_in1~4@) (I r_in2~6@)))) :pattern ((ens%crate!kernel_add.AddKernel.generate. r_out~2@ r_in1~4@ r_in2~6@ num_rns_terms~8@ log_num_blocks~10@ r~45@)) :qid internal_ens__crate!kernel_add.AddKernel.generate._definition :skolemid skolem_internal_ens__crate!kernel_add.AddKernel.generate._definition)))
(set-info :comment ";; Function-Def crate::kernel_add::AddKernel::lemma_spec_generate_block_valid_instructions")
(set-info :comment ";; Function-Def crate::kernel_add::AddKernel::lemma_spec_generate_block")
(set-info :comment ";; Function-Def crate::kernel_add::AddKernel::lemma_spec_generate_valid_instructions")
(set-info :comment ";; Function-Def crate::kernel_add::AddKernel::lemma_spec_generate")
(set-info :comment ";; Function-Def crate::kernel_add::AddKernel::correctness")
(push 1)
(declare-const init_state~2@ crate!semantics.Abstract.State.)
(declare-const log_degree~4@ Int)
(declare-const r_out~6@ Int)
(declare-const r_in1~8@ Int)
(declare-const r_in2~10@ Int)
(declare-const tmp%1@ Bool)
(declare-const tmp%2@ Int)
(declare-const tmp%3@ Int)
(declare-const tmp%4@ Bool)
(declare-const tmp%5@ Bool)
(declare-const tmp%6@ Bool)
(declare-const tmp%7@ Bool)
(declare-const tmp%8@ Bool)
(declare-const tmp%9@ Bool)
(declare-const i~534@ Poly)
(declare-const j~536@ Poly)
(declare-const k~538@ Poly)
(declare-const tmp%10@ Bool)
(declare-const tmp%11@ Bool)
(declare-const tmp%12@ Bool)
(declare-const tmp%13@ Bool)
(declare-const tmp%14@ Int)
(declare-const tmp%15@ Int)
(declare-const coeff_index~692@ Int)
(declare-const tmp%16@ Bool)
(declare-const tmp%17@ Bool)
(declare-const params~170@ crate!semantics.Parameters.)
(declare-const log_block_size~176@ Int)
(declare-const rns_moduli~182@ vstd!seq.Seq<int.>.)
(declare-const log_num_blocks~199@ Int)
(declare-const num_blocks~207@ Int)
(declare-const block_size~215@ Int)
(declare-const init_machine_state~235@ crate!semantics.Machine.State.)
(declare-const what~240@ crate!semantics.Abstract.State.)
(declare-const poly1~250@ crate!semantics.Abstract.Polynomial.)
(declare-const poly2~260@ crate!semantics.Abstract.Polynomial.)
(declare-const abstract_instr~294@ crate!semantics.Abstract.Instruction.)
(declare-const machine_instrs~324@ vstd!seq.Seq<crate!semantics.Machine.Instruction.>.)
(declare-const abstract_state~333@ crate!semantics.Abstract.State.)
(declare-const machine_state~342@ crate!semantics.Machine.State.)
(declare-const abstract_poly0~357@ crate!semantics.Abstract.Polynomial.)
(declare-const machine_poly0_0~366@ crate!semantics.Machine.Polynomial.)
(declare-const machine_poly0_1~376@ crate!semantics.Machine.Polynomial.)
(declare-const machine_poly1~385@ crate!semantics.Machine.Polynomial.)
(declare-const machine_poly2~394@ crate!semantics.Machine.Polynomial.)
(assert fuel_defaults)
(assert (has_type (Poly%crate!semantics.Abstract.State. init_state~2@) TYPE%crate!semantics.Abstract.State.))
(assert (<= 0 log_degree~4@))
(assert (iInv 32 r_out~6@))
(assert (iInv 32 r_in1~8@))
(assert (iInv 32 r_in2~10@))
(assert (crate!semantics.Abstract.impl&%2.valid.? (Poly%crate!semantics.Abstract.State. init_state~2@)))
(assert (crate!semantics.Abstract.impl&%2.valid_instruction.? (Poly%crate!semantics.Abstract.State. init_state~2@) (Poly%crate!semantics.Abstract.Instruction. (crate!semantics.Abstract.Instruction./Add (%I (I log_degree~4@)) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_out~6@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in1~8@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in2~10@))))))))
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%2 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%3 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%4 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%5 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%6 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%7 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%8 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%9 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%10 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%11 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%12 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%13 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%14 Bool)
(set-info :comment ";; precondition not satisfied")
(declare-const %%location_label%%15 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%16 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%17 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%18 Bool)
(set-info :comment ";; postcondition not satisfied")
(declare-const %%location_label%%19 Bool)
(declare-const %%query%% Bool)
(assert (=> %%query%% (not (=> (= params~170@ (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@)))) (=> (= log_block_size~176@ (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. params~170@)))) (=> (= rns_moduli~182@ (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. params~170@)))) (=> (= log_num_blocks~199@ (nClip (Sub log_degree~4@ log_block_size~176@))) (=> (= num_blocks~207@ (crate!arith.pow2.? (I log_num_blocks~199@))) (=> (= block_size~215@ (crate!arith.pow2.? (I log_block_size~176@))) (=> (= tmp%1@ (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@))))) (I r_out~6@))) (and (=> %%location_label%%0 tmp%1@) (=> tmp%1@ (=> (= init_machine_state~235@ (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. init_state~2@))) (=> (= what~240@ init_state~2@) (=> (= poly1~250@ (%Poly%crate!semantics.Abstract.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@)))) (I r_in1~8@)))) (=> (= poly2~260@ (%Poly%crate!semantics.Abstract.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@)))) (I r_in2~10@)))) (=> (= abstract_instr~294@ (crate!semantics.Abstract.Instruction./Add (%I (I log_degree~4@)) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_out~6@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in1~8@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in2~10@)))))) (=> (= machine_instrs~324@ (crate!kernel_add.AddKernel.spec_generate.? (I (nClip (Sub log_degree~4@ log_block_size~176@))) (I (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@))) (I r_out~6@) (I r_in1~8@) (I r_in2~10@))) (=> (= abstract_state~333@ (crate!semantics.Abstract.impl&%2.step.? (Poly%crate!semantics.Abstract.State. init_state~2@) (Poly%crate!semantics.Abstract.Instruction. abstract_instr~294@))) (=> (= machine_state~342@ (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. init_machine_state~235@) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. machine_instrs~324@))) (and (=> %%location_label%%1 (req%crate!semantics.impl&%0.lemma_modulus_greater_than_one. params~170@)) (=> (ens%crate!semantics.impl&%0.lemma_modulus_greater_than_one. params~170@) (=> (= abstract_poly0~357@ (%Poly%crate!semantics.Abstract.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Abstract.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Abstract.Polynomial.>. (crate!semantics.Abstract.State./State/registers (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. abstract_state~333@)))) (I r_out~6@)))) (=> (= machine_poly0_0~366@ (crate!semantics.Abstract.impl&%0.to_machine.? (Poly%crate!semantics.Abstract.Polynomial. abstract_poly0~357@) (Poly%crate!semantics.Parameters. params~170@))) (=> (= machine_poly0_1~376@ (%Poly%crate!semantics.Machine.Polynomial. (vstd!map.impl&%0.index.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. machine_state~342@)))) (I r_out~6@)))) (=> (= machine_poly1~385@ (crate!semantics.Abstract.impl&%0.to_machine.? (Poly%crate!semantics.Abstract.Polynomial. poly1~250@) (Poly%crate!semantics.Parameters. params~170@))) (=> (= machine_poly2~394@ (crate!semantics.Abstract.impl&%0.to_machine.? (Poly%crate!semantics.Abstract.Polynomial. poly2~260@) (Poly%crate!semantics.Parameters. params~170@))) (=> (= tmp%2@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@))) (and (=> %%location_label%%2 (req%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_machine_state~235@ tmp%2@ r_out~6@ r_in1~8@ r_in2~10@)) (=> (ens%crate!kernel_add.AddKernel.lemma_spec_generate_valid_instructions. init_machine_state~235@ tmp%2@ r_out~6@ r_in1~8@ r_in2~10@) (=> (ens%crate!semantics.Machine.impl&%2.lemma_steps_preserve_parameters. init_machine_state~235@ machine_instrs~324@) (=> (= tmp%3@ (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@))) (and (=> %%location_label%%3 (req%crate!kernel_add.AddKernel.lemma_spec_generate. init_machine_state~235@ tmp%3@ r_out~6@ r_in1~8@ r_in2~10@)) (=> (ens%crate!kernel_add.AddKernel.lemma_spec_generate. init_machine_state~235@ tmp%3@ r_out~6@ r_in1~8@ r_in2~10@) (=> (= tmp%4@ (vstd!set.impl&%0.contains.? $ (SINT 32) (vstd!map.impl&%0.dom.? $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial. (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. machine_state~342@))))) (I r_out~6@))) (and (=> %%location_label%%4 tmp%4@) (=> tmp%4@ (=> (= tmp%5@ (crate!semantics.Machine.impl&%0.valid.? (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@) (Poly%crate!semantics.Parameters. params~170@))) (and (=> %%location_label%%5 tmp%5@) (=> tmp%5@ (=> (= tmp%6@ (crate!semantics.Machine.impl&%0.valid.? (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@) (Poly%crate!semantics.Parameters. params~170@))) (and (=> %%location_label%%6 tmp%6@) (=> tmp%6@ (=> (= tmp%7@ (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@))) (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@))))) (and (=> %%location_label%%7 tmp%7@) (=> tmp%7@ (=> (= tmp%8@ (= (crate!semantics.Machine.Polynomial./Polynomial/log_num_blocks (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@))) log_num_blocks~199@)) (and (=> %%location_label%%8 tmp%8@) (=> tmp%8@ (=> (= tmp%9@ (= (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@)) (vstd!seq.Seq.len.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@))))))) (and (=> %%location_label%%9 tmp%9@) (=> tmp%9@ (and (=> (has_type i~534@ INT) (=> (has_type j~536@ INT) (=> (has_type k~538@ INT) (=> (and (and (and (<= 0 (%I i~534@)) (< (%I i~534@) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@)))) (and (<= 0 (%I j~536@)) (< (%I j~536@) num_blocks~207@))) (and (<= 0 (%I k~538@)) (< (%I k~538@) block_size~215@))) (=> (= coeff_index~692@ (crate!semantics.block_index_to_coeff_index.? (Poly%crate!semantics.Parameters. params~170@) j~536@ k~538@)) (and (=> %%location_label%%10 (req%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~170@ poly1~250@ (%I j~536@) (%I k~538@))) (=> (ens%crate!semantics.Abstract.lemma_block_index_to_coeff_index_in_bound. params~170@ poly1~250@ (%I j~536@) (%I k~538@)) (=> (= tmp%10@ (= (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly2~394@)))) i~534@) j~536@) k~538@)) (EucMod (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly2~260@)))) (I coeff_index~692@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@) i~534@))))) (and (=> %%location_label%%11 tmp%10@) (=> tmp%10@ (=> (= tmp%11@ (= (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@)))) i~534@) j~536@) k~538@)) (EucMod (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. abstract_poly0~357@)))) (I coeff_index~692@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@) i~534@))))) (and (=> %%location_label%%12 tmp%11@) (=> tmp%11@ (=> (= tmp%12@ (= (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@)))) i~534@) j~536@) k~538@)) (EucMod (Add (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly1~385@)))) i~534@) j~536@) k~538@)) (%I (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly2~394@)))) i~534@) j~536@) k~538@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@) i~534@))))) (and (=> %%location_label%%13 tmp%12@) (=> tmp%12@ (=> (= tmp%13@ (= (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. abstract_poly0~357@)))) (I coeff_index~692@))) (EucMod (Add (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly1~250@)))) (I coeff_index~692@))) (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly2~260@)))) (I coeff_index~692@)))) (crate!arith.product_of.? (Poly%vstd!seq.Seq<int.>. rns_moduli~182@))))) (and (=> %%location_label%%14 tmp%13@) (=> tmp%13@ (=> (= tmp%14@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly1~250@)))) (I coeff_index~692@)))) (=> (= tmp%15@ (%I (vstd!seq.Seq.index.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Abstract.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Abstract.Polynomial. (Poly%crate!semantics.Abstract.Polynomial. poly2~260@)))) (I coeff_index~692@)))) (and (=> %%location_label%%15 (req%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~182@ tmp%14@ tmp%15@)) (=> (ens%crate!arith.lemma_chinese_remainder_theorem. rns_moduli~182@ tmp%14@ tmp%15@) (=> %%location_label%%16 (= (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@)))) i~534@) j~536@) k~538@) (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@)))) i~534@) j~536@) k~538@)))))))))))))))))))))))))) (=> (forall ((i~534$ Poly) (j~536$ Poly) (k~538$ Poly)) (! (=> (and (has_type i~534$ INT) (has_type j~536$ INT) (has_type k~538$ INT)) (=> (and (and (and (<= 0 (%I i~534$)) (< (%I i~534$) (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. rns_moduli~182@)))) (and (<= 0 (%I j~536$)) (< (%I j~536$) num_blocks~207@))) (and (<= 0 (%I k~538$)) (< (%I k~538$) block_size~215@))) (= (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@)))) i~534$) j~536$) k~538$) (vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@)))) i~534$) j~536$) k~538$)))) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@)))) i~534$) j~536$) k~538$)) :pattern ((vstd!seq.Seq.index.? $ INT (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ INT) (vstd!seq.Seq.index.? $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT)) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@)))) i~534$) j~536$) k~538$)) :qid user_crate__kernel_add__AddKernel__correctness_91 :skolemid skolem_user_crate__kernel_add__AddKernel__correctness_91)) (=> (= tmp%16@ (ext_eq true (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ (TYPE%vstd!seq.Seq. $ INT))) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_0~366@)))) (Poly%vstd!seq.Seq<vstd!seq.Seq<vstd!seq.Seq<int.>.>.>. (crate!semantics.Machine.Polynomial./Polynomial/coeffs (%Poly%crate!semantics.Machine.Polynomial. (Poly%crate!semantics.Machine.Polynomial. machine_poly0_1~376@)))))) (and (=> %%location_label%%17 tmp%16@) (=> tmp%16@ (=> (= tmp%17@ (ext_eq true (TYPE%vstd!map.Map. $ (SINT 32) $ TYPE%crate!semantics.Machine.Polynomial.) (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. abstract_state~333@)))))) (Poly%vstd!map.Map<i32./crate!semantics.Machine.Polynomial.>. (crate!semantics.Machine.State./State/registers (%Poly%crate!semantics.Machine.State. (Poly%crate!semantics.Machine.State. machine_state~342@)))))) (and (=> %%location_label%%18 tmp%17@) (=> tmp%17@ (=> %%location_label%%19 (let ((abstract_instr~97$ (crate!semantics.Abstract.Instruction./Add (%I (I log_degree~4@)) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_out~6@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in1~8@)))) (%Poly%crate!semantics.Abstract.Register. (Poly%crate!semantics.Abstract.Register. (crate!semantics.Abstract.impl&%1.new.? (I r_in2~10@))))))) (let ((machine_instrs~131$ (crate!kernel_add.AddKernel.spec_generate.? (I (nClip (Sub log_degree~4@ (crate!semantics.Parameters./Parameters/log_block_size (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@))))))))) (I (vstd!seq.Seq.len.? $ INT (Poly%vstd!seq.Seq<int.>. (crate!semantics.Parameters./Parameters/rns_moduli (%Poly%crate!semantics.Parameters. (Poly%crate!semantics.Parameters. (crate!semantics.Abstract.State./State/params (%Poly%crate!semantics.Abstract.State. (Poly%crate!semantics.Abstract.State. init_state~2@))))))))) (I r_out~6@) (I r_in1~8@) (I r_in2~10@)))) (let ((abstract_state~140$ (crate!semantics.Abstract.impl&%2.step.? (Poly%crate!semantics.Abstract.State. init_state~2@) (Poly%crate!semantics.Abstract.Instruction. abstract_instr~97$)))) (let ((machine_state~151$ (crate!semantics.Machine.impl&%2.steps.? (Poly%crate!semantics.Machine.State. (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. init_state~2@))) (Poly%vstd!seq.Seq<crate!semantics.Machine.Instruction.>. machine_instrs~131$)))) (= (crate!semantics.Abstract.impl&%2.to_machine.? (Poly%crate!semantics.Abstract.State. abstract_state~140$)) machine_state~151$))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(assert %%query%%)
(check-sat)
