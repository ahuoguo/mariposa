(set-option :auto_config false)
(set-option :smt.mbqi false)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100.0)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :rewriter.sort_disjunctions false)
(set-info :comment ";; Prelude")
(set-info :comment ";; AIR prelude")
(declare-sort %%Function%% 0)
(declare-sort FuelId 0)
(declare-sort Fuel 0)
(declare-const zero Fuel)
(declare-fun succ (Fuel) Fuel)
(declare-fun fuel_bool (FuelId) Bool)
(declare-fun fuel_bool_default (FuelId) Bool)
(declare-const fuel_defaults Bool)
(assert (=> fuel_defaults (forall ((id FuelId)) (! (= (fuel_bool id) (fuel_bool_default id)) :pattern ((fuel_bool id)) :qid prelude_fuel_defaults :skolemid skolem_prelude_fuel_defaults))))
(declare-sort Char 0)
(declare-fun char%from_unicode (Int) Char)
(declare-fun char%to_unicode (Char) Int)
(declare-sort StrSlice 0)
(declare-fun str%strslice_is_ascii (StrSlice) Bool)
(declare-fun str%strslice_len (StrSlice) Int)
(declare-fun str%strslice_get_char (StrSlice Int) Char)
(declare-fun str%new_strlit (Int) StrSlice)
(declare-fun str%from_strlit (StrSlice) Int)
(declare-sort Poly 0)
(declare-sort Height 0)
(declare-fun I (Int) Poly)
(declare-fun B (Bool) Poly)
(declare-fun %I (Poly) Int)
(declare-fun %B (Poly) Bool)
(declare-fun S (StrSlice) Poly)
(declare-fun %S (Poly) StrSlice)
(declare-fun C (Char) Poly)
(declare-fun %C (Poly) Char)
(declare-sort Type 0)
(declare-const BOOL Type)
(declare-const INT Type)
(declare-const NAT Type)
(declare-const STRSLICE Type)
(declare-const CHAR Type)
(declare-fun UINT (Int) Type)
(declare-fun SINT (Int) Type)
(declare-fun CONST_INT (Int) Type)
(declare-fun REF (Type) Type)
(declare-fun MUT_REF (Type) Type)
(declare-fun BOX (Type) Type)
(declare-fun RC (Type) Type)
(declare-fun ARC (Type) Type)
(declare-fun GHOST (Type) Type)
(declare-fun TRACKED (Type) Type)
(declare-fun NEVER (Type) Type)
(declare-fun has_type (Poly Type) Bool)
(declare-fun as_type (Poly Type) Poly)
(declare-fun mk_fun (%%Function%%) %%Function%%)
(declare-fun const_int (Type) Int)
(assert (forall ((i Int)) (= i (const_int (CONST_INT i)))))
(assert (has_type (B true) BOOL))
(assert (has_type (B false) BOOL))
(assert (forall ((x Poly) (t Type)) (! (and (has_type (as_type x t) t) (=> (has_type x t) (= x (as_type x t)))) :pattern ((as_type x t)) :qid prelude_as_type :skolemid skolem_prelude_as_type)))
(assert (forall ((x %%Function%%)) (! (= (mk_fun x) x) :pattern ((mk_fun x)) :qid prelude_mk_fun :skolemid skolem_prelude_mk_fun)))
(assert (forall ((x Bool)) (! (= x (%B (B x))) :pattern ((B x)) :qid prelude_unbox_box_bool :skolemid skolem_prelude_unbox_box_bool)))
(assert (forall ((x Int)) (! (= x (%I (I x))) :pattern ((I x)) :qid prelude_unbox_box_int :skolemid skolem_prelude_unbox_box_int)))
(assert (forall ((x Poly)) (! (=> (has_type x BOOL) (= x (B (%B x)))) :pattern ((has_type x BOOL)) :qid prelude_box_unbox_bool :skolemid skolem_prelude_box_unbox_bool)))
(assert (forall ((x Poly)) (! (=> (has_type x INT) (= x (I (%I x)))) :pattern ((has_type x INT)) :qid prelude_box_unbox_int :skolemid skolem_prelude_box_unbox_int)))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (= x (I (%I x)))) :pattern ((has_type x NAT)) :qid prelude_box_unbox_nat :skolemid skolem_prelude_box_unbox_nat)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (= x (I (%I x)))) :pattern ((has_type x (UINT bits))) :qid prelude_box_unbox_uint :skolemid skolem_prelude_box_unbox_uint)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (= x (I (%I x)))) :pattern ((has_type x (SINT bits))) :qid prelude_box_unbox_sint :skolemid skolem_prelude_box_unbox_sint)))
(assert (forall ((x Int)) (! (= (str%from_strlit (str%new_strlit x)) x) :pattern ((str%new_strlit x)) :qid prelude_strlit_injective :skolemid skolem_prelude_strlit_injective)))
(assert (forall ((x Poly)) (! (=> (has_type x STRSLICE) (= x (S (%S x)))) :pattern ((has_type x STRSLICE)) :qid prelude_box_unbox_strslice :skolemid skolem_prelude_box_unbox_strslice)))
(assert (forall ((x StrSlice)) (! (= x (%S (S x))) :pattern ((S x)) :qid prelude_unbox_box_strslice :skolemid skolem_prelude_unbox_box_strslice)))
(assert (forall ((x StrSlice)) (! (has_type (S x) STRSLICE) :pattern ((has_type (S x) STRSLICE)) :qid prelude_has_type_strslice :skolemid skolem_prelude_has_type_strslice)))
(declare-fun ext_eq (Bool Type Type Poly Poly) Bool)
(assert (forall ((deep Bool) (t Type) (td Type) (x Poly) (y Poly)) (! (= (= x y) (ext_eq deep t td x y)) :pattern ((ext_eq deep t td x y)) :qid prelude_ext_eq :skolemid skolem_prelude_ext_eq)))
(declare-const SZ Int)
(assert (= SZ 64))
(declare-fun uHi (Int) Int)
(declare-fun iLo (Int) Int)
(declare-fun iHi (Int) Int)
(assert (= (uHi 8) 256))
(assert (= (uHi 16) 65536))
(assert (= (uHi 32) 4294967296))
(assert (= (uHi 64) 18446744073709551616))
(assert (= (uHi 128) (+ 1 340282366920938463463374607431768211455)))
(assert (= (iLo 8) (- 128)))
(assert (= (iLo 16) (- 32768)))
(assert (= (iLo 32) (- 2147483648)))
(assert (= (iLo 64) (- 9223372036854775808)))
(assert (= (iLo 128) (- 170141183460469231731687303715884105728)))
(assert (= (iHi 8) 128))
(assert (= (iHi 16) 32768))
(assert (= (iHi 32) 2147483648))
(assert (= (iHi 64) 9223372036854775808))
(assert (= (iHi 128) 170141183460469231731687303715884105728))
(declare-fun nClip (Int) Int)
(declare-fun uClip (Int Int) Int)
(declare-fun iClip (Int Int) Int)
(assert (forall ((i Int)) (! (and (<= 0 (nClip i)) (=> (<= 0 i) (= i (nClip i)))) :pattern ((nClip i)) :qid prelude_nat_clip :skolemid skolem_prelude_nat_clip)))
(assert (forall ((bits Int) (i Int)) (! (and (<= 0 (uClip bits i)) (< (uClip bits i) (uHi bits)) (=> (and (<= 0 i) (< i (uHi bits))) (= i (uClip bits i)))) :pattern ((uClip bits i)) :qid prelude_u_clip :skolemid skolem_prelude_u_clip)))
(assert (forall ((bits Int) (i Int)) (! (and (<= (iLo bits) (iClip bits i)) (< (iClip bits i) (iHi bits)) (=> (and (<= (iLo bits) i) (< i (iHi bits))) (= i (iClip bits i)))) :pattern ((iClip bits i)) :qid prelude_i_clip :skolemid skolem_prelude_i_clip)))
(declare-fun uInv (Int Int) Bool)
(declare-fun iInv (Int Int) Bool)
(assert (forall ((bits Int) (i Int)) (! (= (uInv bits i) (and (<= 0 i) (< i (uHi bits)))) :pattern ((uInv bits i)) :qid prelude_u_inv :skolemid skolem_prelude_u_inv)))
(assert (forall ((bits Int) (i Int)) (! (= (iInv bits i) (and (<= (iLo bits) i) (< i (iHi bits)))) :pattern ((iInv bits i)) :qid prelude_i_inv :skolemid skolem_prelude_i_inv)))
(assert (forall ((x Int)) (! (has_type (I x) INT) :pattern ((has_type (I x) INT)) :qid prelude_has_type_int :skolemid skolem_prelude_has_type_int)))
(assert (forall ((x Int)) (! (=> (<= 0 x) (has_type (I x) NAT)) :pattern ((has_type (I x) NAT)) :qid prelude_has_type_nat :skolemid skolem_prelude_has_type_nat)))
(assert (forall ((bits Int) (x Int)) (! (=> (uInv bits x) (has_type (I x) (UINT bits))) :pattern ((has_type (I x) (UINT bits))) :qid prelude_has_type_uint :skolemid skolem_prelude_has_type_uint)))
(assert (forall ((bits Int) (x Int)) (! (=> (iInv bits x) (has_type (I x) (SINT bits))) :pattern ((has_type (I x) (SINT bits))) :qid prelude_has_type_sint :skolemid skolem_prelude_has_type_sint)))
(assert (forall ((x Poly)) (! (=> (has_type x NAT) (<= 0 (%I x))) :pattern ((has_type x NAT)) :qid prelude_unbox_int :skolemid skolem_prelude_unbox_int)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (UINT bits)) (uInv bits (%I x))) :pattern ((has_type x (UINT bits))) :qid prelude_unbox_uint :skolemid skolem_prelude_unbox_uint)))
(assert (forall ((bits Int) (x Poly)) (! (=> (has_type x (SINT bits)) (iInv bits (%I x))) :pattern ((has_type x (SINT bits))) :qid prelude_unbox_sint :skolemid skolem_prelude_unbox_sint)))
(declare-fun Mul (Int Int) Int)
(declare-fun EucDiv (Int Int) Int)
(declare-fun EucMod (Int Int) Int)
(assert (forall ((x Int) (y Int)) (! (= (Mul x y) (* x y)) :pattern ((Mul x y)) :qid prelude_mul :skolemid skolem_prelude_mul)))
(assert (forall ((x Int) (y Int)) (! (= (EucDiv x y) (div x y)) :pattern ((EucDiv x y)) :qid prelude_eucdiv :skolemid skolem_prelude_eucdiv)))
(assert (forall ((x Int) (y Int)) (! (= (EucMod x y) (mod x y)) :pattern ((EucMod x y)) :qid prelude_eucmod :skolemid skolem_prelude_eucmod)))
(assert (forall ((x Poly)) (! (=> (has_type x CHAR) (= x (C (%C x)))) :pattern ((has_type x CHAR)) :qid prelude_box_unbox_char :skolemid skolem_prelude_box_unbox_char)))
(assert (forall ((x Char)) (! (= x (%C (C x))) :pattern ((C x)) :qid prelude_unbox_box_char :skolemid skolem_prelude_unbox_box_char)))
(assert (forall ((x Char)) (! (has_type (C x) CHAR) :pattern ((has_type (C x) CHAR)) :qid prelude_has_type_char :skolemid skolem_prelude_has_type_char)))
(assert (forall ((x Int)) (! (= (char%to_unicode (char%from_unicode x)) x) :pattern ((char%from_unicode x)) :qid prelude_char_injective :skolemid skolem_prelude_char_injective)))
(assert (forall ((c Char)) (! (and (<= 0 (char%to_unicode c)) (< (char%to_unicode c) (uHi 32))) :pattern ((char%to_unicode c)) :qid prelude_to_unicode_bounds :skolemid skolem_prelude_to_unicode_bounds)))
(declare-fun height (Poly) Height)
(declare-fun height_lt (Height Height) Bool)
(assert (forall ((x Height) (y Height)) (! (= (height_lt x y) (and ((_ partial-order 0) x y) (not (= x y)))) :pattern ((height_lt x y)) :qid prelude_height_lt :skolemid skolem_prelude_height_lt)))
(declare-fun fun_from_recursive_field (Poly) Poly)
(declare-fun check_decrease_int (Int Int Bool) Bool)
(assert (forall ((cur Int) (prev Int) (otherwise Bool)) (! (= (check_decrease_int cur prev otherwise) (or (and (<= 0 cur) (< cur prev)) (and (= cur prev) otherwise))) :pattern ((check_decrease_int cur prev otherwise)) :qid prelude_check_decrease_int :skolemid skolem_prelude_check_decrease_int)))
(declare-fun check_decrease_height (Poly Poly Bool) Bool)
(assert (forall ((cur Poly) (prev Poly) (otherwise Bool)) (! (= (check_decrease_height cur prev otherwise) (or (height_lt (height cur) (height prev)) (and (= (height cur) (height prev)) otherwise))) :pattern ((check_decrease_height cur prev otherwise)) :qid prelude_check_decrease_height :skolemid skolem_prelude_check_decrease_height)))
(declare-fun uintxor (Int Poly Poly) Int)
(declare-fun uintand (Int Poly Poly) Int)
(declare-fun uintor (Int Poly Poly) Int)
(declare-fun uintshr (Int Poly Poly) Int)
(declare-fun uintshl (Int Poly Poly) Int)
(declare-fun uintnot (Int Poly) Int)
(declare-fun closure_req (Type Type Type Type Poly Poly) Bool)
(declare-fun closure_ens (Type Type Type Type Poly Poly Poly) Bool)
(set-info :comment ";; MODULE 'impl_u::l1'")
(set-info :comment ";; impl_u/l1.rs:430:21: 446:23 (#0)")
(set-info :comment ";; Fuel")
(declare-const fuel%vstd!std_specs.result.impl&%0.is_Ok. FuelId)
(declare-const fuel%vstd!std_specs.result.impl&%0.get_Ok_0. FuelId)
(declare-const fuel%vstd!std_specs.result.impl&%0.is_Err. FuelId)
(declare-const fuel%vstd!std_specs.result.impl&%0.get_Err_0. FuelId)
(declare-const fuel%vstd!map.impl&%0.new. FuelId)
(declare-const fuel%vstd!map.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!map.impl&%0.contains_pair. FuelId)
(declare-const fuel%vstd!map.impl&%0.union_prefer_right. FuelId)
(declare-const fuel%vstd!map.check_argument_is_map. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_index. FuelId)
(declare-const fuel%vstd!seq.impl&%0.spec_add. FuelId)
(declare-const fuel%vstd!seq_lib.impl&%0.contains. FuelId)
(declare-const fuel%vstd!seq_lib.impl&%0.to_set. FuelId)
(declare-const fuel%vstd!seq_lib.check_argument_is_seq. FuelId)
(declare-const fuel%vstd!set.impl&%0.choose. FuelId)
(declare-const fuel%vstd!set_lib.check_argument_is_set. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.inv. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.mappings_are_of_valid_size. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.mappings_are_aligned. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.mappings_dont_overlap. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.candidate_mapping_in_bounds. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.mappings_in_bounds. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.accepted_mapping. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.valid_mapping. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.map_frame. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.accepted_resolve. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.resolve. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.remove. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.accepted_unmap. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.unmap. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.ranges_disjoint. FuelId)
(declare-const fuel%main!impl_u.l0.impl&%0.mappings_disjoint. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.well_formed. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.entry_size. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.num_entries. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.empty. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.pages_match_entry_size. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.directories_are_in_next_layer. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.directories_obey_invariant. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.directories_match_arch. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.directories_are_nonempty. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.frames_aligned. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.inv. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.interp. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.upper_vaddr. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.index_for_vaddr. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.entry_base. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.next_entry_base. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.entry_bounds. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.interp_of_entry. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.interp_aux. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.resolve. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.update. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.accepted_mapping. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.new_empty_dir. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.map_frame. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.accepted_unmap. FuelId)
(declare-const fuel%main!impl_u.l1.impl&%0.unmap. FuelId)
(declare-const fuel%main!impl_u.l1.result_map_ok. FuelId)
(declare-const fuel%main!impl_u.l1.result_map. FuelId)
(declare-const fuel%main!impl_u.indexing.index_from_offset. FuelId)
(declare-const fuel%main!impl_u.indexing.index_from_base_and_addr. FuelId)
(declare-const fuel%main!impl_u.indexing.entry_base_from_index. FuelId)
(declare-const fuel%main!impl_u.indexing.next_entry_base_from_index. FuelId)
(declare-const fuel%main!impl_u.indexing.nat_mul. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.entry_size. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.num_entries. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.upper_vaddr. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.inv. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.entry_size_is_next_layer_size. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.contains_entry_size_at_index_atleast. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.contains_entry_size. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.index_for_vaddr. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.entry_base. FuelId)
(declare-const fuel%main!definitions_t.impl&%7.next_entry_base. FuelId)
(declare-const fuel%main!definitions_t.X86_NUM_LAYERS. FuelId)
(declare-const fuel%main!definitions_t.X86_NUM_ENTRIES. FuelId)
(declare-const fuel%main!definitions_t.X86_MAX_ENTRY_SIZE. FuelId)
(declare-const fuel%main!definitions_t.aligned. FuelId)
(declare-const fuel%main!definitions_t.between. FuelId)
(declare-const fuel%main!definitions_t.new_seq. FuelId)
(declare-const fuel%main!definitions_t.overlap. FuelId)
(assert (distinct fuel%vstd!std_specs.result.impl&%0.is_Ok. fuel%vstd!std_specs.result.impl&%0.get_Ok_0. fuel%vstd!std_specs.result.impl&%0.is_Err. fuel%vstd!std_specs.result.impl&%0.get_Err_0. fuel%vstd!map.impl&%0.new. fuel%vstd!map.impl&%0.spec_index. fuel%vstd!map.impl&%0.contains_pair. fuel%vstd!map.impl&%0.union_prefer_right. fuel%vstd!map.check_argument_is_map. fuel%vstd!seq.impl&%0.spec_index. fuel%vstd!seq.impl&%0.spec_add. fuel%vstd!seq_lib.impl&%0.contains. fuel%vstd!seq_lib.impl&%0.to_set. fuel%vstd!seq_lib.check_argument_is_seq. fuel%vstd!set.impl&%0.choose. fuel%vstd!set_lib.check_argument_is_set. fuel%main!impl_u.l0.impl&%0.inv. fuel%main!impl_u.l0.impl&%0.mappings_are_of_valid_size. fuel%main!impl_u.l0.impl&%0.mappings_are_aligned. fuel%main!impl_u.l0.impl&%0.mappings_dont_overlap. fuel%main!impl_u.l0.impl&%0.candidate_mapping_in_bounds. fuel%main!impl_u.l0.impl&%0.mappings_in_bounds. fuel%main!impl_u.l0.impl&%0.accepted_mapping. fuel%main!impl_u.l0.impl&%0.valid_mapping. fuel%main!impl_u.l0.impl&%0.map_frame. fuel%main!impl_u.l0.impl&%0.accepted_resolve. fuel%main!impl_u.l0.impl&%0.resolve. fuel%main!impl_u.l0.impl&%0.remove. fuel%main!impl_u.l0.impl&%0.accepted_unmap. fuel%main!impl_u.l0.impl&%0.unmap. fuel%main!impl_u.l0.impl&%0.ranges_disjoint. fuel%main!impl_u.l0.impl&%0.mappings_disjoint. fuel%main!impl_u.l1.impl&%0.well_formed. fuel%main!impl_u.l1.impl&%0.entry_size. fuel%main!impl_u.l1.impl&%0.num_entries. fuel%main!impl_u.l1.impl&%0.empty. fuel%main!impl_u.l1.impl&%0.pages_match_entry_size. fuel%main!impl_u.l1.impl&%0.directories_are_in_next_layer. fuel%main!impl_u.l1.impl&%0.directories_obey_invariant. fuel%main!impl_u.l1.impl&%0.directories_match_arch. fuel%main!impl_u.l1.impl&%0.directories_are_nonempty. fuel%main!impl_u.l1.impl&%0.frames_aligned. fuel%main!impl_u.l1.impl&%0.inv. fuel%main!impl_u.l1.impl&%0.interp. fuel%main!impl_u.l1.impl&%0.upper_vaddr. fuel%main!impl_u.l1.impl&%0.index_for_vaddr. fuel%main!impl_u.l1.impl&%0.entry_base. fuel%main!impl_u.l1.impl&%0.next_entry_base. fuel%main!impl_u.l1.impl&%0.entry_bounds. fuel%main!impl_u.l1.impl&%0.interp_of_entry. fuel%main!impl_u.l1.impl&%0.interp_aux. fuel%main!impl_u.l1.impl&%0.resolve. fuel%main!impl_u.l1.impl&%0.update. fuel%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds. fuel%main!impl_u.l1.impl&%0.accepted_mapping. fuel%main!impl_u.l1.impl&%0.new_empty_dir. fuel%main!impl_u.l1.impl&%0.map_frame. fuel%main!impl_u.l1.impl&%0.accepted_unmap. fuel%main!impl_u.l1.impl&%0.unmap. fuel%main!impl_u.l1.result_map_ok. fuel%main!impl_u.l1.result_map. fuel%main!impl_u.indexing.index_from_offset. fuel%main!impl_u.indexing.index_from_base_and_addr. fuel%main!impl_u.indexing.entry_base_from_index. fuel%main!impl_u.indexing.next_entry_base_from_index. fuel%main!impl_u.indexing.nat_mul. fuel%main!definitions_t.impl&%7.entry_size. fuel%main!definitions_t.impl&%7.num_entries. fuel%main!definitions_t.impl&%7.upper_vaddr. fuel%main!definitions_t.impl&%7.inv. fuel%main!definitions_t.impl&%7.entry_size_is_next_layer_size. fuel%main!definitions_t.impl&%7.contains_entry_size_at_index_atleast. fuel%main!definitions_t.impl&%7.contains_entry_size. fuel%main!definitions_t.impl&%7.index_for_vaddr. fuel%main!definitions_t.impl&%7.entry_base. fuel%main!definitions_t.impl&%7.next_entry_base. fuel%main!definitions_t.X86_NUM_LAYERS. fuel%main!definitions_t.X86_NUM_ENTRIES. fuel%main!definitions_t.X86_MAX_ENTRY_SIZE. fuel%main!definitions_t.aligned. fuel%main!definitions_t.between. fuel%main!definitions_t.new_seq. fuel%main!definitions_t.overlap.))
(set-info :comment ";; Datatypes")
(declare-sort vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. 0)
(declare-sort vstd!seq.Seq<main!definitions_t.ArchLayer.>. 0)
(declare-sort vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. 0)
(declare-sort vstd!set.Set<nat.>. 0)
(declare-datatypes ((core!result.Result. 0) (main!impl_u.l0.PageTableContents. 0) (main!impl_u.l1.Directory. 0) (main!impl_u.l1.NodeEntry. 0) (main!definitions_t.MemRegion. 0) (main!definitions_t.Flags. 0) (main!definitions_t.PageTableEntry. 0) (main!definitions_t.ArchLayer. 0) (main!definitions_t.Arch. 0) (tuple%0. 0) (tuple%2. 0)) (((core!result.Result./Ok (core!result.Result./Ok/?_0 Poly)) (core!result.Result./Err (core!result.Result./Err/?_0 Poly))) ((main!impl_u.l0.PageTableContents./PageTableContents (main!impl_u.l0.PageTableContents./PageTableContents/?map vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.) (main!impl_u.l0.PageTableContents./PageTableContents/?arch main!definitions_t.Arch.) (main!impl_u.l0.PageTableContents./PageTableContents/?lower Int) (main!impl_u.l0.PageTableContents./PageTableContents/?upper Int))) ((main!impl_u.l1.Directory./Directory (main!impl_u.l1.Directory./Directory/?entries vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.) (main!impl_u.l1.Directory./Directory/?layer Int) (main!impl_u.l1.Directory./Directory/?base_vaddr Int) (main!impl_u.l1.Directory./Directory/?arch main!definitions_t.Arch.))) ((main!impl_u.l1.NodeEntry./Directory (main!impl_u.l1.NodeEntry./Directory/?_0 main!impl_u.l1.Directory.)) (main!impl_u.l1.NodeEntry./Page (main!impl_u.l1.NodeEntry./Page/?_0 main!definitions_t.PageTableEntry.)) (main!impl_u.l1.NodeEntry./Empty )) ((main!definitions_t.MemRegion./MemRegion (main!definitions_t.MemRegion./MemRegion/?base Int) (main!definitions_t.MemRegion./MemRegion/?size Int))) ((main!definitions_t.Flags./Flags (main!definitions_t.Flags./Flags/?is_writable Bool) (main!definitions_t.Flags./Flags/?is_supervisor Bool) (main!definitions_t.Flags./Flags/?disable_execute Bool))) ((main!definitions_t.PageTableEntry./PageTableEntry (main!definitions_t.PageTableEntry./PageTableEntry/?frame main!definitions_t.MemRegion.) (main!definitions_t.PageTableEntry./PageTableEntry/?flags main!definitions_t.Flags.))) ((main!definitions_t.ArchLayer./ArchLayer (main!definitions_t.ArchLayer./ArchLayer/?entry_size Int) (main!definitions_t.ArchLayer./ArchLayer/?num_entries Int))) ((main!definitions_t.Arch./Arch (main!definitions_t.Arch./Arch/?layers vstd!seq.Seq<main!definitions_t.ArchLayer.>.))) ((tuple%0./tuple%0 )) ((tuple%2./tuple%2 (tuple%2./tuple%2/?field%0 Poly) (tuple%2./tuple%2/?field%1 Poly)))))
(declare-fun core!result.Result./Ok/_0 (core!result.Result.) Poly)
(declare-fun core!result.Result./Err/_0 (core!result.Result.) Poly)
(declare-fun main!impl_u.l0.PageTableContents./PageTableContents/map (main!impl_u.l0.PageTableContents.) vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.)
(declare-fun main!impl_u.l0.PageTableContents./PageTableContents/arch (main!impl_u.l0.PageTableContents.) main!definitions_t.Arch.)
(declare-fun main!impl_u.l0.PageTableContents./PageTableContents/lower (main!impl_u.l0.PageTableContents.) Int)
(declare-fun main!impl_u.l0.PageTableContents./PageTableContents/upper (main!impl_u.l0.PageTableContents.) Int)
(declare-fun main!impl_u.l1.Directory./Directory/entries (main!impl_u.l1.Directory.) vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.)
(declare-fun main!impl_u.l1.Directory./Directory/layer (main!impl_u.l1.Directory.) Int)
(declare-fun main!impl_u.l1.Directory./Directory/base_vaddr (main!impl_u.l1.Directory.) Int)
(declare-fun main!impl_u.l1.Directory./Directory/arch (main!impl_u.l1.Directory.) main!definitions_t.Arch.)
(declare-fun main!impl_u.l1.NodeEntry./Directory/_0 (main!impl_u.l1.NodeEntry.) main!impl_u.l1.Directory.)
(declare-fun main!impl_u.l1.NodeEntry./Page/_0 (main!impl_u.l1.NodeEntry.) main!definitions_t.PageTableEntry.)
(declare-fun main!definitions_t.MemRegion./MemRegion/base (main!definitions_t.MemRegion.) Int)
(declare-fun main!definitions_t.MemRegion./MemRegion/size (main!definitions_t.MemRegion.) Int)
(declare-fun main!definitions_t.Flags./Flags/is_writable (main!definitions_t.Flags.) Bool)
(declare-fun main!definitions_t.Flags./Flags/is_supervisor (main!definitions_t.Flags.) Bool)
(declare-fun main!definitions_t.Flags./Flags/disable_execute (main!definitions_t.Flags.) Bool)
(declare-fun main!definitions_t.PageTableEntry./PageTableEntry/frame (main!definitions_t.PageTableEntry.) main!definitions_t.MemRegion.)
(declare-fun main!definitions_t.PageTableEntry./PageTableEntry/flags (main!definitions_t.PageTableEntry.) main!definitions_t.Flags.)
(declare-fun main!definitions_t.ArchLayer./ArchLayer/entry_size (main!definitions_t.ArchLayer.) Int)
(declare-fun main!definitions_t.ArchLayer./ArchLayer/num_entries (main!definitions_t.ArchLayer.) Int)
(declare-fun main!definitions_t.Arch./Arch/layers (main!definitions_t.Arch.) vstd!seq.Seq<main!definitions_t.ArchLayer.>.)
(declare-fun tuple%2./tuple%2/field%0 (tuple%2.) Poly)
(declare-fun tuple%2./tuple%2/field%1 (tuple%2.) Poly)
(declare-fun TYPE%fun%1. (Type Type) Type)
(declare-fun TYPE%core!result.Result. (Type Type) Type)
(declare-fun TYPE%vstd!map.Map. (Type Type) Type)
(declare-fun TYPE%vstd!seq.Seq. (Type) Type)
(declare-fun TYPE%vstd!set.Set. (Type) Type)
(declare-const TYPE%main!impl_u.l0.PageTableContents. Type)
(declare-const TYPE%main!impl_u.l1.Directory. Type)
(declare-const TYPE%main!impl_u.l1.NodeEntry. Type)
(declare-const TYPE%main!definitions_t.MemRegion. Type)
(declare-const TYPE%main!definitions_t.Flags. Type)
(declare-const TYPE%main!definitions_t.PageTableEntry. Type)
(declare-const TYPE%main!definitions_t.ArchLayer. Type)
(declare-const TYPE%main!definitions_t.Arch. Type)
(declare-const TYPE%tuple%0. Type)
(declare-fun TYPE%tuple%2. (Type Type) Type)
(declare-fun Poly%fun%1. (%%Function%%) Poly)
(declare-fun %Poly%fun%1. (Poly) %%Function%%)
(declare-fun Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.) Poly)
(declare-fun %Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (Poly) vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.)
(declare-fun Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (vstd!seq.Seq<main!definitions_t.ArchLayer.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (Poly) vstd!seq.Seq<main!definitions_t.ArchLayer.>.)
(declare-fun Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.) Poly)
(declare-fun %Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (Poly) vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.)
(declare-fun Poly%vstd!set.Set<nat.>. (vstd!set.Set<nat.>.) Poly)
(declare-fun %Poly%vstd!set.Set<nat.>. (Poly) vstd!set.Set<nat.>.)
(declare-fun Poly%core!result.Result. (core!result.Result.) Poly)
(declare-fun %Poly%core!result.Result. (Poly) core!result.Result.)
(declare-fun Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.PageTableContents.) Poly)
(declare-fun %Poly%main!impl_u.l0.PageTableContents. (Poly) main!impl_u.l0.PageTableContents.)
(declare-fun Poly%main!impl_u.l1.Directory. (main!impl_u.l1.Directory.) Poly)
(declare-fun %Poly%main!impl_u.l1.Directory. (Poly) main!impl_u.l1.Directory.)
(declare-fun Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry.) Poly)
(declare-fun %Poly%main!impl_u.l1.NodeEntry. (Poly) main!impl_u.l1.NodeEntry.)
(declare-fun Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion.) Poly)
(declare-fun %Poly%main!definitions_t.MemRegion. (Poly) main!definitions_t.MemRegion.)
(declare-fun Poly%main!definitions_t.Flags. (main!definitions_t.Flags.) Poly)
(declare-fun %Poly%main!definitions_t.Flags. (Poly) main!definitions_t.Flags.)
(declare-fun Poly%main!definitions_t.PageTableEntry. (main!definitions_t.PageTableEntry.) Poly)
(declare-fun %Poly%main!definitions_t.PageTableEntry. (Poly) main!definitions_t.PageTableEntry.)
(declare-fun Poly%main!definitions_t.ArchLayer. (main!definitions_t.ArchLayer.) Poly)
(declare-fun %Poly%main!definitions_t.ArchLayer. (Poly) main!definitions_t.ArchLayer.)
(declare-fun Poly%main!definitions_t.Arch. (main!definitions_t.Arch.) Poly)
(declare-fun %Poly%main!definitions_t.Arch. (Poly) main!definitions_t.Arch.)
(declare-fun Poly%tuple%0. (tuple%0.) Poly)
(declare-fun %Poly%tuple%0. (Poly) tuple%0.)
(declare-fun Poly%tuple%2. (tuple%2.) Poly)
(declare-fun %Poly%tuple%2. (Poly) tuple%2.)
(assert (forall ((x@ %%Function%%)) (! (= x@ (%Poly%fun%1. (Poly%fun%1. x@))) :pattern ((Poly%fun%1. x@)) :qid internal_crate__fun__1_box_axiom_definition :skolemid skolem_internal_crate__fun__1_box_axiom_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%fun%1. T%0& T%1&)) (= x@ (Poly%fun%1. (%Poly%fun%1. x@)))) :pattern ((has_type x@ (TYPE%fun%1. T%0& T%1&))) :qid internal_crate__fun__1_unbox_axiom_definition :skolemid skolem_internal_crate__fun__1_unbox_axiom_definition)))
(declare-fun %%apply%%0 (%%Function%% Poly) Poly)
(assert (forall ((T%0& Type) (T%1& Type) (x@ %%Function%%)) (! (=> (forall ((T%0@ Poly)) (! (=> (has_type T%0@ T%0&) (has_type (%%apply%%0 x@ T%0@) T%1&)) :pattern ((has_type (%%apply%%0 x@ T%0@) T%1&)) :qid internal_crate__fun__1_constructor_inner_definition :skolemid skolem_internal_crate__fun__1_constructor_inner_definition)) (has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0& T%1&))) :pattern ((has_type (Poly%fun%1. (mk_fun x@)) (TYPE%fun%1. T%0& T%1&))) :qid internal_crate__fun__1_constructor_definition :skolemid skolem_internal_crate__fun__1_constructor_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (T%0@ Poly) (x@ %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&)) (has_type T%0@ T%0&)) (has_type (%%apply%%0 x@ T%0@) T%1&)) :pattern ((%%apply%%0 x@ T%0@) (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&))) :qid internal_crate__fun__1_apply_definition :skolemid skolem_internal_crate__fun__1_apply_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (T%0@ Poly) (x@ %%Function%%)) (! (=> (and (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&)) (has_type T%0@ T%0&)) (height_lt (height (%%apply%%0 x@ T%0@)) (height (fun_from_recursive_field (Poly%fun%1. (mk_fun x@)))))) :pattern ((height (%%apply%%0 x@ T%0@)) (has_type (Poly%fun%1. x@) (TYPE%fun%1. T%0& T%1&))) :qid internal_crate__fun__1_height_apply_definition :skolemid skolem_internal_crate__fun__1_height_apply_definition)))
(assert (forall ((T%0& Type) (T%0&. Type) (T%1& Type) (T%1&. Type) (deep@ Bool) (x@ Poly) (y@ Poly)) (! (=> (and (has_type x@ (TYPE%fun%1. T%0& T%1&)) (has_type y@ (TYPE%fun%1. T%0& T%1&)) (forall ((T%0@ Poly)) (! (=> (has_type T%0@ T%0&) (ext_eq deep@ T%1& T%1&. (%%apply%%0 (%Poly%fun%1. x@) T%0@) (%%apply%%0 (%Poly%fun%1. y@) T%0@))) :pattern ((ext_eq deep@ T%1& T%1&. (%%apply%%0 (%Poly%fun%1. x@) T%0@) (%%apply%%0 (%Poly%fun%1. y@) T%0@))) :qid internal_crate__fun__1_inner_ext_equal_definition :skolemid skolem_internal_crate__fun__1_inner_ext_equal_definition))) (ext_eq deep@ (TYPE%fun%1. T%0& T%1&) (TYPE%fun%1. T%0&. T%1&.) x@ y@)) :pattern ((ext_eq deep@ (TYPE%fun%1. T%0& T%1&) (TYPE%fun%1. T%0&. T%1&.) x@ y@)) :qid internal_crate__fun__1_ext_equal_definition :skolemid skolem_internal_crate__fun__1_ext_equal_definition)))
(assert (forall ((x@ vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.)) (! (= x@ (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. x@))) :pattern ((Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. x@)) :qid internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_box_axiom_definition :skolemid skolem_internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (= x@ (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.))) :qid internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_unbox_axiom_definition :skolemid skolem_internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.)) (! (has_type (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. x@) (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) :pattern ((has_type (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. x@) (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.))) :qid internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_has_type_always_definition :skolemid skolem_internal_vstd__map__Map<nat./main!definitions_t.PageTableEntry.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<main!definitions_t.ArchLayer.>.)) (! (= x@ (%Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. x@))) :pattern ((Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. x@)) :qid internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. TYPE%main!definitions_t.ArchLayer.)) (= x@ (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (%Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. TYPE%main!definitions_t.ArchLayer.))) :qid internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<main!definitions_t.ArchLayer.>.)) (! (has_type (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. x@) (TYPE%vstd!seq.Seq. TYPE%main!definitions_t.ArchLayer.)) :pattern ((has_type (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. x@) (TYPE%vstd!seq.Seq. TYPE%main!definitions_t.ArchLayer.))) :qid internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<main!definitions_t.ArchLayer.>_has_type_always_definition)))
(assert (forall ((x@ vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.)) (! (= x@ (%Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. x@))) :pattern ((Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. x@)) :qid internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_box_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!seq.Seq. TYPE%main!impl_u.l1.NodeEntry.)) (= x@ (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (%Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!seq.Seq. TYPE%main!impl_u.l1.NodeEntry.))) :qid internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_unbox_axiom_definition :skolemid skolem_internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.)) (! (has_type (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. x@) (TYPE%vstd!seq.Seq. TYPE%main!impl_u.l1.NodeEntry.)) :pattern ((has_type (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. x@) (TYPE%vstd!seq.Seq. TYPE%main!impl_u.l1.NodeEntry.))) :qid internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_has_type_always_definition :skolemid skolem_internal_vstd__seq__Seq<main!impl_u.l1.NodeEntry.>_has_type_always_definition)))
(assert (forall ((x@ vstd!set.Set<nat.>.)) (! (= x@ (%Poly%vstd!set.Set<nat.>. (Poly%vstd!set.Set<nat.>. x@))) :pattern ((Poly%vstd!set.Set<nat.>. x@)) :qid internal_vstd__set__Set<nat.>_box_axiom_definition :skolemid skolem_internal_vstd__set__Set<nat.>_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ (TYPE%vstd!set.Set. NAT)) (= x@ (Poly%vstd!set.Set<nat.>. (%Poly%vstd!set.Set<nat.>. x@)))) :pattern ((has_type x@ (TYPE%vstd!set.Set. NAT))) :qid internal_vstd__set__Set<nat.>_unbox_axiom_definition :skolemid skolem_internal_vstd__set__Set<nat.>_unbox_axiom_definition)))
(assert (forall ((x@ vstd!set.Set<nat.>.)) (! (has_type (Poly%vstd!set.Set<nat.>. x@) (TYPE%vstd!set.Set. NAT)) :pattern ((has_type (Poly%vstd!set.Set<nat.>. x@) (TYPE%vstd!set.Set. NAT))) :qid internal_vstd__set__Set<nat.>_has_type_always_definition :skolemid skolem_internal_vstd__set__Set<nat.>_has_type_always_definition)))
(assert (forall ((x@ core!result.Result.)) (! (= x@ (%Poly%core!result.Result. (Poly%core!result.Result. x@))) :pattern ((Poly%core!result.Result. x@)) :qid internal_core__result__Result_box_axiom_definition :skolemid skolem_internal_core__result__Result_box_axiom_definition)))
(assert (forall ((T& Type) (E& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%core!result.Result. T& E&)) (= x@ (Poly%core!result.Result. (%Poly%core!result.Result. x@)))) :pattern ((has_type x@ (TYPE%core!result.Result. T& E&))) :qid internal_core__result__Result_unbox_axiom_definition :skolemid skolem_internal_core__result__Result_unbox_axiom_definition)))
(assert (forall ((T& Type) (E& Type) (_0@ Poly)) (! (=> (has_type _0@ T&) (has_type (Poly%core!result.Result. (core!result.Result./Ok _0@)) (TYPE%core!result.Result. T& E&))) :pattern ((has_type (Poly%core!result.Result. (core!result.Result./Ok _0@)) (TYPE%core!result.Result. T& E&))) :qid internal_core!result.Result./Ok_constructor_definition :skolemid skolem_internal_core!result.Result./Ok_constructor_definition)))
(assert (forall ((x@ core!result.Result.)) (! (= (core!result.Result./Ok/_0 x@) (core!result.Result./Ok/?_0 x@)) :pattern ((core!result.Result./Ok/_0 x@)) :qid internal_core!result.Result./Ok/_0_accessor_definition :skolemid skolem_internal_core!result.Result./Ok/_0_accessor_definition)))
(assert (forall ((T& Type) (E& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%core!result.Result. T& E&)) (has_type (core!result.Result./Ok/_0 (%Poly%core!result.Result. x@)) T&)) :pattern ((core!result.Result./Ok/_0 (%Poly%core!result.Result. x@)) (has_type x@ (TYPE%core!result.Result. T& E&))) :qid internal_core!result.Result./Ok/_0_invariant_definition :skolemid skolem_internal_core!result.Result./Ok/_0_invariant_definition)))
(assert (forall ((T& Type) (E& Type) (_0@ Poly)) (! (=> (has_type _0@ E&) (has_type (Poly%core!result.Result. (core!result.Result./Err _0@)) (TYPE%core!result.Result. T& E&))) :pattern ((has_type (Poly%core!result.Result. (core!result.Result./Err _0@)) (TYPE%core!result.Result. T& E&))) :qid internal_core!result.Result./Err_constructor_definition :skolemid skolem_internal_core!result.Result./Err_constructor_definition)))
(assert (forall ((x@ core!result.Result.)) (! (= (core!result.Result./Err/_0 x@) (core!result.Result./Err/?_0 x@)) :pattern ((core!result.Result./Err/_0 x@)) :qid internal_core!result.Result./Err/_0_accessor_definition :skolemid skolem_internal_core!result.Result./Err/_0_accessor_definition)))
(assert (forall ((T& Type) (E& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%core!result.Result. T& E&)) (has_type (core!result.Result./Err/_0 (%Poly%core!result.Result. x@)) E&)) :pattern ((core!result.Result./Err/_0 (%Poly%core!result.Result. x@)) (has_type x@ (TYPE%core!result.Result. T& E&))) :qid internal_core!result.Result./Err/_0_invariant_definition :skolemid skolem_internal_core!result.Result./Err/_0_invariant_definition)))
(assert (forall ((x core!result.Result.)) (! (=> ((_ is core!result.Result./Ok) x) (height_lt (height (core!result.Result./Ok/_0 x)) (height (Poly%core!result.Result. x)))) :pattern ((height (core!result.Result./Ok/_0 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x core!result.Result.)) (! (=> ((_ is core!result.Result./Err) x) (height_lt (height (core!result.Result./Err/_0 x)) (height (Poly%core!result.Result. x)))) :pattern ((height (core!result.Result./Err/_0 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x@ main!impl_u.l0.PageTableContents.)) (! (= x@ (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. x@))) :pattern ((Poly%main!impl_u.l0.PageTableContents. x@)) :qid internal_main__impl_u__l0__PageTableContents_box_axiom_definition :skolemid skolem_internal_main__impl_u__l0__PageTableContents_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l0.PageTableContents.) (= x@ (Poly%main!impl_u.l0.PageTableContents. (%Poly%main!impl_u.l0.PageTableContents. x@)))) :pattern ((has_type x@ TYPE%main!impl_u.l0.PageTableContents.)) :qid internal_main__impl_u__l0__PageTableContents_unbox_axiom_definition :skolemid skolem_internal_main__impl_u__l0__PageTableContents_unbox_axiom_definition)))
(assert (forall ((map@ vstd!map.Map<nat./main!definitions_t.PageTableEntry.>.) (arch@ main!definitions_t.Arch.) (lower@ Int) (upper@ Int)) (! (=> (and (<= 0 lower@) (<= 0 upper@)) (has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.PageTableContents./PageTableContents map@ arch@ lower@ upper@)) TYPE%main!impl_u.l0.PageTableContents.)) :pattern ((has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.PageTableContents./PageTableContents map@ arch@ lower@ upper@)) TYPE%main!impl_u.l0.PageTableContents.)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents_constructor_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents_constructor_definition)))
(assert (forall ((x@ main!impl_u.l0.PageTableContents.)) (! (= (main!impl_u.l0.PageTableContents./PageTableContents/map x@) (main!impl_u.l0.PageTableContents./PageTableContents/?map x@)) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/map x@)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/map_accessor_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/map_accessor_definition)))
(assert (forall ((x@ main!impl_u.l0.PageTableContents.)) (! (= (main!impl_u.l0.PageTableContents./PageTableContents/arch x@) (main!impl_u.l0.PageTableContents./PageTableContents/?arch x@)) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/arch x@)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/arch_accessor_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/arch_accessor_definition)))
(assert (forall ((x@ main!impl_u.l0.PageTableContents.)) (! (= (main!impl_u.l0.PageTableContents./PageTableContents/lower x@) (main!impl_u.l0.PageTableContents./PageTableContents/?lower x@)) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/lower x@)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/lower_accessor_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/lower_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l0.PageTableContents.) (<= 0 (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. x@)))) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. x@)) (has_type x@ TYPE%main!impl_u.l0.PageTableContents.)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/lower_invariant_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/lower_invariant_definition)))
(assert (forall ((x@ main!impl_u.l0.PageTableContents.)) (! (= (main!impl_u.l0.PageTableContents./PageTableContents/upper x@) (main!impl_u.l0.PageTableContents./PageTableContents/?upper x@)) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/upper x@)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/upper_accessor_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/upper_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l0.PageTableContents.) (<= 0 (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. x@)))) :pattern ((main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. x@)) (has_type x@ TYPE%main!impl_u.l0.PageTableContents.)) :qid internal_main!impl_u.l0.PageTableContents./PageTableContents/upper_invariant_definition :skolemid skolem_internal_main!impl_u.l0.PageTableContents./PageTableContents/upper_invariant_definition)))
(assert (forall ((x@ main!impl_u.l1.Directory.)) (! (= x@ (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. x@))) :pattern ((Poly%main!impl_u.l1.Directory. x@)) :qid internal_main__impl_u__l1__Directory_box_axiom_definition :skolemid skolem_internal_main__impl_u__l1__Directory_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.Directory.) (= x@ (Poly%main!impl_u.l1.Directory. (%Poly%main!impl_u.l1.Directory. x@)))) :pattern ((has_type x@ TYPE%main!impl_u.l1.Directory.)) :qid internal_main__impl_u__l1__Directory_unbox_axiom_definition :skolemid skolem_internal_main__impl_u__l1__Directory_unbox_axiom_definition)))
(assert (forall ((entries@ vstd!seq.Seq<main!impl_u.l1.NodeEntry.>.) (layer@ Int) (base_vaddr@ Int) (arch@ main!definitions_t.Arch.)) (! (=> (and (<= 0 layer@) (<= 0 base_vaddr@)) (has_type (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.Directory./Directory entries@ layer@ base_vaddr@ arch@)) TYPE%main!impl_u.l1.Directory.)) :pattern ((has_type (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.Directory./Directory entries@ layer@ base_vaddr@ arch@)) TYPE%main!impl_u.l1.Directory.)) :qid internal_main!impl_u.l1.Directory./Directory_constructor_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory_constructor_definition)))
(assert (forall ((x@ main!impl_u.l1.Directory.)) (! (= (main!impl_u.l1.Directory./Directory/entries x@) (main!impl_u.l1.Directory./Directory/?entries x@)) :pattern ((main!impl_u.l1.Directory./Directory/entries x@)) :qid internal_main!impl_u.l1.Directory./Directory/entries_accessor_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/entries_accessor_definition)))
(assert (forall ((x@ main!impl_u.l1.Directory.)) (! (= (main!impl_u.l1.Directory./Directory/layer x@) (main!impl_u.l1.Directory./Directory/?layer x@)) :pattern ((main!impl_u.l1.Directory./Directory/layer x@)) :qid internal_main!impl_u.l1.Directory./Directory/layer_accessor_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/layer_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.Directory.) (<= 0 (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. x@)))) :pattern ((main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. x@)) (has_type x@ TYPE%main!impl_u.l1.Directory.)) :qid internal_main!impl_u.l1.Directory./Directory/layer_invariant_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/layer_invariant_definition)))
(assert (forall ((x@ main!impl_u.l1.Directory.)) (! (= (main!impl_u.l1.Directory./Directory/base_vaddr x@) (main!impl_u.l1.Directory./Directory/?base_vaddr x@)) :pattern ((main!impl_u.l1.Directory./Directory/base_vaddr x@)) :qid internal_main!impl_u.l1.Directory./Directory/base_vaddr_accessor_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/base_vaddr_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.Directory.) (<= 0 (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. x@)))) :pattern ((main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. x@)) (has_type x@ TYPE%main!impl_u.l1.Directory.)) :qid internal_main!impl_u.l1.Directory./Directory/base_vaddr_invariant_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/base_vaddr_invariant_definition)))
(assert (forall ((x@ main!impl_u.l1.Directory.)) (! (= (main!impl_u.l1.Directory./Directory/arch x@) (main!impl_u.l1.Directory./Directory/?arch x@)) :pattern ((main!impl_u.l1.Directory./Directory/arch x@)) :qid internal_main!impl_u.l1.Directory./Directory/arch_accessor_definition :skolemid skolem_internal_main!impl_u.l1.Directory./Directory/arch_accessor_definition)))
(assert (forall ((x main!impl_u.l1.Directory.)) (! (=> ((_ is main!impl_u.l1.Directory./Directory) x) (height_lt (height (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries x))) (height (Poly%main!impl_u.l1.Directory. x)))) :pattern ((height (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries x)))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x@ main!impl_u.l1.NodeEntry.)) (! (= x@ (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. x@))) :pattern ((Poly%main!impl_u.l1.NodeEntry. x@)) :qid internal_main__impl_u__l1__NodeEntry_box_axiom_definition :skolemid skolem_internal_main__impl_u__l1__NodeEntry_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.NodeEntry.) (= x@ (Poly%main!impl_u.l1.NodeEntry. (%Poly%main!impl_u.l1.NodeEntry. x@)))) :pattern ((has_type x@ TYPE%main!impl_u.l1.NodeEntry.)) :qid internal_main__impl_u__l1__NodeEntry_unbox_axiom_definition :skolemid skolem_internal_main__impl_u__l1__NodeEntry_unbox_axiom_definition)))
(assert (forall ((_0@ main!impl_u.l1.Directory.)) (! (=> (has_type (Poly%main!impl_u.l1.Directory. _0@) TYPE%main!impl_u.l1.Directory.) (has_type (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory _0@)) TYPE%main!impl_u.l1.NodeEntry.)) :pattern ((has_type (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory _0@)) TYPE%main!impl_u.l1.NodeEntry.)) :qid internal_main!impl_u.l1.NodeEntry./Directory_constructor_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Directory_constructor_definition)))
(assert (forall ((x@ main!impl_u.l1.NodeEntry.)) (! (= (main!impl_u.l1.NodeEntry./Directory/_0 x@) (main!impl_u.l1.NodeEntry./Directory/?_0 x@)) :pattern ((main!impl_u.l1.NodeEntry./Directory/_0 x@)) :qid internal_main!impl_u.l1.NodeEntry./Directory/_0_accessor_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Directory/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.NodeEntry.) (has_type (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. x@))) TYPE%main!impl_u.l1.Directory.)) :pattern ((main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. x@)) (has_type x@ TYPE%main!impl_u.l1.NodeEntry.)) :qid internal_main!impl_u.l1.NodeEntry./Directory/_0_invariant_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Directory/_0_invariant_definition)))
(assert (forall ((_0@ main!definitions_t.PageTableEntry.)) (! (=> (has_type (Poly%main!definitions_t.PageTableEntry. _0@) TYPE%main!definitions_t.PageTableEntry.) (has_type (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Page _0@)) TYPE%main!impl_u.l1.NodeEntry.)) :pattern ((has_type (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Page _0@)) TYPE%main!impl_u.l1.NodeEntry.)) :qid internal_main!impl_u.l1.NodeEntry./Page_constructor_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Page_constructor_definition)))
(assert (forall ((x@ main!impl_u.l1.NodeEntry.)) (! (= (main!impl_u.l1.NodeEntry./Page/_0 x@) (main!impl_u.l1.NodeEntry./Page/?_0 x@)) :pattern ((main!impl_u.l1.NodeEntry./Page/_0 x@)) :qid internal_main!impl_u.l1.NodeEntry./Page/_0_accessor_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Page/_0_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!impl_u.l1.NodeEntry.) (has_type (Poly%main!definitions_t.PageTableEntry. (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. x@))) TYPE%main!definitions_t.PageTableEntry.)) :pattern ((main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. x@)) (has_type x@ TYPE%main!impl_u.l1.NodeEntry.)) :qid internal_main!impl_u.l1.NodeEntry./Page/_0_invariant_definition :skolemid skolem_internal_main!impl_u.l1.NodeEntry./Page/_0_invariant_definition)))
(assert (has_type (Poly%main!impl_u.l1.NodeEntry. main!impl_u.l1.NodeEntry./Empty) TYPE%main!impl_u.l1.NodeEntry.))
(assert (forall ((x main!impl_u.l1.NodeEntry.)) (! (=> ((_ is main!impl_u.l1.NodeEntry./Directory) x) (height_lt (height (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 x))) (height (Poly%main!impl_u.l1.NodeEntry. x)))) :pattern ((height (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 x)))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x@ main!definitions_t.MemRegion.)) (! (= x@ (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. x@))) :pattern ((Poly%main!definitions_t.MemRegion. x@)) :qid internal_main__definitions_t__MemRegion_box_axiom_definition :skolemid skolem_internal_main__definitions_t__MemRegion_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.MemRegion.) (= x@ (Poly%main!definitions_t.MemRegion. (%Poly%main!definitions_t.MemRegion. x@)))) :pattern ((has_type x@ TYPE%main!definitions_t.MemRegion.)) :qid internal_main__definitions_t__MemRegion_unbox_axiom_definition :skolemid skolem_internal_main__definitions_t__MemRegion_unbox_axiom_definition)))
(assert (forall ((base@ Int) (size@ Int)) (! (=> (and (<= 0 base@) (<= 0 size@)) (has_type (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion base@ size@)) TYPE%main!definitions_t.MemRegion.)) :pattern ((has_type (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion base@ size@)) TYPE%main!definitions_t.MemRegion.)) :qid internal_main!definitions_t.MemRegion./MemRegion_constructor_definition :skolemid skolem_internal_main!definitions_t.MemRegion./MemRegion_constructor_definition)))
(assert (forall ((x@ main!definitions_t.MemRegion.)) (! (= (main!definitions_t.MemRegion./MemRegion/base x@) (main!definitions_t.MemRegion./MemRegion/?base x@)) :pattern ((main!definitions_t.MemRegion./MemRegion/base x@)) :qid internal_main!definitions_t.MemRegion./MemRegion/base_accessor_definition :skolemid skolem_internal_main!definitions_t.MemRegion./MemRegion/base_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.MemRegion.) (<= 0 (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. x@)))) :pattern ((main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. x@)) (has_type x@ TYPE%main!definitions_t.MemRegion.)) :qid internal_main!definitions_t.MemRegion./MemRegion/base_invariant_definition :skolemid skolem_internal_main!definitions_t.MemRegion./MemRegion/base_invariant_definition)))
(assert (forall ((x@ main!definitions_t.MemRegion.)) (! (= (main!definitions_t.MemRegion./MemRegion/size x@) (main!definitions_t.MemRegion./MemRegion/?size x@)) :pattern ((main!definitions_t.MemRegion./MemRegion/size x@)) :qid internal_main!definitions_t.MemRegion./MemRegion/size_accessor_definition :skolemid skolem_internal_main!definitions_t.MemRegion./MemRegion/size_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.MemRegion.) (<= 0 (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. x@)))) :pattern ((main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. x@)) (has_type x@ TYPE%main!definitions_t.MemRegion.)) :qid internal_main!definitions_t.MemRegion./MemRegion/size_invariant_definition :skolemid skolem_internal_main!definitions_t.MemRegion./MemRegion/size_invariant_definition)))
(assert (forall ((x@ main!definitions_t.Flags.)) (! (= x@ (%Poly%main!definitions_t.Flags. (Poly%main!definitions_t.Flags. x@))) :pattern ((Poly%main!definitions_t.Flags. x@)) :qid internal_main__definitions_t__Flags_box_axiom_definition :skolemid skolem_internal_main__definitions_t__Flags_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.Flags.) (= x@ (Poly%main!definitions_t.Flags. (%Poly%main!definitions_t.Flags. x@)))) :pattern ((has_type x@ TYPE%main!definitions_t.Flags.)) :qid internal_main__definitions_t__Flags_unbox_axiom_definition :skolemid skolem_internal_main__definitions_t__Flags_unbox_axiom_definition)))
(assert (forall ((x@ main!definitions_t.Flags.)) (! (= (main!definitions_t.Flags./Flags/is_writable x@) (main!definitions_t.Flags./Flags/?is_writable x@)) :pattern ((main!definitions_t.Flags./Flags/is_writable x@)) :qid internal_main!definitions_t.Flags./Flags/is_writable_accessor_definition :skolemid skolem_internal_main!definitions_t.Flags./Flags/is_writable_accessor_definition)))
(assert (forall ((x@ main!definitions_t.Flags.)) (! (= (main!definitions_t.Flags./Flags/is_supervisor x@) (main!definitions_t.Flags./Flags/?is_supervisor x@)) :pattern ((main!definitions_t.Flags./Flags/is_supervisor x@)) :qid internal_main!definitions_t.Flags./Flags/is_supervisor_accessor_definition :skolemid skolem_internal_main!definitions_t.Flags./Flags/is_supervisor_accessor_definition)))
(assert (forall ((x@ main!definitions_t.Flags.)) (! (= (main!definitions_t.Flags./Flags/disable_execute x@) (main!definitions_t.Flags./Flags/?disable_execute x@)) :pattern ((main!definitions_t.Flags./Flags/disable_execute x@)) :qid internal_main!definitions_t.Flags./Flags/disable_execute_accessor_definition :skolemid skolem_internal_main!definitions_t.Flags./Flags/disable_execute_accessor_definition)))
(assert (forall ((x@ main!definitions_t.Flags.)) (! (has_type (Poly%main!definitions_t.Flags. x@) TYPE%main!definitions_t.Flags.) :pattern ((has_type (Poly%main!definitions_t.Flags. x@) TYPE%main!definitions_t.Flags.)) :qid internal_main__definitions_t__Flags_has_type_always_definition :skolemid skolem_internal_main__definitions_t__Flags_has_type_always_definition)))
(assert (forall ((x@ main!definitions_t.PageTableEntry.)) (! (= x@ (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. x@))) :pattern ((Poly%main!definitions_t.PageTableEntry. x@)) :qid internal_main__definitions_t__PageTableEntry_box_axiom_definition :skolemid skolem_internal_main__definitions_t__PageTableEntry_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.PageTableEntry.) (= x@ (Poly%main!definitions_t.PageTableEntry. (%Poly%main!definitions_t.PageTableEntry. x@)))) :pattern ((has_type x@ TYPE%main!definitions_t.PageTableEntry.)) :qid internal_main__definitions_t__PageTableEntry_unbox_axiom_definition :skolemid skolem_internal_main__definitions_t__PageTableEntry_unbox_axiom_definition)))
(assert (forall ((frame@ main!definitions_t.MemRegion.) (flags@ main!definitions_t.Flags.)) (! (=> (has_type (Poly%main!definitions_t.MemRegion. frame@) TYPE%main!definitions_t.MemRegion.) (has_type (Poly%main!definitions_t.PageTableEntry. (main!definitions_t.PageTableEntry./PageTableEntry frame@ flags@)) TYPE%main!definitions_t.PageTableEntry.)) :pattern ((has_type (Poly%main!definitions_t.PageTableEntry. (main!definitions_t.PageTableEntry./PageTableEntry frame@ flags@)) TYPE%main!definitions_t.PageTableEntry.)) :qid internal_main!definitions_t.PageTableEntry./PageTableEntry_constructor_definition :skolemid skolem_internal_main!definitions_t.PageTableEntry./PageTableEntry_constructor_definition)))
(assert (forall ((x@ main!definitions_t.PageTableEntry.)) (! (= (main!definitions_t.PageTableEntry./PageTableEntry/frame x@) (main!definitions_t.PageTableEntry./PageTableEntry/?frame x@)) :pattern ((main!definitions_t.PageTableEntry./PageTableEntry/frame x@)) :qid internal_main!definitions_t.PageTableEntry./PageTableEntry/frame_accessor_definition :skolemid skolem_internal_main!definitions_t.PageTableEntry./PageTableEntry/frame_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.PageTableEntry.) (has_type (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. x@))) TYPE%main!definitions_t.MemRegion.)) :pattern ((main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. x@)) (has_type x@ TYPE%main!definitions_t.PageTableEntry.)) :qid internal_main!definitions_t.PageTableEntry./PageTableEntry/frame_invariant_definition :skolemid skolem_internal_main!definitions_t.PageTableEntry./PageTableEntry/frame_invariant_definition)))
(assert (forall ((x@ main!definitions_t.PageTableEntry.)) (! (= (main!definitions_t.PageTableEntry./PageTableEntry/flags x@) (main!definitions_t.PageTableEntry./PageTableEntry/?flags x@)) :pattern ((main!definitions_t.PageTableEntry./PageTableEntry/flags x@)) :qid internal_main!definitions_t.PageTableEntry./PageTableEntry/flags_accessor_definition :skolemid skolem_internal_main!definitions_t.PageTableEntry./PageTableEntry/flags_accessor_definition)))
(assert (forall ((x@ main!definitions_t.ArchLayer.)) (! (= x@ (%Poly%main!definitions_t.ArchLayer. (Poly%main!definitions_t.ArchLayer. x@))) :pattern ((Poly%main!definitions_t.ArchLayer. x@)) :qid internal_main__definitions_t__ArchLayer_box_axiom_definition :skolemid skolem_internal_main__definitions_t__ArchLayer_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.ArchLayer.) (= x@ (Poly%main!definitions_t.ArchLayer. (%Poly%main!definitions_t.ArchLayer. x@)))) :pattern ((has_type x@ TYPE%main!definitions_t.ArchLayer.)) :qid internal_main__definitions_t__ArchLayer_unbox_axiom_definition :skolemid skolem_internal_main__definitions_t__ArchLayer_unbox_axiom_definition)))
(assert (forall ((entry_size@ Int) (num_entries@ Int)) (! (=> (and (<= 0 entry_size@) (<= 0 num_entries@)) (has_type (Poly%main!definitions_t.ArchLayer. (main!definitions_t.ArchLayer./ArchLayer entry_size@ num_entries@)) TYPE%main!definitions_t.ArchLayer.)) :pattern ((has_type (Poly%main!definitions_t.ArchLayer. (main!definitions_t.ArchLayer./ArchLayer entry_size@ num_entries@)) TYPE%main!definitions_t.ArchLayer.)) :qid internal_main!definitions_t.ArchLayer./ArchLayer_constructor_definition :skolemid skolem_internal_main!definitions_t.ArchLayer./ArchLayer_constructor_definition)))
(assert (forall ((x@ main!definitions_t.ArchLayer.)) (! (= (main!definitions_t.ArchLayer./ArchLayer/entry_size x@) (main!definitions_t.ArchLayer./ArchLayer/?entry_size x@)) :pattern ((main!definitions_t.ArchLayer./ArchLayer/entry_size x@)) :qid internal_main!definitions_t.ArchLayer./ArchLayer/entry_size_accessor_definition :skolemid skolem_internal_main!definitions_t.ArchLayer./ArchLayer/entry_size_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.ArchLayer.) (<= 0 (main!definitions_t.ArchLayer./ArchLayer/entry_size (%Poly%main!definitions_t.ArchLayer. x@)))) :pattern ((main!definitions_t.ArchLayer./ArchLayer/entry_size (%Poly%main!definitions_t.ArchLayer. x@)) (has_type x@ TYPE%main!definitions_t.ArchLayer.)) :qid internal_main!definitions_t.ArchLayer./ArchLayer/entry_size_invariant_definition :skolemid skolem_internal_main!definitions_t.ArchLayer./ArchLayer/entry_size_invariant_definition)))
(assert (forall ((x@ main!definitions_t.ArchLayer.)) (! (= (main!definitions_t.ArchLayer./ArchLayer/num_entries x@) (main!definitions_t.ArchLayer./ArchLayer/?num_entries x@)) :pattern ((main!definitions_t.ArchLayer./ArchLayer/num_entries x@)) :qid internal_main!definitions_t.ArchLayer./ArchLayer/num_entries_accessor_definition :skolemid skolem_internal_main!definitions_t.ArchLayer./ArchLayer/num_entries_accessor_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.ArchLayer.) (<= 0 (main!definitions_t.ArchLayer./ArchLayer/num_entries (%Poly%main!definitions_t.ArchLayer. x@)))) :pattern ((main!definitions_t.ArchLayer./ArchLayer/num_entries (%Poly%main!definitions_t.ArchLayer. x@)) (has_type x@ TYPE%main!definitions_t.ArchLayer.)) :qid internal_main!definitions_t.ArchLayer./ArchLayer/num_entries_invariant_definition :skolemid skolem_internal_main!definitions_t.ArchLayer./ArchLayer/num_entries_invariant_definition)))
(assert (forall ((x@ main!definitions_t.Arch.)) (! (= x@ (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. x@))) :pattern ((Poly%main!definitions_t.Arch. x@)) :qid internal_main__definitions_t__Arch_box_axiom_definition :skolemid skolem_internal_main__definitions_t__Arch_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%main!definitions_t.Arch.) (= x@ (Poly%main!definitions_t.Arch. (%Poly%main!definitions_t.Arch. x@)))) :pattern ((has_type x@ TYPE%main!definitions_t.Arch.)) :qid internal_main__definitions_t__Arch_unbox_axiom_definition :skolemid skolem_internal_main__definitions_t__Arch_unbox_axiom_definition)))
(assert (forall ((x@ main!definitions_t.Arch.)) (! (= (main!definitions_t.Arch./Arch/layers x@) (main!definitions_t.Arch./Arch/?layers x@)) :pattern ((main!definitions_t.Arch./Arch/layers x@)) :qid internal_main!definitions_t.Arch./Arch/layers_accessor_definition :skolemid skolem_internal_main!definitions_t.Arch./Arch/layers_accessor_definition)))
(assert (forall ((x@ main!definitions_t.Arch.)) (! (has_type (Poly%main!definitions_t.Arch. x@) TYPE%main!definitions_t.Arch.) :pattern ((has_type (Poly%main!definitions_t.Arch. x@) TYPE%main!definitions_t.Arch.)) :qid internal_main__definitions_t__Arch_has_type_always_definition :skolemid skolem_internal_main__definitions_t__Arch_has_type_always_definition)))
(assert (forall ((x@ tuple%0.)) (! (= x@ (%Poly%tuple%0. (Poly%tuple%0. x@))) :pattern ((Poly%tuple%0. x@)) :qid internal_crate__tuple__0_box_axiom_definition :skolemid skolem_internal_crate__tuple__0_box_axiom_definition)))
(assert (forall ((x@ Poly)) (! (=> (has_type x@ TYPE%tuple%0.) (= x@ (Poly%tuple%0. (%Poly%tuple%0. x@)))) :pattern ((has_type x@ TYPE%tuple%0.)) :qid internal_crate__tuple__0_unbox_axiom_definition :skolemid skolem_internal_crate__tuple__0_unbox_axiom_definition)))
(assert (forall ((x@ tuple%0.)) (! (has_type (Poly%tuple%0. x@) TYPE%tuple%0.) :pattern ((has_type (Poly%tuple%0. x@) TYPE%tuple%0.)) :qid internal_crate__tuple__0_has_type_always_definition :skolemid skolem_internal_crate__tuple__0_has_type_always_definition)))
(assert (forall ((x@ tuple%2.)) (! (= x@ (%Poly%tuple%2. (Poly%tuple%2. x@))) :pattern ((Poly%tuple%2. x@)) :qid internal_crate__tuple__2_box_axiom_definition :skolemid skolem_internal_crate__tuple__2_box_axiom_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0& T%1&)) (= x@ (Poly%tuple%2. (%Poly%tuple%2. x@)))) :pattern ((has_type x@ (TYPE%tuple%2. T%0& T%1&))) :qid internal_crate__tuple__2_unbox_axiom_definition :skolemid skolem_internal_crate__tuple__2_unbox_axiom_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (field%0@ Poly) (field%1@ Poly)) (! (=> (and (has_type field%0@ T%0&) (has_type field%1@ T%1&)) (has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2. T%0& T%1&))) :pattern ((has_type (Poly%tuple%2. (tuple%2./tuple%2 field%0@ field%1@)) (TYPE%tuple%2. T%0& T%1&))) :qid internal_tuple__2./tuple__2_constructor_definition :skolemid skolem_internal_tuple__2./tuple__2_constructor_definition)))
(assert (forall ((x@ tuple%2.)) (! (= (tuple%2./tuple%2/field%0 x@) (tuple%2./tuple%2/?field%0 x@)) :pattern ((tuple%2./tuple%2/field%0 x@)) :qid internal_tuple__2./tuple__2/field__0_accessor_definition :skolemid skolem_internal_tuple__2./tuple__2/field__0_accessor_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0& T%1&)) (has_type (tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) T%0&)) :pattern ((tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2. T%0& T%1&))) :qid internal_tuple__2./tuple__2/field__0_invariant_definition :skolemid skolem_internal_tuple__2./tuple__2/field__0_invariant_definition)))
(assert (forall ((x@ tuple%2.)) (! (= (tuple%2./tuple%2/field%1 x@) (tuple%2./tuple%2/?field%1 x@)) :pattern ((tuple%2./tuple%2/field%1 x@)) :qid internal_tuple__2./tuple__2/field__1_accessor_definition :skolemid skolem_internal_tuple__2./tuple__2/field__1_accessor_definition)))
(assert (forall ((T%0& Type) (T%1& Type) (x@ Poly)) (! (=> (has_type x@ (TYPE%tuple%2. T%0& T%1&)) (has_type (tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) T%1&)) :pattern ((tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) (has_type x@ (TYPE%tuple%2. T%0& T%1&))) :qid internal_tuple__2./tuple__2/field__1_invariant_definition :skolemid skolem_internal_tuple__2./tuple__2/field__1_invariant_definition)))
(assert (forall ((x tuple%2.)) (! (=> ((_ is tuple%2./tuple%2) x) (height_lt (height (tuple%2./tuple%2/field%0 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/field%0 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((x tuple%2.)) (! (=> ((_ is tuple%2./tuple%2) x) (height_lt (height (tuple%2./tuple%2/field%1 x)) (height (Poly%tuple%2. x)))) :pattern ((height (tuple%2./tuple%2/field%1 x))) :qid prelude_datatype_height :skolemid skolem_prelude_datatype_height)))
(assert (forall ((T%0& Type) (T%0&. Type) (T%1& Type) (T%1&. Type) (deep@ Bool) (x@ Poly) (y@ Poly)) (! (=> (and (has_type x@ (TYPE%tuple%2. T%0& T%1&)) (has_type y@ (TYPE%tuple%2. T%0& T%1&)) (ext_eq deep@ T%0& T%0&. (tuple%2./tuple%2/field%0 (%Poly%tuple%2. x@)) (tuple%2./tuple%2/field%0 (%Poly%tuple%2. y@))) (ext_eq deep@ T%1& T%1&. (tuple%2./tuple%2/field%1 (%Poly%tuple%2. x@)) (tuple%2./tuple%2/field%1 (%Poly%tuple%2. y@)))) (ext_eq deep@ (TYPE%tuple%2. T%0& T%1&) (TYPE%tuple%2. T%0&. T%1&.) x@ y@)) :pattern ((ext_eq deep@ (TYPE%tuple%2. T%0& T%1&) (TYPE%tuple%2. T%0&. T%1&.) x@ y@)) :qid internal_tuple__2./tuple__2_ext_equal_definition :skolemid skolem_internal_tuple__2./tuple__2_ext_equal_definition)))
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::is_Ok")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? (Type Type Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::get_Ok_0")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? (Type Type Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::is_Err")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.? (Type Type Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::std_specs::result::ResultAdditionalSpecFns::get_Err_0")
(declare-fun vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.? (Type Type Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::pervasive::arbitrary")
(declare-fun vstd!pervasive.arbitrary.? (Type Type) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::empty")
(declare-fun vstd!map.impl&%0.empty.? (Type Type Type Type) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::new")
(declare-fun vstd!map.impl&%0.new.? (Type Type Type Type Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::dom")
(declare-fun vstd!map.impl&%0.dom.? (Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::index")
(declare-fun vstd!map.impl&%0.index.? (Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::spec_index")
(declare-fun vstd!map.impl&%0.spec_index.? (Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::insert")
(declare-fun vstd!map.impl&%0.insert.? (Type Type Type Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::remove")
(declare-fun vstd!map.impl&%0.remove.? (Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::contains_pair")
(declare-fun vstd!map.impl&%0.contains_pair.? (Type Type Type Type Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::map::impl&%0::union_prefer_right")
(declare-fun vstd!map.impl&%0.union_prefer_right.? (Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::map::check_argument_is_map")
(declare-fun vstd!map.check_argument_is_map.? (Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::empty")
(declare-fun vstd!seq.Seq.empty.? (Type Type) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::new")
(declare-fun vstd!seq.Seq.new.? (Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::len")
(declare-fun vstd!seq.Seq.len.? (Type Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::seq::Seq::index")
(declare-fun vstd!seq.Seq.index.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_index")
(declare-fun vstd!seq.impl&%0.spec_index.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::push")
(declare-fun vstd!seq.Seq.push.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::update")
(declare-fun vstd!seq.Seq.update.? (Type Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::subrange")
(declare-fun vstd!seq.Seq.subrange.? (Type Type Poly Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::Seq::add")
(declare-fun vstd!seq.Seq.add.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq::impl&%0::spec_add")
(declare-fun vstd!seq.impl&%0.spec_add.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::filter")
(declare-fun vstd!seq_lib.impl&%0.filter.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::contains")
(declare-fun vstd!seq_lib.impl&%0.contains.? (Type Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::seq_lib::impl&%0::to_set")
(declare-fun vstd!seq_lib.impl&%0.to_set.? (Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::seq_lib::check_argument_is_seq")
(declare-fun vstd!seq_lib.check_argument_is_seq.? (Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::empty")
(declare-fun vstd!set.impl&%0.empty.? (Type Type) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::new")
(declare-fun vstd!set.impl&%0.new.? (Type Type Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::contains")
(declare-fun vstd!set.impl&%0.contains.? (Type Type Poly Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::insert")
(declare-fun vstd!set.impl&%0.insert.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::remove")
(declare-fun vstd!set.impl&%0.remove.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::union")
(declare-fun vstd!set.impl&%0.union.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::intersect")
(declare-fun vstd!set.impl&%0.intersect.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::difference")
(declare-fun vstd!set.impl&%0.difference.? (Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::complement")
(declare-fun vstd!set.impl&%0.complement.? (Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::finite")
(declare-fun vstd!set.impl&%0.finite.? (Type Type Poly) Bool)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::len")
(declare-fun vstd!set.impl&%0.len.? (Type Type Poly) Int)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::choose")
(declare-fun vstd!set.impl&%0.choose.? (Type Type Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set::impl&%0::mk_map")
(declare-fun vstd!set.impl&%0.mk_map.? (Type Type Type Type Type Type Poly Poly) Poly)
(set-info :comment ";; Function-Decl vstd::set_lib::check_argument_is_set")
(declare-fun vstd!set_lib.check_argument_is_set.? (Type Type Poly) Poly)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::inv")
(declare-fun main!impl_u.l0.impl&%0.inv.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::mappings_are_of_valid_size")
(declare-fun main!impl_u.l0.impl&%0.mappings_are_of_valid_size.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::mappings_are_aligned")
(declare-fun main!impl_u.l0.impl&%0.mappings_are_aligned.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::mappings_dont_overlap")
(declare-fun main!impl_u.l0.impl&%0.mappings_dont_overlap.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::candidate_mapping_in_bounds")
(declare-fun main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::mappings_in_bounds")
(declare-fun main!impl_u.l0.impl&%0.mappings_in_bounds.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::accepted_mapping")
(declare-fun main!impl_u.l0.impl&%0.accepted_mapping.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::valid_mapping")
(declare-fun main!impl_u.l0.impl&%0.valid_mapping.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::map_frame")
(declare-fun main!impl_u.l0.impl&%0.map_frame.? (Poly Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::accepted_resolve")
(declare-fun main!impl_u.l0.impl&%0.accepted_resolve.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::resolve")
(declare-fun main!impl_u.l0.impl&%0.resolve.? (Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::remove")
(declare-fun main!impl_u.l0.impl&%0.remove.? (Poly Poly) main!impl_u.l0.PageTableContents.)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::accepted_unmap")
(declare-fun main!impl_u.l0.impl&%0.accepted_unmap.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::unmap")
(declare-fun main!impl_u.l0.impl&%0.unmap.? (Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::ranges_disjoint")
(declare-fun main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l0::PageTableContents::mappings_disjoint")
(declare-fun main!impl_u.l0.impl&%0.mappings_disjoint.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::well_formed")
(declare-fun main!impl_u.l1.impl&%0.well_formed.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::entry_size")
(declare-fun main!impl_u.l1.impl&%0.entry_size.? (Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::num_entries")
(declare-fun main!impl_u.l1.impl&%0.num_entries.? (Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::empty")
(declare-fun main!impl_u.l1.impl&%0.empty.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::pages_match_entry_size")
(declare-fun main!impl_u.l1.impl&%0.pages_match_entry_size.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::directories_are_in_next_layer")
(declare-fun main!impl_u.l1.impl&%0.directories_are_in_next_layer.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::directories_obey_invariant")
(declare-fun main!impl_u.l1.impl&%0.directories_obey_invariant.? (Poly) Bool)
(declare-fun main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? (Poly Fuel) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::directories_match_arch")
(declare-fun main!impl_u.l1.impl&%0.directories_match_arch.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::directories_are_nonempty")
(declare-fun main!impl_u.l1.impl&%0.directories_are_nonempty.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::frames_aligned")
(declare-fun main!impl_u.l1.impl&%0.frames_aligned.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::inv")
(declare-fun main!impl_u.l1.impl&%0.inv.? (Poly) Bool)
(declare-fun main!impl_u.l1.impl&%0.rec%inv.? (Poly Fuel) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::interp")
(declare-fun main!impl_u.l1.impl&%0.interp.? (Poly) main!impl_u.l0.PageTableContents.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::upper_vaddr")
(declare-fun main!impl_u.l1.impl&%0.upper_vaddr.? (Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::index_for_vaddr")
(declare-fun main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::entry_base")
(declare-fun main!impl_u.l1.impl&%0.entry_base.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::next_entry_base")
(declare-fun main!impl_u.l1.impl&%0.next_entry_base.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::entry_bounds")
(declare-fun main!impl_u.l1.impl&%0.entry_bounds.? (Poly Poly) tuple%2.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::interp_of_entry")
(declare-fun main!impl_u.l1.impl&%0.interp_of_entry.? (Poly Poly) main!impl_u.l0.PageTableContents.)
(declare-fun main!impl_u.l1.impl&%0.rec%interp_of_entry.? (Poly Poly Fuel) main!impl_u.l0.PageTableContents.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::interp_aux")
(declare-fun main!impl_u.l1.impl&%0.interp_aux.? (Poly Poly) main!impl_u.l0.PageTableContents.)
(declare-fun main!impl_u.l1.impl&%0.rec%interp_aux.? (Poly Poly Fuel) main!impl_u.l0.PageTableContents.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::resolve")
(declare-fun main!impl_u.l1.impl&%0.resolve.? (Poly Poly) core!result.Result.)
(declare-fun main!impl_u.l1.impl&%0.rec%resolve.? (Poly Poly Fuel) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::update")
(declare-fun main!impl_u.l1.impl&%0.update.? (Poly Poly Poly) main!impl_u.l1.Directory.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::candidate_mapping_in_bounds")
(declare-fun main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::accepted_mapping")
(declare-fun main!impl_u.l1.impl&%0.accepted_mapping.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::new_empty_dir")
(declare-fun main!impl_u.l1.impl&%0.new_empty_dir.? (Poly Poly) main!impl_u.l1.Directory.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::map_frame")
(declare-fun main!impl_u.l1.impl&%0.map_frame.? (Poly Poly Poly) core!result.Result.)
(declare-fun main!impl_u.l1.impl&%0.rec%map_frame.? (Poly Poly Poly Fuel) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::accepted_unmap")
(declare-fun main!impl_u.l1.impl&%0.accepted_unmap.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::impl_u::l1::Directory::unmap")
(declare-fun main!impl_u.l1.impl&%0.unmap.? (Poly Poly) core!result.Result.)
(declare-fun main!impl_u.l1.impl&%0.rec%unmap.? (Poly Poly Fuel) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l1::result_map_ok")
(declare-fun main!impl_u.l1.result_map_ok.? (Type Type Type Type Type Type Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::l1::result_map")
(declare-fun main!impl_u.l1.result_map.? (Type Type Type Type Poly Poly) core!result.Result.)
(set-info :comment ";; Function-Decl main::impl_u::indexing::index_from_offset")
(declare-fun main!impl_u.indexing.index_from_offset.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::indexing::index_from_base_and_addr")
(declare-fun main!impl_u.indexing.index_from_base_and_addr.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::indexing::entry_base_from_index")
(declare-fun main!impl_u.indexing.entry_base_from_index.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::indexing::next_entry_base_from_index")
(declare-fun main!impl_u.indexing.next_entry_base_from_index.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::impl_u::indexing::nat_mul")
(declare-fun main!impl_u.indexing.nat_mul.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::entry_size")
(declare-fun main!definitions_t.impl&%7.entry_size.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::num_entries")
(declare-fun main!definitions_t.impl&%7.num_entries.? (Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::upper_vaddr")
(declare-fun main!definitions_t.impl&%7.upper_vaddr.? (Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::inv")
(declare-fun main!definitions_t.impl&%7.inv.? (Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::entry_size_is_next_layer_size")
(declare-fun main!definitions_t.impl&%7.entry_size_is_next_layer_size.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::contains_entry_size_at_index_atleast")
(declare-fun main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::contains_entry_size")
(declare-fun main!definitions_t.impl&%7.contains_entry_size.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::index_for_vaddr")
(declare-fun main!definitions_t.impl&%7.index_for_vaddr.? (Poly Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::entry_base")
(declare-fun main!definitions_t.impl&%7.entry_base.? (Poly Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::Arch::next_entry_base")
(declare-fun main!definitions_t.impl&%7.next_entry_base.? (Poly Poly Poly Poly) Int)
(set-info :comment ";; Function-Decl main::definitions_t::X86_NUM_LAYERS")
(declare-fun main!definitions_t.X86_NUM_LAYERS.? () Int)
(set-info :comment ";; Function-Decl main::definitions_t::X86_NUM_ENTRIES")
(declare-fun main!definitions_t.X86_NUM_ENTRIES.? () Int)
(set-info :comment ";; Function-Decl main::definitions_t::X86_MAX_ENTRY_SIZE")
(declare-fun main!definitions_t.X86_MAX_ENTRY_SIZE.? () Int)
(set-info :comment ";; Function-Decl main::definitions_t::aligned")
(declare-fun main!definitions_t.aligned.? (Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::between")
(declare-fun main!definitions_t.between.? (Poly Poly Poly) Bool)
(set-info :comment ";; Function-Decl main::definitions_t::new_seq")
(declare-fun main!definitions_t.new_seq.? (Type Type Poly Poly) Poly)
(declare-fun main!definitions_t.rec%new_seq.? (Type Type Poly Poly Fuel) Poly)
(set-info :comment ";; Function-Decl main::definitions_t::overlap")
(declare-fun main!definitions_t.overlap.? (Poly Poly) Bool)
(set-info :comment ";; Function-Specs vstd::seq::Seq::index")
(declare-fun req%vstd!seq.Seq.index. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%0 Bool)
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly)) (! (= (req%vstd!seq.Seq.index. A& A&. self~2@ i~4@) (=> %%global_location_label%%0 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A& A&. self~2@))))) :pattern ((req%vstd!seq.Seq.index. A& A&. self~2@ i~4@)) :qid internal_req__vstd!seq.Seq.index._definition :skolemid skolem_internal_req__vstd!seq.Seq.index._definition)))
(set-info :comment ";; Function-Specs vstd::seq::Seq::update")
(declare-fun req%vstd!seq.Seq.update. (Type Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%1 Bool)
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly) (a~6@ Poly)) (! (= (req%vstd!seq.Seq.update. A& A&. self~2@ i~4@ a~6@) (=> %%global_location_label%%1 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A& A&. self~2@))))) :pattern ((req%vstd!seq.Seq.update. A& A&. self~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.Seq.update._definition :skolemid skolem_internal_req__vstd!seq.Seq.update._definition)))
(set-info :comment ";; Function-Specs vstd::seq::impl&%0::spec_index")
(declare-fun req%vstd!seq.impl&%0.spec_index. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%2 Bool)
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly)) (! (= (req%vstd!seq.impl&%0.spec_index. A& A&. self~2@ i~4@) (=> %%global_location_label%%2 (and (<= 0 (%I i~4@)) (< (%I i~4@) (vstd!seq.Seq.len.? A& A&. self~2@))))) :pattern ((req%vstd!seq.impl&%0.spec_index. A& A&. self~2@ i~4@)) :qid internal_req__vstd!seq.impl&__0.spec_index._definition :skolemid skolem_internal_req__vstd!seq.impl&__0.spec_index._definition)))
(set-info :comment ";; Function-Specs vstd::seq::Seq::subrange")
(declare-fun req%vstd!seq.Seq.subrange. (Type Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%3 Bool)
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (start_inclusive~4@ Poly) (end_exclusive~6@ Poly)) (! (= (req%vstd!seq.Seq.subrange. A& A&. self~2@ start_inclusive~4@ end_exclusive~6@) (=> %%global_location_label%%3 (and (and (<= 0 (%I start_inclusive~4@)) (<= (%I start_inclusive~4@) (%I end_exclusive~6@))) (<= (%I end_exclusive~6@) (vstd!seq.Seq.len.? A& A&. self~2@))))) :pattern ((req%vstd!seq.Seq.subrange. A& A&. self~2@ start_inclusive~4@ end_exclusive~6@)) :qid internal_req__vstd!seq.Seq.subrange._definition :skolemid skolem_internal_req__vstd!seq.Seq.subrange._definition)))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::index")
(declare-fun req%vstd!map.impl&%0.index. (Type Type Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%4 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.impl&%0.index. K& K&. V& V&. self~2@ key~4@) (=> %%global_location_label%%4 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@) key~4@))) :pattern ((req%vstd!map.impl&%0.index. K& K&. V& V&. self~2@ key~4@)) :qid internal_req__vstd!map.impl&__0.index._definition :skolemid skolem_internal_req__vstd!map.impl&__0.index._definition)))
(set-info :comment ";; Function-Specs vstd::map::impl&%0::spec_index")
(declare-fun req%vstd!map.impl&%0.spec_index. (Type Type Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%5 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.impl&%0.spec_index. K& K&. V& V&. self~2@ key~4@) (=> %%global_location_label%%5 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@) key~4@))) :pattern ((req%vstd!map.impl&%0.spec_index. K& K&. V& V&. self~2@ key~4@)) :qid internal_req__vstd!map.impl&__0.spec_index._definition :skolemid skolem_internal_req__vstd!map.impl&__0.spec_index._definition)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_index_decreases_finite")
(declare-fun req%vstd!map.axiom_map_index_decreases_finite. (Type Type Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%6 Bool)
(declare-const %%global_location_label%%7 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.axiom_map_index_decreases_finite. K& K&. V& V&. m~2@ key~4@) (and (=> %%global_location_label%%6 (vstd!set.impl&%0.finite.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@))) (=> %%global_location_label%%7 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key~4@)))) :pattern ((req%vstd!map.axiom_map_index_decreases_finite. K& K&. V& V&. m~2@ key~4@)) :qid internal_req__vstd!map.axiom_map_index_decreases_finite._definition :skolemid skolem_internal_req__vstd!map.axiom_map_index_decreases_finite._definition)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_index_decreases_infinite")
(declare-fun req%vstd!map.axiom_map_index_decreases_infinite. (Type Type Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%8 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly)) (! (= (req%vstd!map.axiom_map_index_decreases_infinite. K& K&. V& V&. m~2@ key~4@) (=> %%global_location_label%%8 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key~4@))) :pattern ((req%vstd!map.axiom_map_index_decreases_infinite. K& K&. V& V&. m~2@ key~4@)) :qid internal_req__vstd!map.axiom_map_index_decreases_infinite._definition :skolemid skolem_internal_req__vstd!map.axiom_map_index_decreases_infinite._definition)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_insert_different")
(declare-fun req%vstd!map.axiom_map_insert_different. (Type Type Type Type Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%9 Bool)
(declare-const %%global_location_label%%10 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly) (value~8@ Poly)) (! (= (req%vstd!map.axiom_map_insert_different. K& K&. V& V&. m~2@ key1~4@ key2~6@ value~8@) (and (=> %%global_location_label%%9 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key1~4@)) (=> %%global_location_label%%10 (not (= key1~4@ key2~6@))))) :pattern ((req%vstd!map.axiom_map_insert_different. K& K&. V& V&. m~2@ key1~4@ key2~6@ value~8@)) :qid internal_req__vstd!map.axiom_map_insert_different._definition :skolemid skolem_internal_req__vstd!map.axiom_map_insert_different._definition)))
(set-info :comment ";; Function-Specs vstd::map::axiom_map_remove_different")
(declare-fun req%vstd!map.axiom_map_remove_different. (Type Type Type Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%11 Bool)
(declare-const %%global_location_label%%12 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly)) (! (= (req%vstd!map.axiom_map_remove_different. K& K&. V& V&. m~2@ key1~4@ key2~6@) (and (=> %%global_location_label%%11 (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key1~4@)) (=> %%global_location_label%%12 (not (= key1~4@ key2~6@))))) :pattern ((req%vstd!map.axiom_map_remove_different. K& K&. V& V&. m~2@ key1~4@ key2~6@)) :qid internal_req__vstd!map.axiom_map_remove_different._definition :skolemid skolem_internal_req__vstd!map.axiom_map_remove_different._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_index_decreases")
(declare-fun req%vstd!seq.axiom_seq_index_decreases. (Type Type Poly Int) Bool)
(declare-const %%global_location_label%%13 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int)) (! (= (req%vstd!seq.axiom_seq_index_decreases. A& A&. s~2@ i~4@) (=> %%global_location_label%%13 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A& A&. s~2@))))) :pattern ((req%vstd!seq.axiom_seq_index_decreases. A& A&. s~2@ i~4@)) :qid internal_req__vstd!seq.axiom_seq_index_decreases._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_index_decreases._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_new_index")
(declare-fun req%vstd!seq.axiom_seq_new_index. (Type Type Int %%Function%% Int) Bool)
(declare-const %%global_location_label%%14 Bool)
(assert (forall ((A& Type) (A&. Type) (len~2@ Int) (f~4@ %%Function%%) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_new_index. A& A&. len~2@ f~4@ i~6@) (=> %%global_location_label%%14 (and (<= 0 i~6@) (< i~6@ len~2@)))) :pattern ((req%vstd!seq.axiom_seq_new_index. A& A&. len~2@ f~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_new_index._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_new_index._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_push_index_same")
(declare-fun req%vstd!seq.axiom_seq_push_index_same. (Type Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%15 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_push_index_same. A& A&. s~2@ a~4@ i~6@) (=> %%global_location_label%%15 (= i~6@ (vstd!seq.Seq.len.? A& A&. s~2@)))) :pattern ((req%vstd!seq.axiom_seq_push_index_same. A& A&. s~2@ a~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_push_index_same._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_push_index_same._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_push_index_different")
(declare-fun req%vstd!seq.axiom_seq_push_index_different. (Type Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%16 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_push_index_different. A& A&. s~2@ a~4@ i~6@) (=> %%global_location_label%%16 (and (<= 0 i~6@) (< i~6@ (vstd!seq.Seq.len.? A& A&. s~2@))))) :pattern ((req%vstd!seq.axiom_seq_push_index_different. A& A&. s~2@ a~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_push_index_different._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_push_index_different._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_len")
(declare-fun req%vstd!seq.axiom_seq_update_len. (Type Type Poly Int Poly) Bool)
(declare-const %%global_location_label%%17 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_len. A& A&. s~2@ i~4@ a~6@) (=> %%global_location_label%%17 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A& A&. s~2@))))) :pattern ((req%vstd!seq.axiom_seq_update_len. A& A&. s~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.axiom_seq_update_len._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_len._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_same")
(declare-fun req%vstd!seq.axiom_seq_update_same. (Type Type Poly Int Poly) Bool)
(declare-const %%global_location_label%%18 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_same. A& A&. s~2@ i~4@ a~6@) (=> %%global_location_label%%18 (and (<= 0 i~4@) (< i~4@ (vstd!seq.Seq.len.? A& A&. s~2@))))) :pattern ((req%vstd!seq.axiom_seq_update_same. A& A&. s~2@ i~4@ a~6@)) :qid internal_req__vstd!seq.axiom_seq_update_same._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_same._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_update_different")
(declare-fun req%vstd!seq.axiom_seq_update_different. (Type Type Poly Int Int Poly) Bool)
(declare-const %%global_location_label%%19 Bool)
(declare-const %%global_location_label%%20 Bool)
(declare-const %%global_location_label%%21 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i1~4@ Int) (i2~6@ Int) (a~8@ Poly)) (! (= (req%vstd!seq.axiom_seq_update_different. A& A&. s~2@ i1~4@ i2~6@ a~8@) (and (=> %%global_location_label%%19 (and (<= 0 i1~4@) (< i1~4@ (vstd!seq.Seq.len.? A& A&. s~2@)))) (=> %%global_location_label%%20 (and (<= 0 i2~6@) (< i2~6@ (vstd!seq.Seq.len.? A& A&. s~2@)))) (=> %%global_location_label%%21 (not (= i1~4@ i2~6@))))) :pattern ((req%vstd!seq.axiom_seq_update_different. A& A&. s~2@ i1~4@ i2~6@ a~8@)) :qid internal_req__vstd!seq.axiom_seq_update_different._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_update_different._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_subrange_len")
(declare-fun req%vstd!seq.axiom_seq_subrange_len. (Type Type Poly Int Int) Bool)
(declare-const %%global_location_label%%22 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int)) (! (= (req%vstd!seq.axiom_seq_subrange_len. A& A&. s~2@ j~4@ k~6@) (=> %%global_location_label%%22 (and (and (<= 0 j~4@) (<= j~4@ k~6@)) (<= k~6@ (vstd!seq.Seq.len.? A& A&. s~2@))))) :pattern ((req%vstd!seq.axiom_seq_subrange_len. A& A&. s~2@ j~4@ k~6@)) :qid internal_req__vstd!seq.axiom_seq_subrange_len._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_subrange_len._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_subrange_index")
(declare-fun req%vstd!seq.axiom_seq_subrange_index. (Type Type Poly Int Int Int) Bool)
(declare-const %%global_location_label%%23 Bool)
(declare-const %%global_location_label%%24 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int) (i~8@ Int)) (! (= (req%vstd!seq.axiom_seq_subrange_index. A& A&. s~2@ j~4@ k~6@ i~8@) (and (=> %%global_location_label%%23 (and (and (<= 0 j~4@) (<= j~4@ k~6@)) (<= k~6@ (vstd!seq.Seq.len.? A& A&. s~2@)))) (=> %%global_location_label%%24 (and (<= 0 i~8@) (< i~8@ (- k~6@ j~4@)))))) :pattern ((req%vstd!seq.axiom_seq_subrange_index. A& A&. s~2@ j~4@ k~6@ i~8@)) :qid internal_req__vstd!seq.axiom_seq_subrange_index._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_subrange_index._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_add_index1")
(declare-fun req%vstd!seq.axiom_seq_add_index1. (Type Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%25 Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_add_index1. A& A&. s1~2@ s2~4@ i~6@) (=> %%global_location_label%%25 (and (<= 0 i~6@) (< i~6@ (vstd!seq.Seq.len.? A& A&. s1~2@))))) :pattern ((req%vstd!seq.axiom_seq_add_index1. A& A&. s1~2@ s2~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_add_index1._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_add_index1._definition)))
(set-info :comment ";; Function-Specs vstd::seq::axiom_seq_add_index2")
(declare-fun req%vstd!seq.axiom_seq_add_index2. (Type Type Poly Poly Int) Bool)
(declare-const %%global_location_label%%26 Bool)
(declare-const %%global_location_label%%27 Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (req%vstd!seq.axiom_seq_add_index2. A& A&. s1~2@ s2~4@ i~6@) (and (=> %%global_location_label%%26 (<= 0 (vstd!seq.Seq.len.? A& A&. s1~2@))) (=> %%global_location_label%%27 (< i~6@ (+ (vstd!seq.Seq.len.? A& A&. s1~2@) (vstd!seq.Seq.len.? A& A&. s2~4@)))))) :pattern ((req%vstd!seq.axiom_seq_add_index2. A& A&. s1~2@ s2~4@ i~6@)) :qid internal_req__vstd!seq.axiom_seq_add_index2._definition :skolemid skolem_internal_req__vstd!seq.axiom_seq_add_index2._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_different")
(declare-fun req%vstd!set.axiom_set_insert_different. (Type Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%28 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (req%vstd!set.axiom_set_insert_different. A& A&. s~2@ a1~4@ a2~6@) (=> %%global_location_label%%28 (not (= a1~4@ a2~6@)))) :pattern ((req%vstd!set.axiom_set_insert_different. A& A&. s~2@ a1~4@ a2~6@)) :qid internal_req__vstd!set.axiom_set_insert_different._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_different._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_different")
(declare-fun req%vstd!set.axiom_set_remove_different. (Type Type Poly Poly Poly) Bool)
(declare-const %%global_location_label%%29 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (req%vstd!set.axiom_set_remove_different. A& A&. s~2@ a1~4@ a2~6@) (=> %%global_location_label%%29 (not (= a1~4@ a2~6@)))) :pattern ((req%vstd!set.axiom_set_remove_different. A& A&. s~2@ a1~4@ a2~6@)) :qid internal_req__vstd!set.axiom_set_remove_different._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_different._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_mk_map_index")
(declare-fun req%vstd!set.axiom_mk_map_index. (Type Type Type Type Poly %%Function%% Poly) Bool)
(declare-const %%global_location_label%%30 Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (s~2@ Poly) (f~4@ %%Function%%) (key~6@ Poly)) (! (= (req%vstd!set.axiom_mk_map_index. K& K&. V& V&. s~2@ f~4@ key~6@) (=> %%global_location_label%%30 (vstd!set.impl&%0.contains.? K& K&. s~2@ key~6@))) :pattern ((req%vstd!set.axiom_mk_map_index. K& K&. V& V&. s~2@ f~4@ key~6@)) :qid internal_req__vstd!set.axiom_mk_map_index._definition :skolemid skolem_internal_req__vstd!set.axiom_mk_map_index._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_finite")
(declare-fun req%vstd!set.axiom_set_insert_finite. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%31 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_insert_finite. A& A&. s~2@ a~4@) (=> %%global_location_label%%31 (vstd!set.impl&%0.finite.? A& A&. s~2@))) :pattern ((req%vstd!set.axiom_set_insert_finite. A& A&. s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_insert_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_finite")
(declare-fun req%vstd!set.axiom_set_remove_finite. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%32 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_remove_finite. A& A&. s~2@ a~4@) (=> %%global_location_label%%32 (vstd!set.impl&%0.finite.? A& A&. s~2@))) :pattern ((req%vstd!set.axiom_set_remove_finite. A& A&. s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_remove_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_union_finite")
(declare-fun req%vstd!set.axiom_set_union_finite. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%33 Bool)
(declare-const %%global_location_label%%34 Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_union_finite. A& A&. s1~2@ s2~4@) (and (=> %%global_location_label%%33 (vstd!set.impl&%0.finite.? A& A&. s1~2@)) (=> %%global_location_label%%34 (vstd!set.impl&%0.finite.? A& A&. s2~4@)))) :pattern ((req%vstd!set.axiom_set_union_finite. A& A&. s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_union_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_union_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_intersect_finite")
(declare-fun req%vstd!set.axiom_set_intersect_finite. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%35 Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_intersect_finite. A& A&. s1~2@ s2~4@) (=> %%global_location_label%%35 (or (vstd!set.impl&%0.finite.? A& A&. s1~2@) (vstd!set.impl&%0.finite.? A& A&. s2~4@)))) :pattern ((req%vstd!set.axiom_set_intersect_finite. A& A&. s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_intersect_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_intersect_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_difference_finite")
(declare-fun req%vstd!set.axiom_set_difference_finite. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%36 Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (req%vstd!set.axiom_set_difference_finite. A& A&. s1~2@ s2~4@) (=> %%global_location_label%%36 (vstd!set.impl&%0.finite.? A& A&. s1~2@))) :pattern ((req%vstd!set.axiom_set_difference_finite. A& A&. s1~2@ s2~4@)) :qid internal_req__vstd!set.axiom_set_difference_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_difference_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_choose_finite")
(declare-fun req%vstd!set.axiom_set_choose_finite. (Type Type Poly) Bool)
(declare-const %%global_location_label%%37 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (req%vstd!set.axiom_set_choose_finite. A& A&. s~2@) (=> %%global_location_label%%37 (not (vstd!set.impl&%0.finite.? A& A&. s~2@)))) :pattern ((req%vstd!set.axiom_set_choose_finite. A& A&. s~2@)) :qid internal_req__vstd!set.axiom_set_choose_finite._definition :skolemid skolem_internal_req__vstd!set.axiom_set_choose_finite._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_insert_len")
(declare-fun req%vstd!set.axiom_set_insert_len. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%38 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_insert_len. A& A&. s~2@ a~4@) (=> %%global_location_label%%38 (vstd!set.impl&%0.finite.? A& A&. s~2@))) :pattern ((req%vstd!set.axiom_set_insert_len. A& A&. s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_insert_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_insert_len._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_remove_len")
(declare-fun req%vstd!set.axiom_set_remove_len. (Type Type Poly Poly) Bool)
(declare-const %%global_location_label%%39 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (req%vstd!set.axiom_set_remove_len. A& A&. s~2@ a~4@) (=> %%global_location_label%%39 (vstd!set.impl&%0.finite.? A& A&. s~2@))) :pattern ((req%vstd!set.axiom_set_remove_len. A& A&. s~2@ a~4@)) :qid internal_req__vstd!set.axiom_set_remove_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_remove_len._definition)))
(set-info :comment ";; Function-Specs vstd::set::axiom_set_choose_len")
(declare-fun req%vstd!set.axiom_set_choose_len. (Type Type Poly) Bool)
(declare-const %%global_location_label%%40 Bool)
(declare-const %%global_location_label%%41 Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (req%vstd!set.axiom_set_choose_len. A& A&. s~2@) (and (=> %%global_location_label%%40 (vstd!set.impl&%0.finite.? A& A&. s~2@)) (=> %%global_location_label%%41 (not (= (vstd!set.impl&%0.len.? A& A&. s~2@) 0))))) :pattern ((req%vstd!set.axiom_set_choose_len. A& A&. s~2@)) :qid internal_req__vstd!set.axiom_set_choose_len._definition :skolemid skolem_internal_req__vstd!set.axiom_set_choose_len._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::entry_size")
(declare-fun req%main!definitions_t.impl&%7.entry_size. (Poly Poly) Bool)
(declare-const %%global_location_label%%42 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly)) (! (= (req%main!definitions_t.impl&%7.entry_size. self~2@ layer~4@) (=> %%global_location_label%%42 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))))))) :pattern ((req%main!definitions_t.impl&%7.entry_size. self~2@ layer~4@)) :qid internal_req__main!definitions_t.impl&__7.entry_size._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.entry_size._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::num_entries")
(declare-fun req%main!definitions_t.impl&%7.num_entries. (Poly Poly) Bool)
(declare-const %%global_location_label%%43 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly)) (! (= (req%main!definitions_t.impl&%7.num_entries. self~2@ layer~4@) (=> %%global_location_label%%43 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))))))) :pattern ((req%main!definitions_t.impl&%7.num_entries. self~2@ layer~4@)) :qid internal_req__main!definitions_t.impl&__7.num_entries._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.num_entries._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::entry_size_is_next_layer_size")
(declare-fun req%main!definitions_t.impl&%7.entry_size_is_next_layer_size. (Poly Poly) Bool)
(declare-const %%global_location_label%%44 Bool)
(assert (forall ((self~2@ Poly) (i~4@ Poly)) (! (= (req%main!definitions_t.impl&%7.entry_size_is_next_layer_size. self~2@ i~4@) (=> %%global_location_label%%44 (< (%I i~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))))))) :pattern ((req%main!definitions_t.impl&%7.entry_size_is_next_layer_size. self~2@ i~4@)) :qid internal_req__main!definitions_t.impl&__7.entry_size_is_next_layer_size._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.entry_size_is_next_layer_size._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l0::PageTableContents::resolve")
(declare-fun req%main!impl_u.l0.impl&%0.resolve. (Poly Poly) Bool)
(declare-const %%global_location_label%%45 Bool)
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (= (req%main!impl_u.l0.impl&%0.resolve. self~2@ vaddr~4@) (=> %%global_location_label%%45 (main!impl_u.l0.impl&%0.accepted_resolve.? self~2@ vaddr~4@))) :pattern ((req%main!impl_u.l0.impl&%0.resolve. self~2@ vaddr~4@)) :qid internal_req__main!impl_u.l0.impl&__0.resolve._definition :skolemid skolem_internal_req__main!impl_u.l0.impl&__0.resolve._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l0::PageTableContents::unmap")
(declare-fun req%main!impl_u.l0.impl&%0.unmap. (Poly Poly) Bool)
(declare-const %%global_location_label%%46 Bool)
(assert (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (req%main!impl_u.l0.impl&%0.unmap. self~2@ base~4@) (=> %%global_location_label%%46 (main!impl_u.l0.impl&%0.accepted_unmap.? self~2@ base~4@))) :pattern ((req%main!impl_u.l0.impl&%0.unmap. self~2@ base~4@)) :qid internal_req__main!impl_u.l0.impl&__0.unmap._definition :skolemid skolem_internal_req__main!impl_u.l0.impl&__0.unmap._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l0::PageTableContents::lemma_unmap_decrements_len")
(declare-fun req%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. (main!impl_u.l0.PageTableContents. Int) Bool)
(declare-const %%global_location_label%%47 Bool)
(declare-const %%global_location_label%%48 Bool)
(assert (forall ((self~2@ main!impl_u.l0.PageTableContents.) (base~4@ Int)) (! (= (req%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. self~2@ base~4@) (and (=> %%global_location_label%%47 (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. self~2@))) (=> %%global_location_label%%48 (%B (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l0.impl&%0.unmap.? (Poly%main!impl_u.l0.PageTableContents. self~2@) (I base~4@)))))))))) :pattern ((req%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. self~2@ base~4@)) :qid internal_req__main!impl_u.l0.impl&__0.lemma_unmap_decrements_len._definition :skolemid skolem_internal_req__main!impl_u.l0.impl&__0.lemma_unmap_decrements_len._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l0::PageTableContents::lemma_ranges_disjoint_implies_mappings_disjoint")
(declare-fun req%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. (main!impl_u.l0.PageTableContents. main!impl_u.l0.PageTableContents.) Bool)
(declare-const %%global_location_label%%49 Bool)
(declare-const %%global_location_label%%50 Bool)
(declare-const %%global_location_label%%51 Bool)
(assert (forall ((self~2@ main!impl_u.l0.PageTableContents.) (other~4@ main!impl_u.l0.PageTableContents.)) (! (= (req%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. self~2@ other~4@) (and (=> %%global_location_label%%49 (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. self~2@))) (=> %%global_location_label%%50 (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. other~4@))) (=> %%global_location_label%%51 (main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly%main!impl_u.l0.PageTableContents. self~2@) (Poly%main!impl_u.l0.PageTableContents. other~4@))))) :pattern ((req%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. self~2@ other~4@)) :qid internal_req__main!impl_u.l0.impl&__0.lemma_ranges_disjoint_implies_mappings_disjoint._definition :skolemid skolem_internal_req__main!impl_u.l0.impl&__0.lemma_ranges_disjoint_implies_mappings_disjoint._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::entry_size")
(declare-fun req%main!impl_u.l1.impl&%0.entry_size. (Poly) Bool)
(declare-const %%global_location_label%%52 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.entry_size. self~2@) (=> %%global_location_label%%52 (< (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))))))))) :pattern ((req%main!impl_u.l1.impl&%0.entry_size. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.entry_size._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.entry_size._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::num_entries")
(declare-fun req%main!impl_u.l1.impl&%0.num_entries. (Poly) Bool)
(declare-const %%global_location_label%%53 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.num_entries. self~2@) (=> %%global_location_label%%53 (< (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))))))))) :pattern ((req%main!impl_u.l1.impl&%0.num_entries. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.num_entries._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.num_entries._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::empty")
(declare-fun req%main!impl_u.l1.impl&%0.empty. (Poly) Bool)
(declare-const %%global_location_label%%54 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.empty. self~2@) (=> %%global_location_label%%54 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.empty. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.empty._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.empty._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::pages_match_entry_size")
(declare-fun req%main!impl_u.l1.impl&%0.pages_match_entry_size. (Poly) Bool)
(declare-const %%global_location_label%%55 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.pages_match_entry_size. self~2@) (=> %%global_location_label%%55 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.pages_match_entry_size. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.pages_match_entry_size._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.pages_match_entry_size._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::directories_are_in_next_layer")
(declare-fun req%main!impl_u.l1.impl&%0.directories_are_in_next_layer. (Poly) Bool)
(declare-const %%global_location_label%%56 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.directories_are_in_next_layer. self~2@) (=> %%global_location_label%%56 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.directories_are_in_next_layer. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.directories_are_in_next_layer._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.directories_are_in_next_layer._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::directories_are_nonempty")
(declare-fun req%main!impl_u.l1.impl&%0.directories_are_nonempty. (Poly) Bool)
(declare-const %%global_location_label%%57 Bool)
(declare-const %%global_location_label%%58 Bool)
(declare-const %%global_location_label%%59 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.directories_are_nonempty. self~2@) (and (=> %%global_location_label%%57 (main!impl_u.l1.impl&%0.well_formed.? self~2@)) (=> %%global_location_label%%58 (main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@)) (=> %%global_location_label%%59 (main!impl_u.l1.impl&%0.directories_match_arch.? self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.directories_are_nonempty. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.directories_are_nonempty._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.directories_are_nonempty._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::frames_aligned")
(declare-fun req%main!impl_u.l1.impl&%0.frames_aligned. (Poly) Bool)
(declare-const %%global_location_label%%60 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.frames_aligned. self~2@) (=> %%global_location_label%%60 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.frames_aligned. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.frames_aligned._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.frames_aligned._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::directories_obey_invariant")
(declare-fun req%main!impl_u.l1.impl&%0.directories_obey_invariant. (Poly) Bool)
(declare-const %%global_location_label%%61 Bool)
(declare-const %%global_location_label%%62 Bool)
(declare-const %%global_location_label%%63 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.directories_obey_invariant. self~2@) (and (=> %%global_location_label%%61 (main!impl_u.l1.impl&%0.well_formed.? self~2@)) (=> %%global_location_label%%62 (main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@)) (=> %%global_location_label%%63 (main!impl_u.l1.impl&%0.directories_match_arch.? self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.directories_obey_invariant. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.directories_obey_invariant._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.directories_obey_invariant._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::entry_base")
(declare-fun req%main!definitions_t.impl&%7.entry_base. (Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%64 Bool)
(declare-const %%global_location_label%%65 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (= (req%main!definitions_t.impl&%7.entry_base. self~2@ layer~4@ base~6@ idx~8@) (and (=> %%global_location_label%%64 (main!definitions_t.impl&%7.inv.? self~2@)) (=> %%global_location_label%%65 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))))))) :pattern ((req%main!definitions_t.impl&%7.entry_base. self~2@ layer~4@ base~6@ idx~8@)) :qid internal_req__main!definitions_t.impl&__7.entry_base._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.entry_base._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::upper_vaddr")
(declare-fun req%main!definitions_t.impl&%7.upper_vaddr. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%66 Bool)
(declare-const %%global_location_label%%67 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly)) (! (= (req%main!definitions_t.impl&%7.upper_vaddr. self~2@ layer~4@ base~6@) (and (=> %%global_location_label%%66 (main!definitions_t.impl&%7.inv.? self~2@)) (=> %%global_location_label%%67 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))))))) :pattern ((req%main!definitions_t.impl&%7.upper_vaddr. self~2@ layer~4@ base~6@)) :qid internal_req__main!definitions_t.impl&__7.upper_vaddr._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.upper_vaddr._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::upper_vaddr")
(declare-fun req%main!impl_u.l1.impl&%0.upper_vaddr. (Poly) Bool)
(declare-const %%global_location_label%%68 Bool)
(assert (forall ((self~2@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.upper_vaddr. self~2@) (=> %%global_location_label%%68 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.upper_vaddr. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.upper_vaddr._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.upper_vaddr._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::entry_base")
(declare-fun req%main!impl_u.l1.impl&%0.entry_base. (Poly Poly) Bool)
(declare-const %%global_location_label%%69 Bool)
(assert (forall ((self~2@ Poly) (idx~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.entry_base. self~2@ idx~4@) (=> %%global_location_label%%69 (main!impl_u.l1.impl&%0.inv.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.entry_base. self~2@ idx~4@)) :qid internal_req__main!impl_u.l1.impl&__0.entry_base._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.entry_base._definition)))
(set-info :comment ";; Function-Specs main::impl_u::indexing::index_from_offset")
(declare-fun req%main!impl_u.indexing.index_from_offset. (Poly Poly) Bool)
(declare-const %%global_location_label%%70 Bool)
(assert (forall ((offset~2@ Poly) (entry_size~4@ Poly)) (! (= (req%main!impl_u.indexing.index_from_offset. offset~2@ entry_size~4@) (=> %%global_location_label%%70 (> (%I entry_size~4@) 0))) :pattern ((req%main!impl_u.indexing.index_from_offset. offset~2@ entry_size~4@)) :qid internal_req__main!impl_u.indexing.index_from_offset._definition :skolemid skolem_internal_req__main!impl_u.indexing.index_from_offset._definition)))
(set-info :comment ";; Function-Specs main::impl_u::indexing::index_from_base_and_addr")
(declare-fun req%main!impl_u.indexing.index_from_base_and_addr. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%71 Bool)
(declare-const %%global_location_label%%72 Bool)
(assert (forall ((base~2@ Poly) (addr~4@ Poly) (entry_size~6@ Poly)) (! (= (req%main!impl_u.indexing.index_from_base_and_addr. base~2@ addr~4@ entry_size~6@) (and (=> %%global_location_label%%71 (>= (%I addr~4@) (%I base~2@))) (=> %%global_location_label%%72 (> (%I entry_size~6@) 0)))) :pattern ((req%main!impl_u.indexing.index_from_base_and_addr. base~2@ addr~4@ entry_size~6@)) :qid internal_req__main!impl_u.indexing.index_from_base_and_addr._definition :skolemid skolem_internal_req__main!impl_u.indexing.index_from_base_and_addr._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::index_for_vaddr")
(declare-fun req%main!definitions_t.impl&%7.index_for_vaddr. (Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%73 Bool)
(declare-const %%global_location_label%%74 Bool)
(declare-const %%global_location_label%%75 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (vaddr~8@ Poly)) (! (= (req%main!definitions_t.impl&%7.index_for_vaddr. self~2@ layer~4@ base~6@ vaddr~8@) (and (=> %%global_location_label%%73 (main!definitions_t.impl&%7.inv.? self~2@)) (=> %%global_location_label%%74 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))))) (=> %%global_location_label%%75 (<= (%I base~6@) (%I vaddr~8@))))) :pattern ((req%main!definitions_t.impl&%7.index_for_vaddr. self~2@ layer~4@ base~6@ vaddr~8@)) :qid internal_req__main!definitions_t.impl&__7.index_for_vaddr._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.index_for_vaddr._definition)))
(set-info :comment ";; Function-Specs main::definitions_t::Arch::next_entry_base")
(declare-fun req%main!definitions_t.impl&%7.next_entry_base. (Poly Poly Poly Poly) Bool)
(declare-const %%global_location_label%%76 Bool)
(declare-const %%global_location_label%%77 Bool)
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (= (req%main!definitions_t.impl&%7.next_entry_base. self~2@ layer~4@ base~6@ idx~8@) (and (=> %%global_location_label%%76 (main!definitions_t.impl&%7.inv.? self~2@)) (=> %%global_location_label%%77 (< (%I layer~4@) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))))))) :pattern ((req%main!definitions_t.impl&%7.next_entry_base. self~2@ layer~4@ base~6@ idx~8@)) :qid internal_req__main!definitions_t.impl&__7.next_entry_base._definition :skolemid skolem_internal_req__main!definitions_t.impl&__7.next_entry_base._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::next_entry_base")
(declare-fun req%main!impl_u.l1.impl&%0.next_entry_base. (Poly Poly) Bool)
(declare-const %%global_location_label%%78 Bool)
(assert (forall ((self~2@ Poly) (idx~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.next_entry_base. self~2@ idx~4@) (=> %%global_location_label%%78 (main!impl_u.l1.impl&%0.inv.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.next_entry_base. self~2@ idx~4@)) :qid internal_req__main!impl_u.l1.impl&__0.next_entry_base._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.next_entry_base._definition)))
(set-info :comment ";; Function-Specs main::impl_u::indexing::lemma_entry_base_from_index")
(declare-fun req%main!impl_u.indexing.lemma_entry_base_from_index. (Int Int Int) Bool)
(declare-const %%global_location_label%%79 Bool)
(assert (forall ((base~2@ Int) (idx~4@ Int) (entry_size~6@ Int)) (! (= (req%main!impl_u.indexing.lemma_entry_base_from_index. base~2@ idx~4@ entry_size~6@) (=> %%global_location_label%%79 (< 0 entry_size~6@))) :pattern ((req%main!impl_u.indexing.lemma_entry_base_from_index. base~2@ idx~4@ entry_size~6@)) :qid internal_req__main!impl_u.indexing.lemma_entry_base_from_index._definition :skolemid skolem_internal_req__main!impl_u.indexing.lemma_entry_base_from_index._definition)))
(set-info :comment ";; Function-Specs main::impl_u::lib::mod_mult_zero_implies_mod_zero")
(declare-fun req%main!impl_u.lib.mod_mult_zero_implies_mod_zero. (Int Int Int) Bool)
(declare-const %%global_location_label%%80 Bool)
(declare-const %%global_location_label%%81 Bool)
(assert (forall ((a~2@ Int) (b~4@ Int) (c~6@ Int)) (! (= (req%main!impl_u.lib.mod_mult_zero_implies_mod_zero. a~2@ b~4@ c~6@) (and (=> %%global_location_label%%80 (main!definitions_t.aligned.? (I a~2@) (I (nClip (Mul b~4@ c~6@))))) (=> %%global_location_label%%81 (> c~6@ 0)))) :pattern ((req%main!impl_u.lib.mod_mult_zero_implies_mod_zero. a~2@ b~4@ c~6@)) :qid internal_req__main!impl_u.lib.mod_mult_zero_implies_mod_zero._definition :skolemid skolem_internal_req__main!impl_u.lib.mod_mult_zero_implies_mod_zero._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_inv_implies_interp_aux_inv")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%82 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. self~2@ i~4@) (=> %%global_location_label%%82 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. self~2@ i~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_aux_inv._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_aux_inv._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_inv_implies_interp_inv")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%83 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. self~2@) (=> %%global_location_label%%83 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_inv._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_inv._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_inv_implies_interp_of_entry_inv")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%84 Bool)
(declare-const %%global_location_label%%85 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. self~2@ i~4@) (and (=> %%global_location_label%%84 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%85 (< i~4@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. self~2@ i~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_of_entry_inv._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_of_entry_inv._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_of_entry")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_of_entry. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%86 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_of_entry. self~2@) (=> %%global_location_label%%86 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_of_entry. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_of_entries_disjoint")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%87 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. self~2@) (=> %%global_location_label%%87 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entries_disjoint._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entries_disjoint._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_empty_implies_interp_aux_empty")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%88 Bool)
(declare-const %%global_location_label%%89 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. self~2@ i~4@) (and (=> %%global_location_label%%88 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%89 (main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. self~2@ i~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_aux_empty._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_aux_empty._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_empty_implies_interp_empty")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%90 Bool)
(declare-const %%global_location_label%%91 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. self~2@) (and (=> %%global_location_label%%90 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%91 (main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_empty._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_empty._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_ranges_disjoint_interp_aux_interp_of_entry")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%92 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. self~2@) (=> %%global_location_label%%92 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_ranges_disjoint_interp_aux_interp_of_entry._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_ranges_disjoint_interp_aux_interp_of_entry._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. (main!impl_u.l1.Directory. Int Int) Bool)
(declare-const %%global_location_label%%93 Bool)
(declare-const %%global_location_label%%94 Bool)
(declare-const %%global_location_label%%95 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int) (j~6@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. self~2@ i~4@ j~6@) (and (=> %%global_location_label%%93 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%94 (<= i~4@ j~6@)) (=> %%global_location_label%%95 (< j~6@ (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. self~2@ i~4@ j~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%96 Bool)
(declare-const %%global_location_label%%97 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. self~2@ j~4@) (and (=> %%global_location_label%%96 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%97 (< j~4@ (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. self~2@ j~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping._definition)))
(set-info :comment ";; Function-Specs main::impl_u::indexing::lemma_index_from_base_and_addr")
(declare-fun req%main!impl_u.indexing.lemma_index_from_base_and_addr. (Int Int Int Int) Bool)
(declare-const %%global_location_label%%98 Bool)
(declare-const %%global_location_label%%99 Bool)
(declare-const %%global_location_label%%100 Bool)
(assert (forall ((base~2@ Int) (addr~4@ Int) (entry_size~6@ Int) (num_entries~8@ Int)) (! (= (req%main!impl_u.indexing.lemma_index_from_base_and_addr. base~2@ addr~4@ entry_size~6@ num_entries~8@) (and (=> %%global_location_label%%98 (>= addr~4@ base~2@)) (=> %%global_location_label%%99 (< addr~4@ (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I num_entries~8@) (I entry_size~6@)))) (=> %%global_location_label%%100 (> entry_size~6@ 0)))) :pattern ((req%main!impl_u.indexing.lemma_index_from_base_and_addr. base~2@ addr~4@ entry_size~6@ num_entries~8@)) :qid internal_req__main!impl_u.indexing.lemma_index_from_base_and_addr._definition :skolemid skolem_internal_req__main!impl_u.indexing.lemma_index_from_base_and_addr._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::resolve")
(declare-fun req%main!impl_u.l1.impl&%0.resolve. (Poly Poly) Bool)
(declare-const %%global_location_label%%101 Bool)
(declare-const %%global_location_label%%102 Bool)
(declare-const %%global_location_label%%103 Bool)
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.resolve. self~2@ vaddr~4@) (and (=> %%global_location_label%%101 (main!impl_u.l1.impl&%0.inv.? self~2@)) (=> %%global_location_label%%102 (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) vaddr~4@)) (=> %%global_location_label%%103 (and (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) vaddr~4@))))) :pattern ((req%main!impl_u.l1.impl&%0.resolve. self~2@ vaddr~4@)) :qid internal_req__main!impl_u.l1.impl&__0.resolve._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.resolve._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_aux_contains_implies_interp_of_entry_contains")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%104 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. self~2@ j~4@) (=> %%global_location_label%%104 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. self~2@ j~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_aux_contains_implies_interp_of_entry_contains._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_aux_contains_implies_interp_of_entry_contains._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_interp_contains_implies_interp_of_entry_contains")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%105 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. self~2@) (=> %%global_location_label%%105 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_interp_contains_implies_interp_of_entry_contains._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_interp_contains_implies_interp_of_entry_contains._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. (main!impl_u.l1.Directory. Int Int) Bool)
(declare-const %%global_location_label%%106 Bool)
(declare-const %%global_location_label%%107 Bool)
(declare-const %%global_location_label%%108 Bool)
(declare-const %%global_location_label%%109 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int) (i~6@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. self~2@ vaddr~4@ i~6@) (and (=> %%global_location_label%%106 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%107 (< i~6@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%108 (main!definitions_t.between.? (I vaddr~4@) (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)))))) (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)))))))) (=> %%global_location_label%%109 (not (exists ((base~52$ Poly)) (! (and (has_type base~52$ NAT) (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@))))))) base~52$) (main!definitions_t.between.? (I vaddr~4@) base~52$ (I (nClip (+ (%I base~52$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)))))) base~52$)))))))))))) :pattern ((vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)))))) base~52$)) :qid user_main__impl_u__l1__Directory__lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp_128 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp_128)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. self~2@ vaddr~4@ i~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_resolve_structure_assertions")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. (main!impl_u.l1.Directory. Int Int) Bool)
(declare-const %%global_location_label%%110 Bool)
(declare-const %%global_location_label%%111 Bool)
(declare-const %%global_location_label%%112 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int) (idx~6@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. self~2@ vaddr~4@ idx~6@) (and (=> %%global_location_label%%110 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%111 (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I vaddr~4@))) (=> %%global_location_label%%112 (= idx~6@ (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I vaddr~4@)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. self~2@ vaddr~4@ idx~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_resolve_structure_assertions._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_resolve_structure_assertions._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_resolve_refines")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_resolve_refines. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%113 Bool)
(declare-const %%global_location_label%%114 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_resolve_refines. self~2@ vaddr~4@) (and (=> %%global_location_label%%113 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%114 (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I vaddr~4@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_resolve_refines. self~2@ vaddr~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_resolve_refines._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_resolve_refines._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::update")
(declare-fun req%main!impl_u.l1.impl&%0.update. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%115 Bool)
(assert (forall ((self~2@ Poly) (n~4@ Poly) (e~6@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.update. self~2@ n~4@ e~6@) (=> %%global_location_label%%115 (< (%I n~4@) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))))) :pattern ((req%main!impl_u.l1.impl&%0.update. self~2@ n~4@ e~6@)) :qid internal_req__main!impl_u.l1.impl&__0.update._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.update._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::candidate_mapping_in_bounds")
(declare-fun req%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%116 Bool)
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds. self~2@ base~4@ pte~6@) (=> %%global_location_label%%116 (main!impl_u.l1.impl&%0.inv.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.candidate_mapping_in_bounds._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.candidate_mapping_in_bounds._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::accepted_mapping")
(declare-fun req%main!impl_u.l1.impl&%0.accepted_mapping. (Poly Poly Poly) Bool)
(declare-const %%global_location_label%%117 Bool)
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.accepted_mapping. self~2@ base~4@ pte~6@) (=> %%global_location_label%%117 (main!impl_u.l1.impl&%0.inv.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.accepted_mapping. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.accepted_mapping._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.accepted_mapping._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_accepted_mapping_implies_interp_accepted_mapping_manual")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%118 Bool)
(declare-const %%global_location_label%%119 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. self~2@ base~4@ pte~6@) (and (=> %%global_location_label%%118 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%119 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::new_empty_dir")
(declare-fun req%main!impl_u.l1.impl&%0.new_empty_dir. (Poly Poly) Bool)
(declare-const %%global_location_label%%120 Bool)
(declare-const %%global_location_label%%121 Bool)
(declare-const %%global_location_label%%122 Bool)
(assert (forall ((self~2@ Poly) (entry~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.new_empty_dir. self~2@ entry~4@) (and (=> %%global_location_label%%120 (main!impl_u.l1.impl&%0.inv.? self~2@)) (=> %%global_location_label%%121 (< (%I entry~4@) (main!impl_u.l1.impl&%0.num_entries.? self~2@))) (=> %%global_location_label%%122 (< (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) 1)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))))))))))) :pattern ((req%main!impl_u.l1.impl&%0.new_empty_dir. self~2@ entry~4@)) :qid internal_req__main!impl_u.l1.impl&__0.new_empty_dir._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.new_empty_dir._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_new_empty_dir")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_new_empty_dir. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%123 Bool)
(declare-const %%global_location_label%%124 Bool)
(declare-const %%global_location_label%%125 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (entry~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_new_empty_dir. self~2@ entry~4@) (and (=> %%global_location_label%%123 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%124 (< entry~4@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%125 (< (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) 1)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_new_empty_dir. self~2@ entry~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_new_empty_dir._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_new_empty_dir._definition)))
(set-info :comment ";; Function-Specs main::impl_u::lib::leq_add_aligned_less")
(declare-fun req%main!impl_u.lib.leq_add_aligned_less. (Int Int Int) Bool)
(declare-const %%global_location_label%%126 Bool)
(declare-const %%global_location_label%%127 Bool)
(declare-const %%global_location_label%%128 Bool)
(declare-const %%global_location_label%%129 Bool)
(assert (forall ((a~2@ Int) (b~4@ Int) (c~6@ Int)) (! (= (req%main!impl_u.lib.leq_add_aligned_less. a~2@ b~4@ c~6@) (and (=> %%global_location_label%%126 (< 0 b~4@)) (=> %%global_location_label%%127 (< a~2@ c~6@)) (=> %%global_location_label%%128 (main!definitions_t.aligned.? (I a~2@) (I b~4@))) (=> %%global_location_label%%129 (main!definitions_t.aligned.? (I c~6@) (I b~4@))))) :pattern ((req%main!impl_u.lib.leq_add_aligned_less. a~2@ b~4@ c~6@)) :qid internal_req__main!impl_u.lib.leq_add_aligned_less._definition :skolemid skolem_internal_req__main!impl_u.lib.leq_add_aligned_less._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_accepted_mapping_implies_directory_accepted_mapping")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry. main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%130 Bool)
(declare-const %%global_location_label%%131 Bool)
(declare-const %%global_location_label%%132 Bool)
(declare-const %%global_location_label%%133 Bool)
(declare-const %%global_location_label%%134 Bool)
(declare-const %%global_location_label%%135 Bool)
(declare-const %%global_location_label%%136 Bool)
(declare-const %%global_location_label%%137 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.) (d~8@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. self~2@ base~4@ pte~6@ d~8@) (and (=> %%global_location_label%%130 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%131 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (=> %%global_location_label%%132 (= (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~8@))) (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))) (=> %%global_location_label%%133 (= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~8@))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)))))) (=> %%global_location_label%%134 (= (main!impl_u.l1.impl&%0.upper_vaddr.? (Poly%main!impl_u.l1.Directory. d~8@)) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)) 1)))))) (=> %%global_location_label%%135 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. d~8@))) (=> %%global_location_label%%136 (= (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~8@))) (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) 1)))) (=> %%global_location_label%%137 (not (= (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@)) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. pte~6@))))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. self~2@ base~4@ pte~6@ d~8@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_directory_accepted_mapping._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_directory_accepted_mapping._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_map_frame_empty_is_ok")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%138 Bool)
(declare-const %%global_location_label%%139 Bool)
(declare-const %%global_location_label%%140 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. self~2@ base~4@ pte~6@) (and (=> %%global_location_label%%138 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%139 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (=> %%global_location_label%%140 ((_ is main!impl_u.l1.NodeEntry./Empty) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_empty_is_ok._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_empty_is_ok._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_map_frame_preserves_inv")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%141 Bool)
(declare-const %%global_location_label%%142 Bool)
(declare-const %%global_location_label%%143 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. self~2@ base~4@ pte~6@) (and (=> %%global_location_label%%141 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%142 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (=> %%global_location_label%%143 (%B (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@)))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_preserves_inv._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_preserves_inv._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_entries_equal_implies_interp_aux_equal")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. (main!impl_u.l1.Directory. main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%144 Bool)
(declare-const %%global_location_label%%145 Bool)
(declare-const %%global_location_label%%146 Bool)
(declare-const %%global_location_label%%147 Bool)
(declare-const %%global_location_label%%148 Bool)
(declare-const %%global_location_label%%149 Bool)
(declare-const %%global_location_label%%150 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (other~4@ main!impl_u.l1.Directory.) (i~6@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. self~2@ other~4@ i~6@) (and (=> %%global_location_label%%144 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%145 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. other~4@))) (=> %%global_location_label%%146 (= (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. other~4@))))) (=> %%global_location_label%%147 (= (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. other~4@))))) (=> %%global_location_label%%148 (= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. other~4@))))) (=> %%global_location_label%%149 (= (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. other~4@)))) (=> %%global_location_label%%150 (forall ((j~66$ Poly)) (! (=> (has_type j~66$ INT) (=> (and (<= i~6@ (%I j~66$)) (< (%I j~66$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))))) (= (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) j~66$) (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. other~4@)))) j~66$)))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) j~66$)) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. other~4@)))) j~66$)) :qid user_main__impl_u__l1__Directory__lemma_entries_equal_implies_interp_aux_equal_136 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_entries_equal_implies_interp_aux_equal_136))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. self~2@ other~4@ i~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_entries_equal_implies_interp_aux_equal._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_entries_equal_implies_interp_aux_equal._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_insert_interp_of_entry_implies_insert_interp_aux")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. (main!impl_u.l1.Directory. Int Int Int main!impl_u.l1.NodeEntry. main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%151 Bool)
(declare-const %%global_location_label%%152 Bool)
(declare-const %%global_location_label%%153 Bool)
(declare-const %%global_location_label%%154 Bool)
(declare-const %%global_location_label%%155 Bool)
(declare-const %%global_location_label%%156 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int) (j~6@ Int) (base~8@ Int) (n~10@ main!impl_u.l1.NodeEntry.) (pte~12@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. self~2@ i~4@ j~6@ base~8@ n~10@ pte~12@) (and (=> %%global_location_label%%151 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%152 (<= i~4@ j~6@)) (=> %%global_location_label%%153 (< j~6@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%154 (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) (I base~8@)))) (=> %%global_location_label%%155 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@) (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (=> %%global_location_label%%156 (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@)))))) (I base~8@) (Poly%main!definitions_t.PageTableEntry. pte~12@))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) n~10@) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((p~82$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))) (Poly%main!definitions_t.PageTableEntry. p~82$)))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) n~10@) (let ((d~104$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~104$) (I 0)))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.)))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. self~2@ i~4@ j~6@ base~8@ n~10@ pte~12@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp_aux._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp_aux._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_insert_interp_of_entry_implies_insert_interp")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. (main!impl_u.l1.Directory. Int Int main!impl_u.l1.NodeEntry. main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%157 Bool)
(declare-const %%global_location_label%%158 Bool)
(declare-const %%global_location_label%%159 Bool)
(declare-const %%global_location_label%%160 Bool)
(declare-const %%global_location_label%%161 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (base~6@ Int) (n~8@ main!impl_u.l1.NodeEntry.) (pte~10@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. self~2@ j~4@ base~6@ n~8@ pte~10@) (and (=> %%global_location_label%%157 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%158 (< j~4@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%159 (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) (I base~6@)))) (=> %%global_location_label%%160 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (=> %%global_location_label%%161 (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) (I base~6@) (Poly%main!definitions_t.PageTableEntry. pte~10@))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) n~8@) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((p~72$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))) (Poly%main!definitions_t.PageTableEntry. p~72$)))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) n~8@) (let ((d~94$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~94$) (I 0)))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.)))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. self~2@ j~4@ base~6@ n~8@ pte~10@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_nonempty_implies_exists_interp_dom_contains")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. (main!impl_u.l1.Directory.) Bool)
(declare-const %%global_location_label%%162 Bool)
(declare-const %%global_location_label%%163 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. self~2@) (and (=> %%global_location_label%%162 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%163 (not (main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. self~2@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_nonempty_implies_exists_interp_dom_contains._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_nonempty_implies_exists_interp_dom_contains._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_map_frame_refines_map_frame")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(declare-const %%global_location_label%%164 Bool)
(declare-const %%global_location_label%%165 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. self~2@ base~4@ pte~6@) (and (=> %%global_location_label%%164 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%165 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. self~2@ base~4@ pte~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_refines_map_frame._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_refines_map_frame._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_map_frame_structure_assertions")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry. Int) Bool)
(declare-const %%global_location_label%%166 Bool)
(declare-const %%global_location_label%%167 Bool)
(declare-const %%global_location_label%%168 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.) (idx~8@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. self~2@ base~4@ pte~6@ idx~8@) (and (=> %%global_location_label%%166 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%167 (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (=> %%global_location_label%%168 (= idx~8@ (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. self~2@ base~4@ pte~6@ idx~8@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_structure_assertions._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_map_frame_structure_assertions._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::accepted_unmap")
(declare-fun req%main!impl_u.l1.impl&%0.accepted_unmap. (Poly Poly) Bool)
(declare-const %%global_location_label%%169 Bool)
(assert (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.accepted_unmap. self~2@ base~4@) (=> %%global_location_label%%169 (main!impl_u.l1.impl&%0.well_formed.? self~2@))) :pattern ((req%main!impl_u.l1.impl&%0.accepted_unmap. self~2@ base~4@)) :qid internal_req__main!impl_u.l1.impl&__0.accepted_unmap._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.accepted_unmap._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::unmap")
(declare-fun req%main!impl_u.l1.impl&%0.unmap. (Poly Poly) Bool)
(declare-const %%global_location_label%%170 Bool)
(declare-const %%global_location_label%%171 Bool)
(assert (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (req%main!impl_u.l1.impl&%0.unmap. self~2@ base~4@) (and (=> %%global_location_label%%170 (main!impl_u.l1.impl&%0.inv.? self~2@)) (=> %%global_location_label%%171 (main!impl_u.l1.impl&%0.accepted_unmap.? self~2@ base~4@)))) :pattern ((req%main!impl_u.l1.impl&%0.unmap. self~2@ base~4@)) :qid internal_req__main!impl_u.l1.impl&__0.unmap._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.unmap._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_unmap_preserves_inv")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%172 Bool)
(declare-const %%global_location_label%%173 Bool)
(declare-const %%global_location_label%%174 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. self~2@ base~4@) (and (=> %%global_location_label%%172 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%173 (main!impl_u.l1.impl&%0.accepted_unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))) (=> %%global_location_label%%174 (%B (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)))))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. self~2@ base~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_unmap_preserves_inv._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_unmap_preserves_inv._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. (main!impl_u.l1.Directory. Int Int Int main!impl_u.l1.NodeEntry.) Bool)
(declare-const %%global_location_label%%175 Bool)
(declare-const %%global_location_label%%176 Bool)
(declare-const %%global_location_label%%177 Bool)
(declare-const %%global_location_label%%178 Bool)
(declare-const %%global_location_label%%179 Bool)
(declare-const %%global_location_label%%180 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (i~6@ Int) (vaddr~8@ Int) (n~10@ main!impl_u.l1.NodeEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. self~2@ j~4@ i~6@ vaddr~8@ n~10@) (and (=> %%global_location_label%%175 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%176 (<= i~6@ j~4@)) (=> %%global_location_label%%177 (< j~4@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%178 (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) (I vaddr~8@))) (=> %%global_location_label%%179 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (=> %%global_location_label%%180 (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) (I vaddr~8@))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) n~10@) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((p~77$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))) (Poly%main!definitions_t.PageTableEntry. p~77$)))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) n~10@) (let ((d~99$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~10@))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~99$) (I 0)))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.)))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. self~2@ j~4@ i~6@ vaddr~8@ n~10@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_remove_from_interp_of_entry_implies_remove_from_interp")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. (main!impl_u.l1.Directory. Int Int main!impl_u.l1.NodeEntry.) Bool)
(declare-const %%global_location_label%%181 Bool)
(declare-const %%global_location_label%%182 Bool)
(declare-const %%global_location_label%%183 Bool)
(declare-const %%global_location_label%%184 Bool)
(declare-const %%global_location_label%%185 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (vaddr~6@ Int) (n~8@ main!impl_u.l1.NodeEntry.)) (! (= (req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. self~2@ j~4@ vaddr~6@ n~8@) (and (=> %%global_location_label%%181 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%182 (< j~4@ (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (=> %%global_location_label%%183 (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) (I vaddr~6@))) (=> %%global_location_label%%184 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (=> %%global_location_label%%185 (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) (I vaddr~6@))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) n~8@) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((p~69$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))) (Poly%main!definitions_t.PageTableEntry. p~69$)))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) n~8@) (let ((d~91$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. n~8@))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~91$) (I 0)))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.)))))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. self~2@ j~4@ vaddr~6@ n~8@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_unmap_refines_unmap")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. (main!impl_u.l1.Directory. Int) Bool)
(declare-const %%global_location_label%%186 Bool)
(declare-const %%global_location_label%%187 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. self~2@ base~4@) (and (=> %%global_location_label%%186 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%187 (main!impl_u.l1.impl&%0.accepted_unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. self~2@ base~4@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_unmap_refines_unmap._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_unmap_refines_unmap._definition)))
(set-info :comment ";; Function-Specs main::impl_u::l1::Directory::lemma_unmap_structure_assertions")
(declare-fun req%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. (main!impl_u.l1.Directory. Int Int) Bool)
(declare-const %%global_location_label%%188 Bool)
(declare-const %%global_location_label%%189 Bool)
(declare-const %%global_location_label%%190 Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (idx~6@ Int)) (! (= (req%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. self~2@ base~4@ idx~6@) (and (=> %%global_location_label%%188 (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> %%global_location_label%%189 (main!impl_u.l1.impl&%0.accepted_unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))) (=> %%global_location_label%%190 (= idx~6@ (main!impl_u.l1.impl&%0.index_for_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)))))) :pattern ((req%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. self~2@ base~4@ idx~6@)) :qid internal_req__main!impl_u.l1.impl&__0.lemma_unmap_structure_assertions._definition :skolemid skolem_internal_req__main!impl_u.l1.impl&__0.lemma_unmap_structure_assertions._definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::is_Ok")
(assert (forall ((Self%& Type) (Self%&. Type) (T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? Self%& Self%&. T& T&. E& E&. self~2@) BOOL)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? Self%& Self%&. T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::get_Ok_0")
(assert (forall ((Self%& Type) (Self%&. Type) (T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? Self%& Self%&. T& T&. E& E&. self~2@) T&)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? Self%& Self%&. T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::is_Err")
(assert (forall ((Self%& Type) (Self%&. Type) (T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.? Self%& Self%&. T& T&. E& E&. self~2@) BOOL)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.? Self%& Self%&. T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::ResultAdditionalSpecFns::get_Err_0")
(assert (forall ((Self%& Type) (Self%&. Type) (T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ Self%&) (has_type (vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.? Self%& Self%&. T& T&. E& E&. self~2@) E&)) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.? Self%& Self%&. T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.?_pre_post_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::is_Ok")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.is_Ok.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.is_Ok.) (forall ((T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@) (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. self~2@)))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.?_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Ok.?_definition))))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::get_Ok_0")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.get_Ok_0.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.get_Ok_0.) (forall ((T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@) (core!result.Result./Ok/_0 (%Poly%core!result.Result. self~2@))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.?_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Ok_0.?_definition))))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::is_Err")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.is_Err.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.is_Err.) (forall ((T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@) (B ((_ is core!result.Result./Err) (%Poly%core!result.Result. self~2@)))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.?_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.is_Err.?_definition))))
(set-info :comment ";; Function-Axioms vstd::std_specs::result::impl&%0::get_Err_0")
(assert (fuel_bool_default fuel%vstd!std_specs.result.impl&%0.get_Err_0.))
(assert (=> (fuel_bool fuel%vstd!std_specs.result.impl&%0.get_Err_0.) (forall ((T& Type) (T&. Type) (E& Type) (E&. Type) (self~2@ Poly)) (! (= (vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@) (core!result.Result./Err/_0 (%Poly%core!result.Result. self~2@))) :pattern ((vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.? (TYPE%core!result.Result. T& E&) (TYPE%core!result.Result. T&. E&.) T& T&. E& E&. self~2@)) :qid internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.?_definition :skolemid skolem_internal_vstd!std_specs.result.ResultAdditionalSpecFns.get_Err_0.?_definition))))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::len")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (<= 0 (vstd!seq.Seq.len.? A& A&. self~2@))) :pattern ((vstd!seq.Seq.len.? A& A&. self~2@)) :qid internal_vstd!seq.Seq.len.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.len.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::index")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type i~4@ INT)) (has_type (vstd!seq.Seq.index.? A& A&. self~2@ i~4@) A&)) :pattern ((vstd!seq.Seq.index.? A& A&. self~2@ i~4@)) :qid internal_vstd!seq.Seq.index.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::update")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly) (a~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type i~4@ INT) (has_type a~6@ A&)) (has_type (vstd!seq.Seq.update.? A& A&. self~2@ i~4@ a~6@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.Seq.update.? A& A&. self~2@ i~4@ a~6@)) :qid internal_vstd!seq.Seq.update.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.update.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::empty")
(assert (forall ((A& Type) (A&. Type)) (! (has_type (vstd!seq.Seq.empty.? A& A&.) (TYPE%vstd!seq.Seq. A&)) :pattern ((vstd!seq.Seq.empty.? A& A&.)) :qid internal_vstd!seq.Seq.empty.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::push")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type a~4@ A&)) (has_type (vstd!seq.Seq.push.? A& A&. self~2@ a~4@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.Seq.push.? A& A&. self~2@ a~4@)) :qid internal_vstd!seq.Seq.push.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.push.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_index.) (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly)) (! (= (vstd!seq.impl&%0.spec_index.? A& A&. self~2@ i~4@) (vstd!seq.Seq.index.? A& A&. self~2@ i~4@)) :pattern ((vstd!seq.impl&%0.spec_index.? A& A&. self~2@ i~4@)) :qid internal_vstd!seq.impl&__0.spec_index.?_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_index.?_definition))))
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (i~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type i~4@ INT)) (has_type (vstd!seq.impl&%0.spec_index.? A& A&. self~2@ i~4@) A&)) :pattern ((vstd!seq.impl&%0.spec_index.? A& A&. self~2@ i~4@)) :qid internal_vstd!seq.impl&__0.spec_index.?_pre_post_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::subrange")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (start_inclusive~4@ Poly) (end_exclusive~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type start_inclusive~4@ INT) (has_type end_exclusive~6@ INT)) (has_type (vstd!seq.Seq.subrange.? A& A&. self~2@ start_inclusive~4@ end_exclusive~6@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.Seq.subrange.? A& A&. self~2@ start_inclusive~4@ end_exclusive~6@)) :qid internal_vstd!seq.Seq.subrange.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.subrange.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::add")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (rhs~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type rhs~4@ (TYPE%vstd!seq.Seq. A&))) (has_type (vstd!seq.Seq.add.? A& A&. self~2@ rhs~4@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.Seq.add.? A& A&. self~2@ rhs~4@)) :qid internal_vstd!seq.Seq.add.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.add.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::impl&%0::spec_add")
(assert (fuel_bool_default fuel%vstd!seq.impl&%0.spec_add.))
(assert (=> (fuel_bool fuel%vstd!seq.impl&%0.spec_add.) (forall ((A& Type) (A&. Type) (self~2@ Poly) (rhs~4@ Poly)) (! (= (vstd!seq.impl&%0.spec_add.? A& A&. self~2@ rhs~4@) (vstd!seq.Seq.add.? A& A&. self~2@ rhs~4@)) :pattern ((vstd!seq.impl&%0.spec_add.? A& A&. self~2@ rhs~4@)) :qid internal_vstd!seq.impl&__0.spec_add.?_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_add.?_definition))))
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (rhs~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type rhs~4@ (TYPE%vstd!seq.Seq. A&))) (has_type (vstd!seq.impl&%0.spec_add.? A& A&. self~2@ rhs~4@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.impl&%0.spec_add.? A& A&. self~2@ rhs~4@)) :qid internal_vstd!seq.impl&__0.spec_add.?_pre_post_definition :skolemid skolem_internal_vstd!seq.impl&__0.spec_add.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::pervasive::arbitrary")
(assert (forall ((A& Type) (A&. Type)) (! (has_type (vstd!pervasive.arbitrary.? A& A&.) A&) :pattern ((vstd!pervasive.arbitrary.? A& A&.)) :qid internal_vstd!pervasive.arbitrary.?_pre_post_definition :skolemid skolem_internal_vstd!pervasive.arbitrary.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::check_argument_is_seq")
(assert (fuel_bool_default fuel%vstd!seq_lib.check_argument_is_seq.))
(assert (=> (fuel_bool fuel%vstd!seq_lib.check_argument_is_seq.) (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (vstd!seq_lib.check_argument_is_seq.? A& A&. s~2@) s~2@) :pattern ((vstd!seq_lib.check_argument_is_seq.? A& A&. s~2@)) :qid internal_vstd!seq_lib.check_argument_is_seq.?_definition :skolemid skolem_internal_vstd!seq_lib.check_argument_is_seq.?_definition))))
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (=> (has_type s~2@ (TYPE%vstd!seq.Seq. A&)) (has_type (vstd!seq_lib.check_argument_is_seq.? A& A&. s~2@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq_lib.check_argument_is_seq.? A& A&. s~2@)) :qid internal_vstd!seq_lib.check_argument_is_seq.?_pre_post_definition :skolemid skolem_internal_vstd!seq_lib.check_argument_is_seq.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::empty")
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type)) (! (has_type (vstd!map.impl&%0.empty.? K& K&. V& V&.) (TYPE%vstd!map.Map. K& V&)) :pattern ((vstd!map.impl&%0.empty.? K& K&. V& V&.)) :qid internal_vstd!map.impl&__0.empty.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::mk_map")
(assert (forall ((A& Type) (A&. Type) (V& Type) (V&. Type) (F& Type) (F&. Type) (self~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type f~4@ F&)) (has_type (vstd!set.impl&%0.mk_map.? A& A&. V& V&. F& F&. self~2@ f~4@) (TYPE%vstd!map.Map. A& V&))) :pattern ((vstd!set.impl&%0.mk_map.? A& A&. V& V&. F& F&. self~2@ f~4@)) :qid internal_vstd!set.impl&__0.mk_map.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.mk_map.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::complement")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type (vstd!set.impl&%0.complement.? A& A&. self~2@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.complement.? A& A&. self~2@)) :qid internal_vstd!set.impl&__0.complement.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.complement.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::empty")
(assert (forall ((A& Type) (A&. Type)) (! (has_type (vstd!set.impl&%0.empty.? A& A&.) (TYPE%vstd!set.Set. A&)) :pattern ((vstd!set.impl&%0.empty.? A& A&.)) :qid internal_vstd!set.impl&__0.empty.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.empty.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::new")
(assert (forall ((A& Type) (A&. Type) (F& Type) (F&. Type) (f~2@ Poly)) (! (=> (has_type f~2@ F&) (has_type (vstd!set.impl&%0.new.? A& A&. F& F&. f~2@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.new.? A& A&. F& F&. f~2@)) :qid internal_vstd!set.impl&__0.new.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::new")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.new.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.new.) (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (impl%2& Type) (impl%2&. Type) (impl%3& Type) (impl%3&. Type) (fk~2@ Poly) (fv~4@ Poly)) (! (= (vstd!map.impl&%0.new.? K& K&. V& V&. impl%2& impl%2&. impl%3& impl%3&. fk~2@ fv~4@) (vstd!set.impl&%0.mk_map.? K& K&. V& V&. impl%3& impl%3&. (vstd!set.impl&%0.new.? K& K&. impl%2& impl%2&. fk~2@) fv~4@)) :pattern ((vstd!map.impl&%0.new.? K& K&. V& V&. impl%2& impl%2&. impl%3& impl%3&. fk~2@ fv~4@)) :qid internal_vstd!map.impl&__0.new.?_definition :skolemid skolem_internal_vstd!map.impl&__0.new.?_definition))))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (impl%2& Type) (impl%2&. Type) (impl%3& Type) (impl%3&. Type) (fk~2@ Poly) (fv~4@ Poly)) (! (=> (and (has_type fk~2@ impl%2&) (has_type fv~4@ impl%3&)) (has_type (vstd!map.impl&%0.new.? K& K&. V& V&. impl%2& impl%2&. impl%3& impl%3&. fk~2@ fv~4@) (TYPE%vstd!map.Map. K& V&))) :pattern ((vstd!map.impl&%0.new.? K& K&. V& V&. impl%2& impl%2&. impl%3& impl%3&. fk~2@ fv~4@)) :qid internal_vstd!map.impl&__0.new.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::dom")
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type (vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@) (TYPE%vstd!set.Set. K&))) :pattern ((vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@)) :qid internal_vstd!map.impl&__0.dom.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.dom.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::index")
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.index.? K& K&. V& V&. self~2@ key~4@) V&)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. self~2@ key~4@)) :qid internal_vstd!map.impl&__0.index.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::spec_index")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.spec_index.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.spec_index.) (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (= (vstd!map.impl&%0.spec_index.? K& K&. V& V&. self~2@ key~4@) (vstd!map.impl&%0.index.? K& K&. V& V&. self~2@ key~4@)) :pattern ((vstd!map.impl&%0.spec_index.? K& K&. V& V&. self~2@ key~4@)) :qid internal_vstd!map.impl&__0.spec_index.?_definition :skolemid skolem_internal_vstd!map.impl&__0.spec_index.?_definition))))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.spec_index.? K& K&. V& V&. self~2@ key~4@) V&)) :pattern ((vstd!map.impl&%0.spec_index.? K& K&. V& V&. self~2@ key~4@)) :qid internal_vstd!map.impl&__0.spec_index.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.spec_index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::insert")
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type key~4@ K&) (has_type value~6@ V&)) (has_type (vstd!map.impl&%0.insert.? K& K&. V& V&. self~2@ key~4@ value~6@) (TYPE%vstd!map.Map. K& V&))) :pattern ((vstd!map.impl&%0.insert.? K& K&. V& V&. self~2@ key~4@ value~6@)) :qid internal_vstd!map.impl&__0.insert.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.insert.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::remove")
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (key~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type key~4@ K&)) (has_type (vstd!map.impl&%0.remove.? K& K&. V& V&. self~2@ key~4@) (TYPE%vstd!map.Map. K& V&))) :pattern ((vstd!map.impl&%0.remove.? K& K&. V& V&. self~2@ key~4@)) :qid internal_vstd!map.impl&__0.remove.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.remove.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::contains_pair")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.contains_pair.))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.contains_pair.) (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (k~4@ Poly) (v~6@ Poly)) (! (= (vstd!map.impl&%0.contains_pair.? K& K&. V& V&. self~2@ k~4@ v~6@) (and (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@) k~4@) (= (vstd!map.impl&%0.index.? K& K&. V& V&. self~2@ k~4@) v~6@))) :pattern ((vstd!map.impl&%0.contains_pair.? K& K&. V& V&. self~2@ k~4@ v~6@)) :qid internal_vstd!map.impl&__0.contains_pair.?_definition :skolemid skolem_internal_vstd!map.impl&__0.contains_pair.?_definition))))
(set-info :comment ";; Function-Axioms vstd::map::impl&%0::union_prefer_right")
(assert (fuel_bool_default fuel%vstd!map.impl&%0.union_prefer_right.))
(declare-fun %%lambda%%0 (Type Type Poly Type Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Type) (%%hole%%4 Type) (%%hole%%5 Poly) (k~17$ Poly)) (! (= (%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k~17$) (B (or (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 k~17$) (vstd!set.impl&%0.contains.? %%hole%%3 %%hole%%4 %%hole%%5 k~17$)))) :pattern ((%%apply%%0 (%%lambda%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5) k~17$)))))
(declare-fun %%lambda%%1 (Type Type Poly Type Type Type Type Poly Type Type Type Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Type) (%%hole%%2 Poly) (%%hole%%3 Type) (%%hole%%4 Type) (%%hole%%5 Type) (%%hole%%6 Type) (%%hole%%7 Poly) (%%hole%%8 Type) (%%hole%%9 Type) (%%hole%%10 Type) (%%hole%%11 Type) (%%hole%%12 Poly) (k~44$ Poly)) (! (= (%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k~44$) (ite (vstd!set.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 k~44$) (vstd!map.impl&%0.index.? %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 k~44$) (vstd!map.impl&%0.index.? %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 k~44$))) :pattern ((%%apply%%0 (%%lambda%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) k~44$)))))
(assert (=> (fuel_bool fuel%vstd!map.impl&%0.union_prefer_right.) (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (m2~4@ Poly)) (! (= (vstd!map.impl&%0.union_prefer_right.? K& K&. V& V&. self~2@ m2~4@) (vstd!map.impl&%0.new.? K& K&. V& V&. (TYPE%fun%1. K& BOOL) (TYPE%fun%1. K&. BOOL) (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) (Poly%fun%1. (mk_fun (%%lambda%%0 K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. self~2@) K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4@)))) (Poly%fun%1. (mk_fun (%%lambda%%1 K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4@) K& K&. V& V&. m2~4@ K& K&. V& V&. self~2@))))) :pattern ((vstd!map.impl&%0.union_prefer_right.? K& K&. V& V&. self~2@ m2~4@)) :qid internal_vstd!map.impl&__0.union_prefer_right.?_definition :skolemid skolem_internal_vstd!map.impl&__0.union_prefer_right.?_definition))))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (self~2@ Poly) (m2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!map.Map. K& V&)) (has_type m2~4@ (TYPE%vstd!map.Map. K& V&))) (has_type (vstd!map.impl&%0.union_prefer_right.? K& K&. V& V&. self~2@ m2~4@) (TYPE%vstd!map.Map. K& V&))) :pattern ((vstd!map.impl&%0.union_prefer_right.? K& K&. V& V&. self~2@ m2~4@)) :qid internal_vstd!map.impl&__0.union_prefer_right.?_pre_post_definition :skolemid skolem_internal_vstd!map.impl&__0.union_prefer_right.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_index_decreases_finite")
(declare-fun ens%vstd!map.axiom_map_index_decreases_finite. (Type Type Type Type Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_index_decreases_finite. K& K&. V& V&. m~2@ key~4@) (height_lt (height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2@ key~4@)) (height m~2@))) :pattern ((ens%vstd!map.axiom_map_index_decreases_finite. K& K&. V& V&. m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_index_decreases_finite._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_index_decreases_finite._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key~4$ K&)) (=> (and (vstd!set.impl&%0.finite.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$)) (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key~4$)) (height_lt (height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key~4$)) (height m~2$)))) :pattern ((height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key~4$))) :qid user_vstd__map__axiom_map_index_decreases_finite_0 :skolemid skolem_user_vstd__map__axiom_map_index_decreases_finite_0)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_index_decreases_infinite")
(declare-fun ens%vstd!map.axiom_map_index_decreases_infinite. (Type Type Type Type Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_index_decreases_infinite. K& K&. V& V&. m~2@ key~4@) (height_lt (height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2@ key~4@)) (height (fun_from_recursive_field m~2@)))) :pattern ((ens%vstd!map.axiom_map_index_decreases_infinite. K& K&. V& V&. m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_index_decreases_infinite._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_index_decreases_infinite._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key~4$ K&)) (=> (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key~4$) (height_lt (height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key~4$)) (height (fun_from_recursive_field m~2$))))) :pattern ((height (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key~4$))) :qid user_vstd__map__axiom_map_index_decreases_infinite_1 :skolemid skolem_user_vstd__map__axiom_map_index_decreases_infinite_1)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_empty")
(declare-fun ens%vstd!map.axiom_map_empty. (Type Type Type Type) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type)) (! (= (ens%vstd!map.axiom_map_empty. K& K&. V& V&.) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.empty.? K& K&. V& V&.)) (vstd!set.impl&%0.empty.? K& K&.))) :pattern ((ens%vstd!map.axiom_map_empty. K& K&. V& V&.)) :qid internal_ens__vstd!map.axiom_map_empty._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_empty._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type)) (! (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.empty.? K& K&. V& V&.)) (vstd!set.impl&%0.empty.? K& K&.)) :pattern ((vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.empty.? K& K&. V& V&.))) :qid user_vstd__map__axiom_map_empty_2 :skolemid skolem_user_vstd__map__axiom_map_empty_2)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::insert")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type a~4@ A&)) (has_type (vstd!set.impl&%0.insert.? A& A&. self~2@ a~4@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.insert.? A& A&. self~2@ a~4@)) :qid internal_vstd!set.impl&__0.insert.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.insert.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_domain")
(declare-fun ens%vstd!map.axiom_map_insert_domain. (Type Type Type Type Poly Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_domain. K& K&. V& V&. m~2@ key~4@ value~6@) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2@ key~4@ value~6@)) (vstd!set.impl&%0.insert.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key~4@))) :pattern ((ens%vstd!map.axiom_map_insert_domain. K& K&. V& V&. m~2@ key~4@ value~6@)) :qid internal_ens__vstd!map.axiom_map_insert_domain._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_domain._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key~4$ Poly) (value~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key~4$ K&) (has_type value~6$ V&)) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key~4$ value~6$)) (vstd!set.impl&%0.insert.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key~4$))) :pattern ((vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key~4$ value~6$))) :qid user_vstd__map__axiom_map_insert_domain_3 :skolemid skolem_user_vstd__map__axiom_map_insert_domain_3)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_same")
(declare-fun ens%vstd!map.axiom_map_insert_same. (Type Type Type Type Poly Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly) (value~6@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_same. K& K&. V& V&. m~2@ key~4@ value~6@) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2@ key~4@ value~6@) key~4@) value~6@)) :pattern ((ens%vstd!map.axiom_map_insert_same. K& K&. V& V&. m~2@ key~4@ value~6@)) :qid internal_ens__vstd!map.axiom_map_insert_same._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_same._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key~4$ Poly) (value~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key~4$ K&) (has_type value~6$ V&)) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key~4$ value~6$) key~4$) value~6$)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key~4$ value~6$) key~4$)) :qid user_vstd__map__axiom_map_insert_same_4 :skolemid skolem_user_vstd__map__axiom_map_insert_same_4)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_insert_different")
(declare-fun ens%vstd!map.axiom_map_insert_different. (Type Type Type Type Poly Poly Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly) (value~8@ Poly)) (! (= (ens%vstd!map.axiom_map_insert_different. K& K&. V& V&. m~2@ key1~4@ key2~6@ value~8@) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2@ key2~6@ value~8@) key1~4@) (vstd!map.impl&%0.index.? K& K&. V& V&. m~2@ key1~4@))) :pattern ((ens%vstd!map.axiom_map_insert_different. K& K&. V& V&. m~2@ key1~4@ key2~6@ value~8@)) :qid internal_ens__vstd!map.axiom_map_insert_different._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_insert_different._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key1~4$ Poly) (key2~6$ Poly) (value~8$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key1~4$ K&) (has_type key2~6$ K&) (has_type value~8$ V&)) (=> (and (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key1~4$) (not (= key1~4$ key2~6$))) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key2~6$ value~8$) key1~4$) (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key1~4$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.insert.? K& K&. V& V&. m~2$ key2~6$ value~8$) key1~4$)) :qid user_vstd__map__axiom_map_insert_different_5 :skolemid skolem_user_vstd__map__axiom_map_insert_different_5)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::remove")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (a~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type a~4@ A&)) (has_type (vstd!set.impl&%0.remove.? A& A&. self~2@ a~4@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.remove.? A& A&. self~2@ a~4@)) :qid internal_vstd!set.impl&__0.remove.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.remove.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_remove_domain")
(declare-fun ens%vstd!map.axiom_map_remove_domain. (Type Type Type Type Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key~4@ Poly)) (! (= (ens%vstd!map.axiom_map_remove_domain. K& K&. V& V&. m~2@ key~4@) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2@ key~4@)) (vstd!set.impl&%0.remove.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2@) key~4@))) :pattern ((ens%vstd!map.axiom_map_remove_domain. K& K&. V& V&. m~2@ key~4@)) :qid internal_ens__vstd!map.axiom_map_remove_domain._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_remove_domain._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key~4$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key~4$ K&)) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2$ key~4$)) (vstd!set.impl&%0.remove.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key~4$))) :pattern ((vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2$ key~4$))) :qid user_vstd__map__axiom_map_remove_domain_6 :skolemid skolem_user_vstd__map__axiom_map_remove_domain_6)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_remove_different")
(declare-fun ens%vstd!map.axiom_map_remove_different. (Type Type Type Type Poly Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly) (key1~4@ Poly) (key2~6@ Poly)) (! (= (ens%vstd!map.axiom_map_remove_different. K& K&. V& V&. m~2@ key1~4@ key2~6@) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2@ key2~6@) key1~4@) (vstd!map.impl&%0.index.? K& K&. V& V&. m~2@ key1~4@))) :pattern ((ens%vstd!map.axiom_map_remove_different. K& K&. V& V&. m~2@ key1~4@ key2~6@)) :qid internal_ens__vstd!map.axiom_map_remove_different._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_remove_different._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2$ Poly) (key1~4$ Poly) (key2~6$ Poly)) (! (=> (and (has_type m~2$ (TYPE%vstd!map.Map. K& V&)) (has_type key1~4$ K&) (has_type key2~6$ K&)) (=> (and (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m~2$) key1~4$) (not (= key1~4$ key2~6$))) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2$ key2~6$) key1~4$) (vstd!map.impl&%0.index.? K& K&. V& V&. m~2$ key1~4$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!map.impl&%0.remove.? K& K&. V& V&. m~2$ key2~6$) key1~4$)) :qid user_vstd__map__axiom_map_remove_different_7 :skolemid skolem_user_vstd__map__axiom_map_remove_different_7)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_ext_equal")
(declare-fun ens%vstd!map.axiom_map_ext_equal. (Type Type Type Type Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m1~2@ Poly) (m2~4@ Poly)) (! (= (ens%vstd!map.axiom_map_ext_equal. K& K&. V& V&. m1~2@ m2~4@) (= (ext_eq false (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2@ m2~4@) (and (ext_eq false (TYPE%vstd!set.Set. K&) (TYPE%vstd!set.Set. K&.) (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2@) (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4@)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2@) k~47$) (= (vstd!map.impl&%0.index.? K& K&. V& V&. m1~2@ k~47$) (vstd!map.impl&%0.index.? K& K&. V& V&. m2~4@ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m1~2@ k~47$)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m2~4@ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_8 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_8))))) :pattern ((ens%vstd!map.axiom_map_ext_equal. K& K&. V& V&. m1~2@ m2~4@)) :qid internal_ens__vstd!map.axiom_map_ext_equal._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_ext_equal._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m1~2$ Poly) (m2~4$ Poly)) (! (=> (and (has_type m1~2$ (TYPE%vstd!map.Map. K& V&)) (has_type m2~4$ (TYPE%vstd!map.Map. K& V&))) (= (ext_eq false (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2$ m2~4$) (and (ext_eq false (TYPE%vstd!set.Set. K&) (TYPE%vstd!set.Set. K&.) (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2$) (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4$)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2$) k~47$) (= (vstd!map.impl&%0.index.? K& K&. V& V&. m1~2$ k~47$) (vstd!map.impl&%0.index.? K& K&. V& V&. m2~4$ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m1~2$ k~47$)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m2~4$ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_9 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_9))))) :pattern ((ext_eq false (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2$ m2~4$)) :qid user_vstd__map__axiom_map_ext_equal_10 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_10)))
(set-info :comment ";; Function-Axioms vstd::map::axiom_map_ext_equal_deep")
(declare-fun ens%vstd!map.axiom_map_ext_equal_deep. (Type Type Type Type Poly Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m1~2@ Poly) (m2~4@ Poly)) (! (= (ens%vstd!map.axiom_map_ext_equal_deep. K& K&. V& V&. m1~2@ m2~4@) (= (ext_eq true (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2@ m2~4@) (and (ext_eq true (TYPE%vstd!set.Set. K&) (TYPE%vstd!set.Set. K&.) (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2@) (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4@)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2@) k~47$) (ext_eq true V& V&. (vstd!map.impl&%0.index.? K& K&. V& V&. m1~2@ k~47$) (vstd!map.impl&%0.index.? K& K&. V& V&. m2~4@ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m1~2@ k~47$)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m2~4@ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_deep_11 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_11))))) :pattern ((ens%vstd!map.axiom_map_ext_equal_deep. K& K&. V& V&. m1~2@ m2~4@)) :qid internal_ens__vstd!map.axiom_map_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!map.axiom_map_ext_equal_deep._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m1~2$ Poly) (m2~4$ Poly)) (! (=> (and (has_type m1~2$ (TYPE%vstd!map.Map. K& V&)) (has_type m2~4$ (TYPE%vstd!map.Map. K& V&))) (= (ext_eq true (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2$ m2~4$) (and (ext_eq true (TYPE%vstd!set.Set. K&) (TYPE%vstd!set.Set. K&.) (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2$) (vstd!map.impl&%0.dom.? K& K&. V& V&. m2~4$)) (forall ((k~47$ Poly)) (! (=> (has_type k~47$ K&) (=> (vstd!set.impl&%0.contains.? K& K&. (vstd!map.impl&%0.dom.? K& K&. V& V&. m1~2$) k~47$) (ext_eq true V& V&. (vstd!map.impl&%0.index.? K& K&. V& V&. m1~2$ k~47$) (vstd!map.impl&%0.index.? K& K&. V& V&. m2~4$ k~47$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m1~2$ k~47$)) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. m2~4$ k~47$)) :qid user_vstd__map__axiom_map_ext_equal_deep_12 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_12))))) :pattern ((ext_eq true (TYPE%vstd!map.Map. K& V&) (TYPE%vstd!map.Map. K&. V&.) m1~2$ m2~4$)) :qid user_vstd__map__axiom_map_ext_equal_deep_13 :skolemid skolem_user_vstd__map__axiom_map_ext_equal_deep_13)))
(set-info :comment ";; Function-Axioms vstd::map::check_argument_is_map")
(assert (fuel_bool_default fuel%vstd!map.check_argument_is_map.))
(assert (=> (fuel_bool fuel%vstd!map.check_argument_is_map.) (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly)) (! (= (vstd!map.check_argument_is_map.? K& K&. V& V&. m~2@) m~2@) :pattern ((vstd!map.check_argument_is_map.? K& K&. V& V&. m~2@)) :qid internal_vstd!map.check_argument_is_map.?_definition :skolemid skolem_internal_vstd!map.check_argument_is_map.?_definition))))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (m~2@ Poly)) (! (=> (has_type m~2@ (TYPE%vstd!map.Map. K& V&)) (has_type (vstd!map.check_argument_is_map.? K& K&. V& V&. m~2@) (TYPE%vstd!map.Map. K& V&))) :pattern ((vstd!map.check_argument_is_map.? K& K&. V& V&. m~2@)) :qid internal_vstd!map.check_argument_is_map.?_pre_post_definition :skolemid skolem_internal_vstd!map.check_argument_is_map.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::Seq::new")
(assert (forall ((A& Type) (A&. Type) (impl%1& Type) (impl%1&. Type) (len~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type len~2@ NAT) (has_type f~4@ impl%1&)) (has_type (vstd!seq.Seq.new.? A& A&. impl%1& impl%1&. len~2@ f~4@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq.Seq.new.? A& A&. impl%1& impl%1&. len~2@ f~4@)) :qid internal_vstd!seq.Seq.new.?_pre_post_definition :skolemid skolem_internal_vstd!seq.Seq.new.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_index_decreases")
(declare-fun ens%vstd!seq.axiom_seq_index_decreases. (Type Type Poly Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int)) (! (= (ens%vstd!seq.axiom_seq_index_decreases. A& A&. s~2@ i~4@) (height_lt (height (vstd!seq.Seq.index.? A& A&. s~2@ (I i~4@))) (height s~2@))) :pattern ((ens%vstd!seq.axiom_seq_index_decreases. A& A&. s~2@ i~4@)) :qid internal_ens__vstd!seq.axiom_seq_index_decreases._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_index_decreases._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (i~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type i~4$ INT)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A& A&. s~2$))) (height_lt (height (vstd!seq.Seq.index.? A& A&. s~2$ i~4$)) (height s~2$)))) :pattern ((height (vstd!seq.Seq.index.? A& A&. s~2$ i~4$))) :qid user_vstd__seq__axiom_seq_index_decreases_14 :skolemid skolem_user_vstd__seq__axiom_seq_index_decreases_14)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_empty")
(declare-fun ens%vstd!seq.axiom_seq_empty. (Type Type) Bool)
(assert (forall ((A& Type) (A&. Type)) (! (= (ens%vstd!seq.axiom_seq_empty. A& A&.) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.empty.? A& A&.)) 0)) :pattern ((ens%vstd!seq.axiom_seq_empty. A& A&.)) :qid internal_ens__vstd!seq.axiom_seq_empty._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_empty._definition)))
(assert (forall ((A& Type) (A&. Type)) (! (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.empty.? A& A&.)) 0) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.empty.? A& A&.))) :qid user_vstd__seq__axiom_seq_empty_15 :skolemid skolem_user_vstd__seq__axiom_seq_empty_15)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_new_len")
(declare-fun ens%vstd!seq.axiom_seq_new_len. (Type Type Int %%Function%%) Bool)
(assert (forall ((A& Type) (A&. Type) (len~2@ Int) (f~4@ %%Function%%)) (! (= (ens%vstd!seq.axiom_seq_new_len. A& A&. len~2@ f~4@) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) (I len~2@) (Poly%fun%1. f~4@))) len~2@)) :pattern ((ens%vstd!seq.axiom_seq_new_len. A& A&. len~2@ f~4@)) :qid internal_ens__vstd!seq.axiom_seq_new_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_new_len._definition)))
(assert (forall ((A& Type) (A&. Type) (len~2$ Poly) (f~4$ Poly)) (! (=> (and (has_type len~2$ NAT) (has_type f~4$ (TYPE%fun%1. INT A&))) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) len~2$ f~4$)) (%I len~2$))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) len~2$ f~4$))) :qid user_vstd__seq__axiom_seq_new_len_16 :skolemid skolem_user_vstd__seq__axiom_seq_new_len_16)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_new_index")
(declare-fun ens%vstd!seq.axiom_seq_new_index. (Type Type Int %%Function%% Int) Bool)
(assert (forall ((A& Type) (A&. Type) (len~2@ Int) (f~4@ %%Function%%) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_new_index. A& A&. len~2@ f~4@ i~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) (I len~2@) (Poly%fun%1. f~4@)) (I i~6@)) (%%apply%%0 f~4@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_new_index. A& A&. len~2@ f~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_new_index._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_new_index._definition)))
(assert (forall ((A& Type) (A&. Type) (len~2$ Poly) (f~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type len~2$ NAT) (has_type f~4$ (TYPE%fun%1. INT A&)) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (%I len~2$))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) len~2$ f~4$) i~6$) (%%apply%%0 (%Poly%fun%1. f~4$) i~6$)))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.new.? A& A&. (TYPE%fun%1. INT A&) (TYPE%fun%1. INT A&.) len~2$ f~4$) i~6$)) :qid user_vstd__seq__axiom_seq_new_index_17 :skolemid skolem_user_vstd__seq__axiom_seq_new_index_17)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_len")
(declare-fun ens%vstd!seq.axiom_seq_push_len. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_push_len. A& A&. s~2@ a~4@) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2@ a~4@)) (nClip (+ (vstd!seq.Seq.len.? A& A&. s~2@) 1)))) :pattern ((ens%vstd!seq.axiom_seq_push_len. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!seq.axiom_seq_push_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type a~4$ A&)) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$)) (nClip (+ (vstd!seq.Seq.len.? A& A&. s~2$) 1)))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$))) :qid user_vstd__seq__axiom_seq_push_len_18 :skolemid skolem_user_vstd__seq__axiom_seq_push_len_18)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_index_same")
(declare-fun ens%vstd!seq.axiom_seq_push_index_same. (Type Type Poly Poly Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_push_index_same. A& A&. s~2@ a~4@ i~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2@ a~4@) (I i~6@)) a~4@)) :pattern ((ens%vstd!seq.axiom_seq_push_index_same. A& A&. s~2@ a~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_push_index_same._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_index_same._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type a~4$ A&) (has_type i~6$ INT)) (=> (= (%I i~6$) (vstd!seq.Seq.len.? A& A&. s~2$)) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$) i~6$) a~4$))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$) i~6$)) :qid user_vstd__seq__axiom_seq_push_index_same_19 :skolemid skolem_user_vstd__seq__axiom_seq_push_index_same_19)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_push_index_different")
(declare-fun ens%vstd!seq.axiom_seq_push_index_different. (Type Type Poly Poly Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_push_index_different. A& A&. s~2@ a~4@ i~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2@ a~4@) (I i~6@)) (vstd!seq.Seq.index.? A& A&. s~2@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_push_index_different. A& A&. s~2@ a~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_push_index_different._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_push_index_different._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type a~4$ A&) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (vstd!seq.Seq.len.? A& A&. s~2$))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$) i~6$) (vstd!seq.Seq.index.? A& A&. s~2$ i~6$)))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.push.? A& A&. s~2$ a~4$) i~6$)) :qid user_vstd__seq__axiom_seq_push_index_different_20 :skolemid skolem_user_vstd__seq__axiom_seq_push_index_different_20)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_len")
(declare-fun ens%vstd!seq.axiom_seq_update_len. (Type Type Poly Int Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_len. A& A&. s~2@ i~4@ a~6@) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2@ (I i~4@) a~6@)) (vstd!seq.Seq.len.? A& A&. s~2@))) :pattern ((ens%vstd!seq.axiom_seq_update_len. A& A&. s~2@ i~4@ a~6@)) :qid internal_ens__vstd!seq.axiom_seq_update_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (i~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type i~4$ INT) (has_type a~6$ A&)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A& A&. s~2$))) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i~4$ a~6$)) (vstd!seq.Seq.len.? A& A&. s~2$)))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i~4$ a~6$))) :qid user_vstd__seq__axiom_seq_update_len_21 :skolemid skolem_user_vstd__seq__axiom_seq_update_len_21)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_same")
(declare-fun ens%vstd!seq.axiom_seq_update_same. (Type Type Poly Int Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i~4@ Int) (a~6@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_same. A& A&. s~2@ i~4@ a~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2@ (I i~4@) a~6@) (I i~4@)) a~6@)) :pattern ((ens%vstd!seq.axiom_seq_update_same. A& A&. s~2@ i~4@ a~6@)) :qid internal_ens__vstd!seq.axiom_seq_update_same._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_same._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (i~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type i~4$ INT) (has_type a~6$ A&)) (=> (and (<= 0 (%I i~4$)) (< (%I i~4$) (vstd!seq.Seq.len.? A& A&. s~2$))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i~4$ a~6$) i~4$) a~6$))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i~4$ a~6$) i~4$)) :qid user_vstd__seq__axiom_seq_update_same_22 :skolemid skolem_user_vstd__seq__axiom_seq_update_same_22)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_update_different")
(declare-fun ens%vstd!seq.axiom_seq_update_different. (Type Type Poly Int Int Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (i1~4@ Int) (i2~6@ Int) (a~8@ Poly)) (! (= (ens%vstd!seq.axiom_seq_update_different. A& A&. s~2@ i1~4@ i2~6@ a~8@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2@ (I i2~6@) a~8@) (I i1~4@)) (vstd!seq.Seq.index.? A& A&. s~2@ (I i1~4@)))) :pattern ((ens%vstd!seq.axiom_seq_update_different. A& A&. s~2@ i1~4@ i2~6@ a~8@)) :qid internal_ens__vstd!seq.axiom_seq_update_different._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_update_different._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (i1~4$ Poly) (i2~6$ Poly) (a~8$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type i1~4$ INT) (has_type i2~6$ INT) (has_type a~8$ A&)) (=> (and (and (and (<= 0 (%I i1~4$)) (< (%I i1~4$) (vstd!seq.Seq.len.? A& A&. s~2$))) (and (<= 0 (%I i2~6$)) (< (%I i2~6$) (vstd!seq.Seq.len.? A& A&. s~2$)))) (not (= i1~4$ i2~6$))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i2~6$ a~8$) i1~4$) (vstd!seq.Seq.index.? A& A&. s~2$ i1~4$)))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.update.? A& A&. s~2$ i2~6$ a~8$) i1~4$)) :qid user_vstd__seq__axiom_seq_update_different_23 :skolemid skolem_user_vstd__seq__axiom_seq_update_different_23)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_ext_equal")
(declare-fun ens%vstd!seq.axiom_seq_ext_equal. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_ext_equal. A& A&. s1~2@ s2~4@) (= (ext_eq false (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2@ s2~4@) (and (= (vstd!seq.Seq.len.? A& A&. s1~2@) (vstd!seq.Seq.len.? A& A&. s2~4@)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A& A&. s1~2@))) (= (vstd!seq.Seq.index.? A& A&. s1~2@ i~47$) (vstd!seq.Seq.index.? A& A&. s2~4@ i~47$)))) :pattern ((vstd!seq.Seq.index.? A& A&. s1~2@ i~47$)) :pattern ((vstd!seq.Seq.index.? A& A&. s2~4@ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_24 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_24))))) :pattern ((ens%vstd!seq.axiom_seq_ext_equal. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_ext_equal._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_ext_equal._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&))) (= (ext_eq false (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2$ s2~4$) (and (= (vstd!seq.Seq.len.? A& A&. s1~2$) (vstd!seq.Seq.len.? A& A&. s2~4$)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A& A&. s1~2$))) (= (vstd!seq.Seq.index.? A& A&. s1~2$ i~47$) (vstd!seq.Seq.index.? A& A&. s2~4$ i~47$)))) :pattern ((vstd!seq.Seq.index.? A& A&. s1~2$ i~47$)) :pattern ((vstd!seq.Seq.index.? A& A&. s2~4$ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_25 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_25))))) :pattern ((ext_eq false (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2$ s2~4$)) :qid user_vstd__seq__axiom_seq_ext_equal_26 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_26)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_ext_equal_deep")
(declare-fun ens%vstd!seq.axiom_seq_ext_equal_deep. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_ext_equal_deep. A& A&. s1~2@ s2~4@) (= (ext_eq true (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2@ s2~4@) (and (= (vstd!seq.Seq.len.? A& A&. s1~2@) (vstd!seq.Seq.len.? A& A&. s2~4@)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A& A&. s1~2@))) (ext_eq true A& A&. (vstd!seq.Seq.index.? A& A&. s1~2@ i~47$) (vstd!seq.Seq.index.? A& A&. s2~4@ i~47$)))) :pattern ((vstd!seq.Seq.index.? A& A&. s1~2@ i~47$)) :pattern ((vstd!seq.Seq.index.? A& A&. s2~4@ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_27 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_27))))) :pattern ((ens%vstd!seq.axiom_seq_ext_equal_deep. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_ext_equal_deep._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&))) (= (ext_eq true (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2$ s2~4$) (and (= (vstd!seq.Seq.len.? A& A&. s1~2$) (vstd!seq.Seq.len.? A& A&. s2~4$)) (forall ((i~47$ Poly)) (! (=> (has_type i~47$ INT) (=> (and (<= 0 (%I i~47$)) (< (%I i~47$) (vstd!seq.Seq.len.? A& A&. s1~2$))) (ext_eq true A& A&. (vstd!seq.Seq.index.? A& A&. s1~2$ i~47$) (vstd!seq.Seq.index.? A& A&. s2~4$ i~47$)))) :pattern ((vstd!seq.Seq.index.? A& A&. s1~2$ i~47$)) :pattern ((vstd!seq.Seq.index.? A& A&. s2~4$ i~47$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_28 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_28))))) :pattern ((ext_eq true (TYPE%vstd!seq.Seq. A&) (TYPE%vstd!seq.Seq. A&.) s1~2$ s2~4$)) :qid user_vstd__seq__axiom_seq_ext_equal_deep_29 :skolemid skolem_user_vstd__seq__axiom_seq_ext_equal_deep_29)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_subrange_len")
(declare-fun ens%vstd!seq.axiom_seq_subrange_len. (Type Type Poly Int Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_subrange_len. A& A&. s~2@ j~4@ k~6@) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2@ (I j~4@) (I k~6@))) (- k~6@ j~4@))) :pattern ((ens%vstd!seq.axiom_seq_subrange_len. A& A&. s~2@ j~4@ k~6@)) :qid internal_ens__vstd!seq.axiom_seq_subrange_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_subrange_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (j~4$ Poly) (k~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type j~4$ INT) (has_type k~6$ INT)) (=> (and (and (<= 0 (%I j~4$)) (<= (%I j~4$) (%I k~6$))) (<= (%I k~6$) (vstd!seq.Seq.len.? A& A&. s~2$))) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2$ j~4$ k~6$)) (- (%I k~6$) (%I j~4$))))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2$ j~4$ k~6$))) :qid user_vstd__seq__axiom_seq_subrange_len_30 :skolemid skolem_user_vstd__seq__axiom_seq_subrange_len_30)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_subrange_index")
(declare-fun ens%vstd!seq.axiom_seq_subrange_index. (Type Type Poly Int Int Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (j~4@ Int) (k~6@ Int) (i~8@ Int)) (! (= (ens%vstd!seq.axiom_seq_subrange_index. A& A&. s~2@ j~4@ k~6@ i~8@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2@ (I j~4@) (I k~6@)) (I i~8@)) (vstd!seq.Seq.index.? A& A&. s~2@ (I (+ i~8@ j~4@))))) :pattern ((ens%vstd!seq.axiom_seq_subrange_index. A& A&. s~2@ j~4@ k~6@ i~8@)) :qid internal_ens__vstd!seq.axiom_seq_subrange_index._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_subrange_index._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (j~4$ Poly) (k~6$ Poly) (i~8$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!seq.Seq. A&)) (has_type j~4$ INT) (has_type k~6$ INT) (has_type i~8$ INT)) (=> (and (and (and (<= 0 (%I j~4$)) (<= (%I j~4$) (%I k~6$))) (<= (%I k~6$) (vstd!seq.Seq.len.? A& A&. s~2$))) (and (<= 0 (%I i~8$)) (< (%I i~8$) (- (%I k~6$) (%I j~4$))))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2$ j~4$ k~6$) i~8$) (vstd!seq.Seq.index.? A& A&. s~2$ (I (+ (%I i~8$) (%I j~4$))))))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.subrange.? A& A&. s~2$ j~4$ k~6$) i~8$)) :qid user_vstd__seq__axiom_seq_subrange_index_31 :skolemid skolem_user_vstd__seq__axiom_seq_subrange_index_31)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_len")
(declare-fun ens%vstd!seq.axiom_seq_add_len. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!seq.axiom_seq_add_len. A& A&. s1~2@ s2~4@) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2@ s2~4@)) (nClip (+ (vstd!seq.Seq.len.? A& A&. s1~2@) (vstd!seq.Seq.len.? A& A&. s2~4@))))) :pattern ((ens%vstd!seq.axiom_seq_add_len. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!seq.axiom_seq_add_len._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&))) (= (vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$)) (nClip (+ (vstd!seq.Seq.len.? A& A&. s1~2$) (vstd!seq.Seq.len.? A& A&. s2~4$))))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$))) :qid user_vstd__seq__axiom_seq_add_len_32 :skolemid skolem_user_vstd__seq__axiom_seq_add_len_32)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_index1")
(declare-fun ens%vstd!seq.axiom_seq_add_index1. (Type Type Poly Poly Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_add_index1. A& A&. s1~2@ s2~4@ i~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2@ s2~4@) (I i~6@)) (vstd!seq.Seq.index.? A& A&. s1~2@ (I i~6@)))) :pattern ((ens%vstd!seq.axiom_seq_add_index1. A& A&. s1~2@ s2~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_add_index1._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_index1._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&)) (has_type i~6$ INT)) (=> (and (<= 0 (%I i~6$)) (< (%I i~6$) (vstd!seq.Seq.len.? A& A&. s1~2$))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$) i~6$) (vstd!seq.Seq.index.? A& A&. s1~2$ i~6$)))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$) i~6$)) :qid user_vstd__seq__axiom_seq_add_index1_33 :skolemid skolem_user_vstd__seq__axiom_seq_add_index1_33)))
(set-info :comment ";; Function-Axioms vstd::seq::axiom_seq_add_index2")
(declare-fun ens%vstd!seq.axiom_seq_add_index2. (Type Type Poly Poly Int) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (i~6@ Int)) (! (= (ens%vstd!seq.axiom_seq_add_index2. A& A&. s1~2@ s2~4@ i~6@) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2@ s2~4@) (I i~6@)) (vstd!seq.Seq.index.? A& A&. s2~4@ (I (- i~6@ (vstd!seq.Seq.len.? A& A&. s1~2@)))))) :pattern ((ens%vstd!seq.axiom_seq_add_index2. A& A&. s1~2@ s2~4@ i~6@)) :qid internal_ens__vstd!seq.axiom_seq_add_index2._definition :skolemid skolem_internal_ens__vstd!seq.axiom_seq_add_index2._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly) (i~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!seq.Seq. A&)) (has_type s2~4$ (TYPE%vstd!seq.Seq. A&)) (has_type i~6$ INT)) (=> (and (<= 0 (vstd!seq.Seq.len.? A& A&. s1~2$)) (< (%I i~6$) (+ (vstd!seq.Seq.len.? A& A&. s1~2$) (vstd!seq.Seq.len.? A& A&. s2~4$)))) (= (vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$) i~6$) (vstd!seq.Seq.index.? A& A&. s2~4$ (I (- (%I i~6$) (vstd!seq.Seq.len.? A& A&. s1~2$))))))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq.Seq.add.? A& A&. s1~2$ s2~4$) i~6$)) :qid user_vstd__seq__axiom_seq_add_index2_34 :skolemid skolem_user_vstd__seq__axiom_seq_add_index2_34)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::filter")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (pred~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type pred~4@ (TYPE%fun%1. A& BOOL))) (has_type (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ pred~4@) (TYPE%vstd!seq.Seq. A&))) :pattern ((vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ pred~4@)) :qid internal_vstd!seq_lib.impl&__0.filter.?_pre_post_definition :skolemid skolem_internal_vstd!seq_lib.impl&__0.filter.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::contains")
(assert (fuel_bool_default fuel%vstd!seq_lib.impl&%0.contains.))
(assert (=> (fuel_bool fuel%vstd!seq_lib.impl&%0.contains.) (forall ((A& Type) (A&. Type) (self~2@ Poly) (needle~4@ Poly)) (! (= (vstd!seq_lib.impl&%0.contains.? A& A&. self~2@ needle~4@) (exists ((i~12$ Poly)) (! (and (has_type i~12$ INT) (and (and (<= 0 (%I i~12$)) (< (%I i~12$) (vstd!seq.Seq.len.? A& A&. self~2@))) (= (vstd!seq.Seq.index.? A& A&. self~2@ i~12$) needle~4@))) :pattern ((vstd!seq.Seq.index.? A& A&. self~2@ i~12$)) :qid user_vstd__seq_lib__impl&%0__contains_35 :skolemid skolem_user_vstd__seq_lib__impl&%0__contains_35))) :pattern ((vstd!seq_lib.impl&%0.contains.? A& A&. self~2@ needle~4@)) :qid internal_vstd!seq_lib.impl&__0.contains.?_definition :skolemid skolem_internal_vstd!seq_lib.impl&__0.contains.?_definition))))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::filter_lemma_broadcast")
(declare-fun ens%vstd!seq_lib.impl&%0.filter_lemma_broadcast. (Type Type Poly %%Function%%) Bool)
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (pred~4@ %%Function%%)) (! (= (ens%vstd!seq_lib.impl&%0.filter_lemma_broadcast. A& A&. self~2@ pred~4@) (and (forall ((i~18$ Poly)) (! (=> (has_type i~18$ INT) (=> (and (<= 0 (%I i~18$)) (< (%I i~18$) (vstd!seq.Seq.len.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@))))) (%B (%%apply%%0 pred~4@ (vstd!seq.Seq.index.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@)) i~18$))))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@)) i~18$)) :qid user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_36 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_36)) (forall ((i~82$ Poly)) (! (=> (has_type i~82$ INT) (=> (and (and (<= 0 (%I i~82$)) (< (%I i~82$) (vstd!seq.Seq.len.? A& A&. self~2@))) (%B (%%apply%%0 pred~4@ (vstd!seq.Seq.index.? A& A&. self~2@ i~82$)))) (vstd!seq_lib.impl&%0.contains.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@)) (vstd!seq.Seq.index.? A& A&. self~2@ i~82$)))) :pattern ((vstd!seq_lib.impl&%0.contains.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@)) (vstd!seq.Seq.index.? A& A&. self~2@ i~82$))) :qid user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_37 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_37)) (<= (vstd!seq.Seq.len.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2@ (Poly%fun%1. pred~4@))) (vstd!seq.Seq.len.? A& A&. self~2@)))) :pattern ((ens%vstd!seq_lib.impl&%0.filter_lemma_broadcast. A& A&. self~2@ pred~4@)) :qid internal_ens__vstd!seq_lib.impl&__0.filter_lemma_broadcast._definition :skolemid skolem_internal_ens__vstd!seq_lib.impl&__0.filter_lemma_broadcast._definition)))
(assert (forall ((A& Type) (A&. Type) (self~2$ Poly) (pred~4$ Poly)) (! (=> (and (has_type self~2$ (TYPE%vstd!seq.Seq. A&)) (has_type pred~4$ (TYPE%fun%1. A& BOOL))) (and (and (forall ((i~18$ Poly)) (! (=> (has_type i~18$ INT) (=> (and (<= 0 (%I i~18$)) (< (%I i~18$) (vstd!seq.Seq.len.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$)))) (%B (%%apply%%0 (%Poly%fun%1. pred~4$) (vstd!seq.Seq.index.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$) i~18$))))) :pattern ((vstd!seq.Seq.index.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$) i~18$)) :qid user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_38 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_38)) (forall ((i~82$ Poly)) (! (=> (has_type i~82$ INT) (=> (and (and (<= 0 (%I i~82$)) (< (%I i~82$) (vstd!seq.Seq.len.? A& A&. self~2$))) (%B (%%apply%%0 (%Poly%fun%1. pred~4$) (vstd!seq.Seq.index.? A& A&. self~2$ i~82$)))) (vstd!seq_lib.impl&%0.contains.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$) (vstd!seq.Seq.index.? A& A&. self~2$ i~82$)))) :pattern ((vstd!seq_lib.impl&%0.contains.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$) (vstd!seq.Seq.index.? A& A&. self~2$ i~82$))) :qid user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_39 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_39))) (<= (vstd!seq.Seq.len.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$)) (vstd!seq.Seq.len.? A& A&. self~2$)))) :pattern ((vstd!seq.Seq.len.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. self~2$ pred~4$))) :qid user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_40 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_lemma_broadcast_40)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::filter_distributes_over_add_broacast")
(declare-fun ens%vstd!seq_lib.impl&%0.filter_distributes_over_add_broacast. (Type Type Poly Poly %%Function%%) Bool)
(assert (forall ((A& Type) (A&. Type) (a~2@ Poly) (b~4@ Poly) (pred~6@ %%Function%%)) (! (= (ens%vstd!seq_lib.impl&%0.filter_distributes_over_add_broacast. A& A&. a~2@ b~4@ pred~6@) (= (vstd!seq_lib.impl&%0.filter.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2@ b~4@) (Poly%fun%1. pred~6@)) (vstd!seq.Seq.add.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. a~2@ (Poly%fun%1. pred~6@)) (vstd!seq_lib.impl&%0.filter.? A& A&. b~4@ (Poly%fun%1. pred~6@))))) :pattern ((ens%vstd!seq_lib.impl&%0.filter_distributes_over_add_broacast. A& A&. a~2@ b~4@ pred~6@)) :qid internal_ens__vstd!seq_lib.impl&__0.filter_distributes_over_add_broacast._definition :skolemid skolem_internal_ens__vstd!seq_lib.impl&__0.filter_distributes_over_add_broacast._definition)))
(assert (forall ((A& Type) (A&. Type) (a~2$ Poly) (b~4$ Poly) (pred~6$ Poly)) (! (=> (and (has_type a~2$ (TYPE%vstd!seq.Seq. A&)) (has_type b~4$ (TYPE%vstd!seq.Seq. A&)) (has_type pred~6$ (TYPE%fun%1. A& BOOL))) (= (vstd!seq_lib.impl&%0.filter.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2$ b~4$) pred~6$) (vstd!seq.Seq.add.? A& A&. (vstd!seq_lib.impl&%0.filter.? A& A&. a~2$ pred~6$) (vstd!seq_lib.impl&%0.filter.? A& A&. b~4$ pred~6$)))) :pattern ((vstd!seq_lib.impl&%0.filter.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2$ b~4$) pred~6$)) :qid user_vstd__seq_lib__impl&%0__filter_distributes_over_add_broacast_41 :skolemid skolem_user_vstd__seq_lib__impl&%0__filter_distributes_over_add_broacast_41)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::add_empty_broacast")
(declare-fun ens%vstd!seq_lib.impl&%0.add_empty_broacast. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (a~2@ Poly) (b~4@ Poly)) (! (= (ens%vstd!seq_lib.impl&%0.add_empty_broacast. A& A&. a~2@ b~4@) (=> (= (vstd!seq.Seq.len.? A& A&. b~4@) 0) (= (vstd!seq.Seq.add.? A& A&. a~2@ b~4@) a~2@))) :pattern ((ens%vstd!seq_lib.impl&%0.add_empty_broacast. A& A&. a~2@ b~4@)) :qid internal_ens__vstd!seq_lib.impl&__0.add_empty_broacast._definition :skolemid skolem_internal_ens__vstd!seq_lib.impl&__0.add_empty_broacast._definition)))
(assert (forall ((A& Type) (A&. Type) (a~2$ Poly) (b~4$ Poly)) (! (=> (and (has_type a~2$ (TYPE%vstd!seq.Seq. A&)) (has_type b~4$ (TYPE%vstd!seq.Seq. A&))) (=> (= (vstd!seq.Seq.len.? A& A&. b~4$) 0) (= (vstd!seq.Seq.add.? A& A&. a~2$ b~4$) a~2$))) :pattern ((vstd!seq.Seq.add.? A& A&. a~2$ b~4$)) :qid user_vstd__seq_lib__impl&%0__add_empty_broacast_42 :skolemid skolem_user_vstd__seq_lib__impl&%0__add_empty_broacast_42)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::push_distributes_over_add_broacast")
(declare-fun ens%vstd!seq_lib.impl&%0.push_distributes_over_add_broacast. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (a~2@ Poly) (b~4@ Poly) (elt~6@ Poly)) (! (= (ens%vstd!seq_lib.impl&%0.push_distributes_over_add_broacast. A& A&. a~2@ b~4@ elt~6@) (= (vstd!seq.Seq.push.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2@ b~4@) elt~6@) (vstd!seq.Seq.add.? A& A&. a~2@ (vstd!seq.Seq.push.? A& A&. b~4@ elt~6@)))) :pattern ((ens%vstd!seq_lib.impl&%0.push_distributes_over_add_broacast. A& A&. a~2@ b~4@ elt~6@)) :qid internal_ens__vstd!seq_lib.impl&__0.push_distributes_over_add_broacast._definition :skolemid skolem_internal_ens__vstd!seq_lib.impl&__0.push_distributes_over_add_broacast._definition)))
(assert (forall ((A& Type) (A&. Type) (a~2$ Poly) (b~4$ Poly) (elt~6$ Poly)) (! (=> (and (has_type a~2$ (TYPE%vstd!seq.Seq. A&)) (has_type b~4$ (TYPE%vstd!seq.Seq. A&)) (has_type elt~6$ A&)) (= (vstd!seq.Seq.push.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2$ b~4$) elt~6$) (vstd!seq.Seq.add.? A& A&. a~2$ (vstd!seq.Seq.push.? A& A&. b~4$ elt~6$)))) :pattern ((vstd!seq.Seq.push.? A& A&. (vstd!seq.Seq.add.? A& A&. a~2$ b~4$) elt~6$)) :pattern ((vstd!seq.Seq.add.? A& A&. a~2$ (vstd!seq.Seq.push.? A& A&. b~4$ elt~6$))) :qid user_vstd__seq_lib__impl&%0__push_distributes_over_add_broacast_43 :skolemid skolem_user_vstd__seq_lib__impl&%0__push_distributes_over_add_broacast_43)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::impl&%0::to_set")
(assert (fuel_bool_default fuel%vstd!seq_lib.impl&%0.to_set.))
(declare-fun %%lambda%%2 (Type Type Poly) %%Function%%)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Type) (%%hole%%2 Poly) (a~15$ Poly)) (! (= (%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2) a~15$) (B (vstd!seq_lib.impl&%0.contains.? %%hole%%0 %%hole%%1 %%hole%%2 a~15$))) :pattern ((%%apply%%0 (%%lambda%%2 %%hole%%0 %%hole%%1 %%hole%%2) a~15$)))))
(assert (=> (fuel_bool fuel%vstd!seq_lib.impl&%0.to_set.) (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (= (vstd!seq_lib.impl&%0.to_set.? A& A&. self~2@) (vstd!set.impl&%0.new.? A& A&. (TYPE%fun%1. A& BOOL) (TYPE%fun%1. A&. BOOL) (Poly%fun%1. (mk_fun (%%lambda%%2 A& A&. self~2@))))) :pattern ((vstd!seq_lib.impl&%0.to_set.? A& A&. self~2@)) :qid internal_vstd!seq_lib.impl&__0.to_set.?_definition :skolemid skolem_internal_vstd!seq_lib.impl&__0.to_set.?_definition))))
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!seq.Seq. A&)) (has_type (vstd!seq_lib.impl&%0.to_set.? A& A&. self~2@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!seq_lib.impl&%0.to_set.? A& A&. self~2@)) :qid internal_vstd!seq_lib.impl&__0.to_set.?_pre_post_definition :skolemid skolem_internal_vstd!seq_lib.impl&__0.to_set.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::seq_lib::seq_to_set_is_finite_broadcast")
(declare-fun ens%vstd!seq_lib.seq_to_set_is_finite_broadcast. (Type Type Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (seq~2@ Poly)) (! (= (ens%vstd!seq_lib.seq_to_set_is_finite_broadcast. A& A&. seq~2@) (vstd!set.impl&%0.finite.? A& A&. (vstd!seq_lib.impl&%0.to_set.? A& A&. seq~2@))) :pattern ((ens%vstd!seq_lib.seq_to_set_is_finite_broadcast. A& A&. seq~2@)) :qid internal_ens__vstd!seq_lib.seq_to_set_is_finite_broadcast._definition :skolemid skolem_internal_ens__vstd!seq_lib.seq_to_set_is_finite_broadcast._definition)))
(assert (forall ((A& Type) (A&. Type) (seq~2$ Poly)) (! (=> (has_type seq~2$ (TYPE%vstd!seq.Seq. A&)) (vstd!set.impl&%0.finite.? A& A&. (vstd!seq_lib.impl&%0.to_set.? A& A&. seq~2$))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!seq_lib.impl&%0.to_set.? A& A&. seq~2$))) :qid user_vstd__seq_lib__seq_to_set_is_finite_broadcast_44 :skolemid skolem_user_vstd__seq_lib__seq_to_set_is_finite_broadcast_44)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::len")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&)) (<= 0 (vstd!set.impl&%0.len.? A& A&. self~2@))) :pattern ((vstd!set.impl&%0.len.? A& A&. self~2@)) :qid internal_vstd!set.impl&__0.len.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.len.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::union")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&))) (has_type (vstd!set.impl&%0.union.? A& A&. self~2@ s2~4@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.union.? A& A&. self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.union.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.union.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::intersect")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&))) (has_type (vstd!set.impl&%0.intersect.? A& A&. self~2@ s2~4@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.intersect.? A& A&. self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.intersect.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.intersect.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::difference")
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly) (s2~4@ Poly)) (! (=> (and (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type s2~4@ (TYPE%vstd!set.Set. A&))) (has_type (vstd!set.impl&%0.difference.? A& A&. self~2@ s2~4@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set.impl&%0.difference.? A& A&. self~2@ s2~4@)) :qid internal_vstd!set.impl&__0.difference.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.difference.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::impl&%0::choose")
(assert (fuel_bool_default fuel%vstd!set.impl&%0.choose.))
(declare-fun %%choose%%0 (Type Type Type Poly Type Type Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Type) (%%hole%%2 Type) (%%hole%%3 Poly) (%%hole%%4 Type) (%%hole%%5 Type) (%%hole%%6 Poly)) (! (=> (exists ((a~10$ Poly)) (! (and (has_type a~10$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a~10$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a~10$)) :qid user_vstd__set__impl&%0__choose_45 :skolemid skolem_user_vstd__set__impl&%0__choose_45)) (exists ((a~10$ Poly)) (! (and (and (has_type a~10$ %%hole%%0) (vstd!set.impl&%0.contains.? %%hole%%1 %%hole%%2 %%hole%%3 a~10$)) (= (%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6) a~10$)) :pattern ((vstd!set.impl&%0.contains.? %%hole%%4 %%hole%%5 %%hole%%6 a~10$))))) :pattern ((%%choose%%0 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6)))))
(assert (=> (fuel_bool fuel%vstd!set.impl&%0.choose.) (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (= (vstd!set.impl&%0.choose.? A& A&. self~2@) (as_type (%%choose%%0 A& A& A&. self~2@ A& A&. self~2@) A&)) :pattern ((vstd!set.impl&%0.choose.? A& A&. self~2@)) :qid internal_vstd!set.impl&__0.choose.?_definition :skolemid skolem_internal_vstd!set.impl&__0.choose.?_definition))))
(assert (forall ((A& Type) (A&. Type) (self~2@ Poly)) (! (=> (has_type self~2@ (TYPE%vstd!set.Set. A&)) (has_type (vstd!set.impl&%0.choose.? A& A&. self~2@) A&)) :pattern ((vstd!set.impl&%0.choose.? A& A&. self~2@)) :qid internal_vstd!set.impl&__0.choose.?_pre_post_definition :skolemid skolem_internal_vstd!set.impl&__0.choose.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty")
(declare-fun ens%vstd!set.axiom_set_empty. (Type Type Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (a~2@ Poly)) (! (= (ens%vstd!set.axiom_set_empty. A& A&. a~2@) (not (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.empty.? A& A&.) a~2@))) :pattern ((ens%vstd!set.axiom_set_empty. A& A&. a~2@)) :qid internal_ens__vstd!set.axiom_set_empty._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty._definition)))
(assert (forall ((A& Type) (A&. Type) (a~2$ Poly)) (! (=> (has_type a~2$ A&) (not (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.empty.? A& A&.) a~2$))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.empty.? A& A&.) a~2$)) :qid user_vstd__set__axiom_set_empty_46 :skolemid skolem_user_vstd__set__axiom_set_empty_46)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_new")
(declare-fun ens%vstd!set.axiom_set_new. (Type Type %%Function%% Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (f~2@ %%Function%%) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_new. A& A&. f~2@ a~4@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.new.? A& A&. (TYPE%fun%1. A& BOOL) (TYPE%fun%1. A&. BOOL) (Poly%fun%1. f~2@)) a~4@) (%B (%%apply%%0 f~2@ a~4@)))) :pattern ((ens%vstd!set.axiom_set_new. A& A&. f~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_new._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_new._definition)))
(assert (forall ((A& Type) (A&. Type) (f~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type f~2$ (TYPE%fun%1. A& BOOL)) (has_type a~4$ A&)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.new.? A& A&. (TYPE%fun%1. A& BOOL) (TYPE%fun%1. A&. BOOL) f~2$) a~4$) (%B (%%apply%%0 (%Poly%fun%1. f~2$) a~4$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.new.? A& A&. (TYPE%fun%1. A& BOOL) (TYPE%fun%1. A&. BOOL) f~2$) a~4$)) :qid user_vstd__set__axiom_set_new_47 :skolemid skolem_user_vstd__set__axiom_set_new_47)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_same")
(declare-fun ens%vstd!set.axiom_set_insert_same. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_same. A& A&. s~2@ a~4@) (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2@ a~4@) a~4@)) :pattern ((ens%vstd!set.axiom_set_insert_same. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_same._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_same._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$) a~4$)) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$) a~4$)) :qid user_vstd__set__axiom_set_insert_same_48 :skolemid skolem_user_vstd__set__axiom_set_insert_same_48)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_different")
(declare-fun ens%vstd!set.axiom_set_insert_different. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_different. A& A&. s~2@ a1~4@ a2~6@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2@ a2~6@) a1~4@) (vstd!set.impl&%0.contains.? A& A&. s~2@ a1~4@))) :pattern ((ens%vstd!set.axiom_set_insert_different. A& A&. s~2@ a1~4@ a2~6@)) :qid internal_ens__vstd!set.axiom_set_insert_different._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_different._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a1~4$ Poly) (a2~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a1~4$ A&) (has_type a2~6$ A&)) (=> (not (= a1~4$ a2~6$)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a2~6$) a1~4$) (vstd!set.impl&%0.contains.? A& A&. s~2$ a1~4$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a2~6$) a1~4$)) :qid user_vstd__set__axiom_set_insert_different_49 :skolemid skolem_user_vstd__set__axiom_set_insert_different_49)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_same")
(declare-fun ens%vstd!set.axiom_set_remove_same. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_same. A& A&. s~2@ a~4@) (not (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2@ a~4@) a~4@))) :pattern ((ens%vstd!set.axiom_set_remove_same. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_same._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_same._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (not (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$) a~4$))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$) a~4$)) :qid user_vstd__set__axiom_set_remove_same_50 :skolemid skolem_user_vstd__set__axiom_set_remove_same_50)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_different")
(declare-fun ens%vstd!set.axiom_set_remove_different. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a1~4@ Poly) (a2~6@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_different. A& A&. s~2@ a1~4@ a2~6@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2@ a2~6@) a1~4@) (vstd!set.impl&%0.contains.? A& A&. s~2@ a1~4@))) :pattern ((ens%vstd!set.axiom_set_remove_different. A& A&. s~2@ a1~4@ a2~6@)) :qid internal_ens__vstd!set.axiom_set_remove_different._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_different._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a1~4$ Poly) (a2~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a1~4$ A&) (has_type a2~6$ A&)) (=> (not (= a1~4$ a2~6$)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a2~6$) a1~4$) (vstd!set.impl&%0.contains.? A& A&. s~2$ a1~4$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a2~6$) a1~4$)) :qid user_vstd__set__axiom_set_remove_different_51 :skolemid skolem_user_vstd__set__axiom_set_remove_different_51)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_union")
(declare-fun ens%vstd!set.axiom_set_union. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_union. A& A&. s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2@ s2~4@) a~6@) (or (vstd!set.impl&%0.contains.? A& A&. s1~2@ a~6@) (vstd!set.impl&%0.contains.? A& A&. s2~4@ a~6@)))) :pattern ((ens%vstd!set.axiom_set_union. A& A&. s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_union._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_union._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2$ s2~4$) a~6$) (or (vstd!set.impl&%0.contains.? A& A&. s1~2$ a~6$) (vstd!set.impl&%0.contains.? A& A&. s2~4$ a~6$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_union_52 :skolemid skolem_user_vstd__set__axiom_set_union_52)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_intersect")
(declare-fun ens%vstd!set.axiom_set_intersect. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_intersect. A& A&. s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2@ s2~4@) a~6@) (and (vstd!set.impl&%0.contains.? A& A&. s1~2@ a~6@) (vstd!set.impl&%0.contains.? A& A&. s2~4@ a~6@)))) :pattern ((ens%vstd!set.axiom_set_intersect. A& A&. s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_intersect._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_intersect._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2$ s2~4$) a~6$) (and (vstd!set.impl&%0.contains.? A& A&. s1~2$ a~6$) (vstd!set.impl&%0.contains.? A& A&. s2~4$ a~6$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_intersect_53 :skolemid skolem_user_vstd__set__axiom_set_intersect_53)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_difference")
(declare-fun ens%vstd!set.axiom_set_difference. (Type Type Poly Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly) (a~6@ Poly)) (! (= (ens%vstd!set.axiom_set_difference. A& A&. s1~2@ s2~4@ a~6@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2@ s2~4@) a~6@) (and (vstd!set.impl&%0.contains.? A& A&. s1~2@ a~6@) (not (vstd!set.impl&%0.contains.? A& A&. s2~4@ a~6@))))) :pattern ((ens%vstd!set.axiom_set_difference. A& A&. s1~2@ s2~4@ a~6@)) :qid internal_ens__vstd!set.axiom_set_difference._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_difference._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly) (a~6$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&)) (has_type a~6$ A&)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2$ s2~4$) a~6$) (and (vstd!set.impl&%0.contains.? A& A&. s1~2$ a~6$) (not (vstd!set.impl&%0.contains.? A& A&. s2~4$ a~6$))))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2$ s2~4$) a~6$)) :qid user_vstd__set__axiom_set_difference_54 :skolemid skolem_user_vstd__set__axiom_set_difference_54)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_complement")
(declare-fun ens%vstd!set.axiom_set_complement. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_complement. A& A&. s~2@ a~4@) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.complement.? A& A&. s~2@) a~4@) (not (vstd!set.impl&%0.contains.? A& A&. s~2@ a~4@)))) :pattern ((ens%vstd!set.axiom_set_complement. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_complement._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_complement._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (= (vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.complement.? A& A&. s~2$) a~4$) (not (vstd!set.impl&%0.contains.? A& A&. s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. (vstd!set.impl&%0.complement.? A& A&. s~2$) a~4$)) :qid user_vstd__set__axiom_set_complement_55 :skolemid skolem_user_vstd__set__axiom_set_complement_55)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_ext_equal")
(declare-fun ens%vstd!set.axiom_set_ext_equal. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_ext_equal. A& A&. s1~2@ s2~4@) (= (ext_eq false (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2@ s2~4@) (forall ((a~32$ Poly)) (! (=> (has_type a~32$ A&) (= (vstd!set.impl&%0.contains.? A& A&. s1~2@ a~32$) (vstd!set.impl&%0.contains.? A& A&. s2~4@ a~32$))) :pattern ((vstd!set.impl&%0.contains.? A& A&. s1~2@ a~32$)) :pattern ((vstd!set.impl&%0.contains.? A& A&. s2~4@ a~32$)) :qid user_vstd__set__axiom_set_ext_equal_56 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_56)))) :pattern ((ens%vstd!set.axiom_set_ext_equal. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_ext_equal._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_ext_equal._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&))) (= (ext_eq false (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2$ s2~4$) (forall ((a~32$ Poly)) (! (=> (has_type a~32$ A&) (= (vstd!set.impl&%0.contains.? A& A&. s1~2$ a~32$) (vstd!set.impl&%0.contains.? A& A&. s2~4$ a~32$))) :pattern ((vstd!set.impl&%0.contains.? A& A&. s1~2$ a~32$)) :pattern ((vstd!set.impl&%0.contains.? A& A&. s2~4$ a~32$)) :qid user_vstd__set__axiom_set_ext_equal_57 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_57)))) :pattern ((ext_eq false (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2$ s2~4$)) :qid user_vstd__set__axiom_set_ext_equal_58 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_58)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_ext_equal_deep")
(declare-fun ens%vstd!set.axiom_set_ext_equal_deep. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_ext_equal_deep. A& A&. s1~2@ s2~4@) (= (ext_eq true (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2@ s2~4@) (ext_eq false (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_ext_equal_deep. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_ext_equal_deep._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_ext_equal_deep._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&))) (= (ext_eq true (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2$ s2~4$) (ext_eq false (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2$ s2~4$))) :pattern ((ext_eq true (TYPE%vstd!set.Set. A&) (TYPE%vstd!set.Set. A&.) s1~2$ s2~4$)) :qid user_vstd__set__axiom_set_ext_equal_deep_59 :skolemid skolem_user_vstd__set__axiom_set_ext_equal_deep_59)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_mk_map_domain")
(declare-fun ens%vstd!set.axiom_mk_map_domain. (Type Type Type Type Poly %%Function%%) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (s~2@ Poly) (f~4@ %%Function%%)) (! (= (ens%vstd!set.axiom_mk_map_domain. K& K&. V& V&. s~2@ f~4@) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2@ (Poly%fun%1. f~4@))) s~2@)) :pattern ((ens%vstd!set.axiom_mk_map_domain. K& K&. V& V&. s~2@ f~4@)) :qid internal_ens__vstd!set.axiom_mk_map_domain._definition :skolemid skolem_internal_ens__vstd!set.axiom_mk_map_domain._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (s~2$ Poly) (f~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. K&)) (has_type f~4$ (TYPE%fun%1. K& V&))) (= (vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2$ f~4$)) s~2$)) :pattern ((vstd!map.impl&%0.dom.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2$ f~4$))) :qid user_vstd__set__axiom_mk_map_domain_60 :skolemid skolem_user_vstd__set__axiom_mk_map_domain_60)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_mk_map_index")
(declare-fun ens%vstd!set.axiom_mk_map_index. (Type Type Type Type Poly %%Function%% Poly) Bool)
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (s~2@ Poly) (f~4@ %%Function%%) (key~6@ Poly)) (! (= (ens%vstd!set.axiom_mk_map_index. K& K&. V& V&. s~2@ f~4@ key~6@) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2@ (Poly%fun%1. f~4@)) key~6@) (%%apply%%0 f~4@ key~6@))) :pattern ((ens%vstd!set.axiom_mk_map_index. K& K&. V& V&. s~2@ f~4@ key~6@)) :qid internal_ens__vstd!set.axiom_mk_map_index._definition :skolemid skolem_internal_ens__vstd!set.axiom_mk_map_index._definition)))
(assert (forall ((K& Type) (K&. Type) (V& Type) (V&. Type) (s~2$ Poly) (f~4$ Poly) (key~6$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. K&)) (has_type f~4$ (TYPE%fun%1. K& V&)) (has_type key~6$ K&)) (=> (vstd!set.impl&%0.contains.? K& K&. s~2$ key~6$) (= (vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2$ f~4$) key~6$) (%%apply%%0 (%Poly%fun%1. f~4$) key~6$)))) :pattern ((vstd!map.impl&%0.index.? K& K&. V& V&. (vstd!set.impl&%0.mk_map.? K& K&. V& V&. (TYPE%fun%1. K& V&) (TYPE%fun%1. K&. V&.) s~2$ f~4$) key~6$)) :qid user_vstd__set__axiom_mk_map_index_61 :skolemid skolem_user_vstd__set__axiom_mk_map_index_61)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty_finite")
(declare-fun ens%vstd!set.axiom_set_empty_finite. (Type Type) Bool)
(assert (forall ((A& Type) (A&. Type)) (! (= (ens%vstd!set.axiom_set_empty_finite. A& A&.) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.empty.? A& A&.))) :pattern ((ens%vstd!set.axiom_set_empty_finite. A& A&.)) :qid internal_ens__vstd!set.axiom_set_empty_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty_finite._definition)))
(assert (forall ((A& Type) (A&. Type)) (! (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.empty.? A& A&.)) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.empty.? A& A&.))) :qid user_vstd__set__axiom_set_empty_finite_62 :skolemid skolem_user_vstd__set__axiom_set_empty_finite_62)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_finite")
(declare-fun ens%vstd!set.axiom_set_insert_finite. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_finite. A& A&. s~2@ a~4@) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2@ a~4@))) :pattern ((ens%vstd!set.axiom_set_insert_finite. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A& A&. s~2$) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$))) :qid user_vstd__set__axiom_set_insert_finite_63 :skolemid skolem_user_vstd__set__axiom_set_insert_finite_63)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_finite")
(declare-fun ens%vstd!set.axiom_set_remove_finite. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_finite. A& A&. s~2@ a~4@) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2@ a~4@))) :pattern ((ens%vstd!set.axiom_set_remove_finite. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A& A&. s~2$) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$)))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$))) :qid user_vstd__set__axiom_set_remove_finite_64 :skolemid skolem_user_vstd__set__axiom_set_remove_finite_64)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_union_finite")
(declare-fun ens%vstd!set.axiom_set_union_finite. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_union_finite. A& A&. s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_union_finite. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_union_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_union_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&))) (=> (and (vstd!set.impl&%0.finite.? A& A&. s1~2$) (vstd!set.impl&%0.finite.? A& A&. s2~4$)) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.union.? A& A&. s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_union_finite_65 :skolemid skolem_user_vstd__set__axiom_set_union_finite_65)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_intersect_finite")
(declare-fun ens%vstd!set.axiom_set_intersect_finite. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_intersect_finite. A& A&. s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_intersect_finite. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_intersect_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_intersect_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&))) (=> (or (vstd!set.impl&%0.finite.? A& A&. s1~2$) (vstd!set.impl&%0.finite.? A& A&. s2~4$)) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.intersect.? A& A&. s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_intersect_finite_66 :skolemid skolem_user_vstd__set__axiom_set_intersect_finite_66)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_difference_finite")
(declare-fun ens%vstd!set.axiom_set_difference_finite. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s1~2@ Poly) (s2~4@ Poly)) (! (= (ens%vstd!set.axiom_set_difference_finite. A& A&. s1~2@ s2~4@) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2@ s2~4@))) :pattern ((ens%vstd!set.axiom_set_difference_finite. A& A&. s1~2@ s2~4@)) :qid internal_ens__vstd!set.axiom_set_difference_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_difference_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s1~2$ Poly) (s2~4$ Poly)) (! (=> (and (has_type s1~2$ (TYPE%vstd!set.Set. A&)) (has_type s2~4$ (TYPE%vstd!set.Set. A&))) (=> (vstd!set.impl&%0.finite.? A& A&. s1~2$) (vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2$ s2~4$)))) :pattern ((vstd!set.impl&%0.finite.? A& A&. (vstd!set.impl&%0.difference.? A& A&. s1~2$ s2~4$))) :qid user_vstd__set__axiom_set_difference_finite_67 :skolemid skolem_user_vstd__set__axiom_set_difference_finite_67)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_choose_finite")
(declare-fun ens%vstd!set.axiom_set_choose_finite. (Type Type Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (ens%vstd!set.axiom_set_choose_finite. A& A&. s~2@) (vstd!set.impl&%0.contains.? A& A&. s~2@ (vstd!set.impl&%0.choose.? A& A&. s~2@))) :pattern ((ens%vstd!set.axiom_set_choose_finite. A& A&. s~2@)) :qid internal_ens__vstd!set.axiom_set_choose_finite._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_choose_finite._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly)) (! (=> (has_type s~2$ (TYPE%vstd!set.Set. A&)) (=> (not (vstd!set.impl&%0.finite.? A& A&. s~2$)) (vstd!set.impl&%0.contains.? A& A&. s~2$ (vstd!set.impl&%0.choose.? A& A&. s~2$)))) :pattern ((vstd!set.impl&%0.contains.? A& A&. s~2$ (vstd!set.impl&%0.choose.? A& A&. s~2$))) :qid user_vstd__set__axiom_set_choose_finite_68 :skolemid skolem_user_vstd__set__axiom_set_choose_finite_68)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_empty_len")
(declare-fun ens%vstd!set.axiom_set_empty_len. (Type Type) Bool)
(assert (forall ((A& Type) (A&. Type)) (! (= (ens%vstd!set.axiom_set_empty_len. A& A&.) (= (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.empty.? A& A&.)) 0)) :pattern ((ens%vstd!set.axiom_set_empty_len. A& A&.)) :qid internal_ens__vstd!set.axiom_set_empty_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_empty_len._definition)))
(assert (forall ((A& Type) (A&. Type)) (! (= (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.empty.? A& A&.)) 0) :pattern ((vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.empty.? A& A&.))) :qid user_vstd__set__axiom_set_empty_len_69 :skolemid skolem_user_vstd__set__axiom_set_empty_len_69)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_insert_len")
(declare-fun ens%vstd!set.axiom_set_insert_len. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_insert_len. A& A&. s~2@ a~4@) (= (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2@ a~4@)) (+ (vstd!set.impl&%0.len.? A& A&. s~2@) (ite (vstd!set.impl&%0.contains.? A& A&. s~2@ a~4@) 0 1)))) :pattern ((ens%vstd!set.axiom_set_insert_len. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_insert_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_insert_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A& A&. s~2$) (= (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$)) (+ (vstd!set.impl&%0.len.? A& A&. s~2$) (ite (vstd!set.impl&%0.contains.? A& A&. s~2$ a~4$) 0 1))))) :pattern ((vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.insert.? A& A&. s~2$ a~4$))) :qid user_vstd__set__axiom_set_insert_len_70 :skolemid skolem_user_vstd__set__axiom_set_insert_len_70)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_remove_len")
(declare-fun ens%vstd!set.axiom_set_remove_len. (Type Type Poly Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly) (a~4@ Poly)) (! (= (ens%vstd!set.axiom_set_remove_len. A& A&. s~2@ a~4@) (= (vstd!set.impl&%0.len.? A& A&. s~2@) (+ (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2@ a~4@)) (ite (vstd!set.impl&%0.contains.? A& A&. s~2@ a~4@) 1 0)))) :pattern ((ens%vstd!set.axiom_set_remove_len. A& A&. s~2@ a~4@)) :qid internal_ens__vstd!set.axiom_set_remove_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_remove_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly) (a~4$ Poly)) (! (=> (and (has_type s~2$ (TYPE%vstd!set.Set. A&)) (has_type a~4$ A&)) (=> (vstd!set.impl&%0.finite.? A& A&. s~2$) (= (vstd!set.impl&%0.len.? A& A&. s~2$) (+ (vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$)) (ite (vstd!set.impl&%0.contains.? A& A&. s~2$ a~4$) 1 0))))) :pattern ((vstd!set.impl&%0.len.? A& A&. (vstd!set.impl&%0.remove.? A& A&. s~2$ a~4$))) :qid user_vstd__set__axiom_set_remove_len_71 :skolemid skolem_user_vstd__set__axiom_set_remove_len_71)))
(set-info :comment ";; Function-Axioms vstd::set::axiom_set_choose_len")
(declare-fun ens%vstd!set.axiom_set_choose_len. (Type Type Poly) Bool)
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (ens%vstd!set.axiom_set_choose_len. A& A&. s~2@) (vstd!set.impl&%0.contains.? A& A&. s~2@ (vstd!set.impl&%0.choose.? A& A&. s~2@))) :pattern ((ens%vstd!set.axiom_set_choose_len. A& A&. s~2@)) :qid internal_ens__vstd!set.axiom_set_choose_len._definition :skolemid skolem_internal_ens__vstd!set.axiom_set_choose_len._definition)))
(assert (forall ((A& Type) (A&. Type) (s~2$ Poly)) (! (=> (has_type s~2$ (TYPE%vstd!set.Set. A&)) (=> (and (vstd!set.impl&%0.finite.? A& A&. s~2$) (not (= (vstd!set.impl&%0.len.? A& A&. s~2$) 0))) (vstd!set.impl&%0.contains.? A& A&. s~2$ (vstd!set.impl&%0.choose.? A& A&. s~2$)))) :pattern ((vstd!set.impl&%0.len.? A& A&. s~2$) (vstd!set.impl&%0.contains.? A& A&. s~2$ (vstd!set.impl&%0.choose.? A& A&. s~2$))) :qid user_vstd__set__axiom_set_choose_len_72 :skolemid skolem_user_vstd__set__axiom_set_choose_len_72)))
(set-info :comment ";; Function-Axioms vstd::set_lib::check_argument_is_set")
(assert (fuel_bool_default fuel%vstd!set_lib.check_argument_is_set.))
(assert (=> (fuel_bool fuel%vstd!set_lib.check_argument_is_set.) (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (= (vstd!set_lib.check_argument_is_set.? A& A&. s~2@) s~2@) :pattern ((vstd!set_lib.check_argument_is_set.? A& A&. s~2@)) :qid internal_vstd!set_lib.check_argument_is_set.?_definition :skolemid skolem_internal_vstd!set_lib.check_argument_is_set.?_definition))))
(assert (forall ((A& Type) (A&. Type) (s~2@ Poly)) (! (=> (has_type s~2@ (TYPE%vstd!set.Set. A&)) (has_type (vstd!set_lib.check_argument_is_set.? A& A&. s~2@) (TYPE%vstd!set.Set. A&))) :pattern ((vstd!set_lib.check_argument_is_set.? A& A&. s~2@)) :qid internal_vstd!set_lib.check_argument_is_set.?_pre_post_definition :skolemid skolem_internal_vstd!set_lib.check_argument_is_set.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::X86_NUM_LAYERS")
(assert (fuel_bool_default fuel%main!definitions_t.X86_NUM_LAYERS.))
(assert (=> (fuel_bool fuel%main!definitions_t.X86_NUM_LAYERS.) (= main!definitions_t.X86_NUM_LAYERS.? 4)))
(assert (uInv SZ main!definitions_t.X86_NUM_LAYERS.?))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::entry_size")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.entry_size.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.entry_size.) (forall ((self~2@ Poly) (layer~4@ Poly)) (! (= (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@) (main!definitions_t.ArchLayer./ArchLayer/entry_size (%Poly%main!definitions_t.ArchLayer. (vstd!seq.Seq.index.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))) layer~4@)))) :pattern ((main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)) :qid internal_main!definitions_t.impl&__7.entry_size.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.entry_size.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT)) (<= 0 (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@))) :pattern ((main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)) :qid internal_main!definitions_t.impl&__7.entry_size.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.entry_size.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::num_entries")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.num_entries.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.num_entries.) (forall ((self~2@ Poly) (layer~4@ Poly)) (! (= (main!definitions_t.impl&%7.num_entries.? self~2@ layer~4@) (main!definitions_t.ArchLayer./ArchLayer/num_entries (%Poly%main!definitions_t.ArchLayer. (vstd!seq.Seq.index.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))) layer~4@)))) :pattern ((main!definitions_t.impl&%7.num_entries.? self~2@ layer~4@)) :qid internal_main!definitions_t.impl&__7.num_entries.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.num_entries.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT)) (<= 0 (main!definitions_t.impl&%7.num_entries.? self~2@ layer~4@))) :pattern ((main!definitions_t.impl&%7.num_entries.? self~2@ layer~4@)) :qid internal_main!definitions_t.impl&__7.num_entries.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.num_entries.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::X86_MAX_ENTRY_SIZE")
(assert (fuel_bool_default fuel%main!definitions_t.X86_MAX_ENTRY_SIZE.))
(assert (=> (fuel_bool fuel%main!definitions_t.X86_MAX_ENTRY_SIZE.) (= main!definitions_t.X86_MAX_ENTRY_SIZE.? (nClip (* (nClip (* (nClip (* 512 1024)) 1024)) 1024)))))
(assert (<= 0 main!definitions_t.X86_MAX_ENTRY_SIZE.?))
(set-info :comment ";; Function-Axioms main::definitions_t::X86_NUM_ENTRIES")
(assert (fuel_bool_default fuel%main!definitions_t.X86_NUM_ENTRIES.))
(assert (=> (fuel_bool fuel%main!definitions_t.X86_NUM_ENTRIES.) (= main!definitions_t.X86_NUM_ENTRIES.? 512)))
(assert (uInv SZ main!definitions_t.X86_NUM_ENTRIES.?))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::entry_size_is_next_layer_size")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.entry_size_is_next_layer_size.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.entry_size_is_next_layer_size.) (forall ((self~2@ Poly) (i~4@ Poly)) (! (= (main!definitions_t.impl&%7.entry_size_is_next_layer_size.? self~2@ i~4@) (=> (< (nClip (+ (%I i~4@) 1)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))))) (= (main!definitions_t.impl&%7.entry_size.? self~2@ i~4@) (nClip (Mul (main!definitions_t.impl&%7.entry_size.? self~2@ (I (nClip (+ (%I i~4@) 1)))) (main!definitions_t.impl&%7.num_entries.? self~2@ (I (nClip (+ (%I i~4@) 1))))))))) :pattern ((main!definitions_t.impl&%7.entry_size_is_next_layer_size.? self~2@ i~4@)) :qid internal_main!definitions_t.impl&__7.entry_size_is_next_layer_size.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.entry_size_is_next_layer_size.?_definition))))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::inv")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.inv.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.inv.) (forall ((self~2@ Poly)) (! (= (main!definitions_t.impl&%7.inv.? self~2@) (and (<= (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))) main!definitions_t.X86_NUM_LAYERS.?) (forall ((i~20$ Poly)) (! (=> (has_type i~20$ NAT) (=> (< (%I i~20$) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@))))) (and (and (let ((tmp%%1$ (main!definitions_t.impl&%7.entry_size.? self~2@ i~20$))) (and (< 0 tmp%%1$) (<= tmp%%1$ main!definitions_t.X86_MAX_ENTRY_SIZE.?))) (let ((tmp%%2$ (main!definitions_t.impl&%7.num_entries.? self~2@ i~20$))) (and (< 0 tmp%%2$) (<= tmp%%2$ main!definitions_t.X86_NUM_ENTRIES.?)))) (main!definitions_t.impl&%7.entry_size_is_next_layer_size.? self~2@ i~20$)))) :pattern ((main!definitions_t.impl&%7.entry_size.? self~2@ i~20$)) :pattern ((main!definitions_t.impl&%7.num_entries.? self~2@ i~20$)) :qid user_main__definitions_t__Arch__inv_73 :skolemid skolem_user_main__definitions_t__Arch__inv_73)))) :pattern ((main!definitions_t.impl&%7.inv.? self~2@)) :qid internal_main!definitions_t.impl&__7.inv.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.inv.?_definition))))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::contains_entry_size_at_index_atleast")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.) (forall ((self~2@ Poly) (entry_size~4@ Poly) (min_idx~6@ Poly)) (! (= (main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.? self~2@ entry_size~4@ min_idx~6@) (exists ((i~14$ Poly)) (! (and (has_type i~14$ NAT) (and (and (<= (%I min_idx~6@) (%I i~14$)) (< (%I i~14$) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. self~2@)))))) (= (main!definitions_t.impl&%7.entry_size.? self~2@ i~14$) (%I entry_size~4@)))) :pattern ((main!definitions_t.impl&%7.entry_size.? self~2@ i~14$)) :qid user_main__definitions_t__Arch__contains_entry_size_at_index_atleast_74 :skolemid skolem_user_main__definitions_t__Arch__contains_entry_size_at_index_atleast_74))) :pattern ((main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.? self~2@ entry_size~4@ min_idx~6@)) :qid internal_main!definitions_t.impl&__7.contains_entry_size_at_index_atleast.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.contains_entry_size_at_index_atleast.?_definition))))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::contains_entry_size")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.contains_entry_size.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.contains_entry_size.) (forall ((self~2@ Poly) (entry_size~4@ Poly)) (! (= (main!definitions_t.impl&%7.contains_entry_size.? self~2@ entry_size~4@) (main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.? self~2@ entry_size~4@ (I 0))) :pattern ((main!definitions_t.impl&%7.contains_entry_size.? self~2@ entry_size~4@)) :qid internal_main!definitions_t.impl&__7.contains_entry_size.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.contains_entry_size.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::mappings_are_of_valid_size")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.mappings_are_of_valid_size.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.mappings_are_of_valid_size.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l0.impl&%0.mappings_are_of_valid_size.? self~2@) (forall ((va~10$ Poly)) (! (=> (has_type va~10$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) va~10$) (main!definitions_t.impl&%7.contains_entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$)))))))))) :pattern ((main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))) :pattern ((main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))) :qid user_main__impl_u__l0__PageTableContents__mappings_are_of_valid_size_75 :skolemid skolem_user_main__impl_u__l0__PageTableContents__mappings_are_of_valid_size_75))) :pattern ((main!impl_u.l0.impl&%0.mappings_are_of_valid_size.? self~2@)) :qid internal_main!impl_u.l0.impl&__0.mappings_are_of_valid_size.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.mappings_are_of_valid_size.?_definition))))
(set-info :comment ";; Function-Axioms main::definitions_t::aligned")
(assert (fuel_bool_default fuel%main!definitions_t.aligned.))
(assert (=> (fuel_bool fuel%main!definitions_t.aligned.) (forall ((addr~2@ Poly) (size~4@ Poly)) (! (= (main!definitions_t.aligned.? addr~2@ size~4@) (= (nClip (EucMod (%I addr~2@) (%I size~4@))) 0)) :pattern ((main!definitions_t.aligned.? addr~2@ size~4@)) :qid internal_main!definitions_t.aligned.?_definition :skolemid skolem_internal_main!definitions_t.aligned.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::mappings_are_aligned")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.mappings_are_aligned.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.mappings_are_aligned.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l0.impl&%0.mappings_are_aligned.? self~2@) (forall ((va~10$ Poly)) (! (=> (has_type va~10$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) va~10$) (and (main!definitions_t.aligned.? va~10$ (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$)))))))) (main!definitions_t.aligned.? (I (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))))))) :pattern ((main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))) :pattern ((main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) va~10$))))))) :qid user_main__impl_u__l0__PageTableContents__mappings_are_aligned_76 :skolemid skolem_user_main__impl_u__l0__PageTableContents__mappings_are_aligned_76))) :pattern ((main!impl_u.l0.impl&%0.mappings_are_aligned.? self~2@)) :qid internal_main!impl_u.l0.impl&__0.mappings_are_aligned.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.mappings_are_aligned.?_definition))))
(set-info :comment ";; Function-Axioms main::definitions_t::overlap")
(assert (fuel_bool_default fuel%main!definitions_t.overlap.))
(assert (=> (fuel_bool fuel%main!definitions_t.overlap.) (forall ((region1~2@ Poly) (region2~4@ Poly)) (! (= (main!definitions_t.overlap.? region1~2@ region2~4@) (ite (<= (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region1~2@)) (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region2~4@))) (< (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region2~4@)) (nClip (+ (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region1~2@)) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. region1~2@))))) (< (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region1~2@)) (nClip (+ (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. region2~4@)) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. region2~4@))))))) :pattern ((main!definitions_t.overlap.? region1~2@ region2~4@)) :qid internal_main!definitions_t.overlap.?_definition :skolemid skolem_internal_main!definitions_t.overlap.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::mappings_dont_overlap")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.mappings_dont_overlap.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.mappings_dont_overlap.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l0.impl&%0.mappings_dont_overlap.? self~2@) (forall ((b1~10$ Poly) (b2~12$ Poly)) (! (=> (and (has_type b1~10$ NAT) (has_type b2~12$ NAT)) (=> (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b1~10$) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b2~12$)) (or (= b1~10$ b2~12$) (not (main!definitions_t.overlap.? (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I b1~10$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b1~10$)))))))))) (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I b2~12$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b2~12$))))))))))))))) :pattern ((vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b1~10$) (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b2~12$)) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b1~10$) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b2~12$)) :qid user_main__impl_u__l0__PageTableContents__mappings_dont_overlap_77 :skolemid skolem_user_main__impl_u__l0__PageTableContents__mappings_dont_overlap_77))) :pattern ((main!impl_u.l0.impl&%0.mappings_dont_overlap.? self~2@)) :qid internal_main!impl_u.l0.impl&__0.mappings_dont_overlap.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.mappings_dont_overlap.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::candidate_mapping_in_bounds")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@) (and (<= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@)) (%I base~4@)) (<= (nClip (+ (%I base~4@) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@))))) :pattern ((main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l0.impl&__0.candidate_mapping_in_bounds.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.candidate_mapping_in_bounds.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::mappings_in_bounds")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.mappings_in_bounds.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.mappings_in_bounds.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l0.impl&%0.mappings_in_bounds.? self~2@) (forall ((b1~10$ Poly)) (! (=> (has_type b1~10$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b1~10$) (main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? self~2@ b1~10$ (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b1~10$)))) :pattern ((vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b1~10$)) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b1~10$)) :pattern ((main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? self~2@ b1~10$ (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b1~10$))) :qid user_main__impl_u__l0__PageTableContents__mappings_in_bounds_78 :skolemid skolem_user_main__impl_u__l0__PageTableContents__mappings_in_bounds_78))) :pattern ((main!impl_u.l0.impl&%0.mappings_in_bounds.? self~2@)) :qid internal_main!impl_u.l0.impl&__0.mappings_in_bounds.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.mappings_in_bounds.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::inv")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.inv.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.inv.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l0.impl&%0.inv.? self~2@) (and (and (and (and (and (vstd!set.impl&%0.finite.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))))) (main!definitions_t.impl&%7.inv.? (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@))))) (main!impl_u.l0.impl&%0.mappings_are_of_valid_size.? self~2@)) (main!impl_u.l0.impl&%0.mappings_are_aligned.? self~2@)) (main!impl_u.l0.impl&%0.mappings_dont_overlap.? self~2@)) (main!impl_u.l0.impl&%0.mappings_in_bounds.? self~2@))) :pattern ((main!impl_u.l0.impl&%0.inv.? self~2@)) :qid internal_main!impl_u.l0.impl&__0.inv.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.inv.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::accepted_mapping")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.accepted_mapping.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.accepted_mapping.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l0.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@) (and (and (and (main!definitions_t.aligned.? base~4@ (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!definitions_t.aligned.? (I (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))))) (main!impl_u.l0.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@)) (main!definitions_t.impl&%7.contains_entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))))) :pattern ((main!impl_u.l0.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l0.impl&__0.accepted_mapping.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.accepted_mapping.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::valid_mapping")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.valid_mapping.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.valid_mapping.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l0.impl&%0.valid_mapping.? self~2@ base~4@ pte~6@) (forall ((b~14$ Poly)) (! (=> (has_type b~14$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b~14$) (not (main!definitions_t.overlap.? (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I base~4@) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))))) (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I b~14$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) b~14$)))))))))))))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) b~14$)) :qid user_main__impl_u__l0__PageTableContents__valid_mapping_79 :skolemid skolem_user_main__impl_u__l0__PageTableContents__valid_mapping_79))) :pattern ((main!impl_u.l0.impl&%0.valid_mapping.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l0.impl&__0.valid_mapping.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.valid_mapping.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::map_frame")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.map_frame.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.map_frame.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l0.impl&%0.map_frame.? self~2@ base~4@ pte~6@) (ite (main!impl_u.l0.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@) (ite (main!impl_u.l0.impl&%0.valid_mapping.? self~2@ base~4@ pte~6@) (core!result.Result./Ok (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.PageTableContents./PageTableContents (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) base~4@ pte~6@)) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@))))))) (core!result.Result./Err self~2@)) (%Poly%core!result.Result. (vstd!pervasive.arbitrary.? (TYPE%core!result.Result. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.) (TYPE%core!result.Result. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.))))) :pattern ((main!impl_u.l0.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l0.impl&__0.map_frame.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.map_frame.?_definition))))
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l0.PageTableContents.) (has_type base~4@ NAT) (has_type pte~6@ TYPE%main!definitions_t.PageTableEntry.)) (has_type (Poly%core!result.Result. (main!impl_u.l0.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) (TYPE%core!result.Result. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.))) :pattern ((main!impl_u.l0.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l0.impl&__0.map_frame.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.map_frame.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::between")
(assert (fuel_bool_default fuel%main!definitions_t.between.))
(assert (=> (fuel_bool fuel%main!definitions_t.between.) (forall ((x~2@ Poly) (a~4@ Poly) (b~6@ Poly)) (! (= (main!definitions_t.between.? x~2@ a~4@ b~6@) (and (<= (%I a~4@) (%I x~2@)) (< (%I x~2@) (%I b~6@)))) :pattern ((main!definitions_t.between.? x~2@ a~4@ b~6@)) :qid internal_main!definitions_t.between.?_definition :skolemid skolem_internal_main!definitions_t.between.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::accepted_resolve")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.accepted_resolve.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.accepted_resolve.) (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.accepted_resolve.? self~2@ vaddr~4@) (main!definitions_t.between.? vaddr~4@ (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@))) (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@))))) :pattern ((main!impl_u.l0.impl&%0.accepted_resolve.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l0.impl&__0.accepted_resolve.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.accepted_resolve.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::resolve")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.resolve.))
(declare-fun %%choose%%1 (Type Type Type Type Type Type Poly Poly Type Type Type Type Poly) Poly)
(assert (forall ((%%hole%%0 Type) (%%hole%%1 Type) (%%hole%%2 Type) (%%hole%%3 Type) (%%hole%%4 Type) (%%hole%%5 Type) (%%hole%%6 Poly) (%%hole%%7 Poly) (%%hole%%8 Type) (%%hole%%9 Type) (%%hole%%10 Type) (%%hole%%11 Type) (%%hole%%12 Poly)) (! (=> (exists ((base~67$ Poly) (pte~69$ Poly)) (! (and (has_type base~67$ %%hole%%0) (has_type pte~69$ %%hole%%1) (and (vstd!map.impl&%0.contains_pair.? %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 base~67$ pte~69$) (main!definitions_t.between.? %%hole%%7 base~67$ (I (nClip (+ (%I base~67$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~69$))))))))))) :pattern ((vstd!map.impl&%0.contains_pair.? %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 base~67$ pte~69$)) :qid user_main__impl_u__l0__PageTableContents__resolve_81 :skolemid skolem_user_main__impl_u__l0__PageTableContents__resolve_81)) (exists ((base~67$ Poly) (pte~69$ Poly)) (! (and (and (has_type base~67$ %%hole%%0) (has_type pte~69$ %%hole%%1) (and (vstd!map.impl&%0.contains_pair.? %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 base~67$ pte~69$) (main!definitions_t.between.? %%hole%%7 base~67$ (I (nClip (+ (%I base~67$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~69$))))))))))) (= (%%choose%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12) (Poly%tuple%2. (tuple%2./tuple%2 base~67$ pte~69$)))) :pattern ((vstd!map.impl&%0.contains_pair.? %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12 base~67$ pte~69$))))) :pattern ((%%choose%%1 %%hole%%0 %%hole%%1 %%hole%%2 %%hole%%3 %%hole%%4 %%hole%%5 %%hole%%6 %%hole%%7 %%hole%%8 %%hole%%9 %%hole%%10 %%hole%%11 %%hole%%12)))))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.resolve.) (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.resolve.? self~2@ vaddr~4@) (ite (exists ((base~26$ Poly) (pte~28$ Poly)) (! (and (and (has_type base~26$ NAT) (has_type pte~28$ TYPE%main!definitions_t.PageTableEntry.)) (and (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) base~26$ pte~28$) (main!definitions_t.between.? vaddr~4@ base~26$ (I (nClip (+ (%I base~26$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~28$))))))))))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) base~26$ pte~28$)) :qid user_main__impl_u__l0__PageTableContents__resolve_80 :skolemid skolem_user_main__impl_u__l0__PageTableContents__resolve_80)) (let ((tmp%%1$ (%Poly%tuple%2. (as_type (%%choose%%1 NAT TYPE%main!definitions_t.PageTableEntry. NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) vaddr~4@ NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (TYPE%tuple%2. NAT TYPE%main!definitions_t.PageTableEntry.))))) (let ((base~100$ (%I (tuple%2./tuple%2/field%0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (let ((pte~101$ (%Poly%main!definitions_t.PageTableEntry. (tuple%2./tuple%2/field%1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (core!result.Result./Ok (Poly%tuple%2. (tuple%2./tuple%2 (I base~100$) (Poly%main!definitions_t.PageTableEntry. pte~101$))))))) (core!result.Result./Err (Poly%tuple%0. tuple%0./tuple%0)))) :pattern ((main!impl_u.l0.impl&%0.resolve.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l0.impl&__0.resolve.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.resolve.?_definition))))
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l0.PageTableContents.) (has_type vaddr~4@ NAT)) (has_type (Poly%core!result.Result. (main!impl_u.l0.impl&%0.resolve.? self~2@ vaddr~4@)) (TYPE%core!result.Result. (TYPE%tuple%2. NAT TYPE%main!definitions_t.PageTableEntry.) TYPE%tuple%0.))) :pattern ((main!impl_u.l0.impl&%0.resolve.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l0.impl&__0.resolve.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.resolve.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::remove")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.remove.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.remove.) (forall ((self~2@ Poly) (n~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.remove.? self~2@ n~4@) (main!impl_u.l0.PageTableContents./PageTableContents (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) n~4@)) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@)))))) :pattern ((main!impl_u.l0.impl&%0.remove.? self~2@ n~4@)) :qid internal_main!impl_u.l0.impl&__0.remove.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.remove.?_definition))))
(assert (forall ((self~2@ Poly) (n~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l0.PageTableContents.) (has_type n~4@ NAT)) (has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.impl&%0.remove.? self~2@ n~4@)) TYPE%main!impl_u.l0.PageTableContents.)) :pattern ((main!impl_u.l0.impl&%0.remove.? self~2@ n~4@)) :qid internal_main!impl_u.l0.impl&__0.remove.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.remove.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::accepted_unmap")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.accepted_unmap.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.accepted_unmap.) (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.accepted_unmap.? self~2@ base~4@) (and (main!definitions_t.between.? base~4@ (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@))) (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) (exists ((size~24$ Poly)) (! (and (has_type size~24$ NAT) (and (main!definitions_t.impl&%7.contains_entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@))) size~24$) (main!definitions_t.aligned.? base~4@ size~24$))) :pattern ((main!definitions_t.impl&%7.contains_entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l0.PageTableContents./PageTableContents/arch (%Poly%main!impl_u.l0.PageTableContents. self~2@))) size~24$)) :pattern ((main!definitions_t.aligned.? base~4@ size~24$)) :qid user_main__impl_u__l0__PageTableContents__accepted_unmap_82 :skolemid skolem_user_main__impl_u__l0__PageTableContents__accepted_unmap_82)))) :pattern ((main!impl_u.l0.impl&%0.accepted_unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l0.impl&__0.accepted_unmap.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.accepted_unmap.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::unmap")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.unmap.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.unmap.) (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.unmap.? self~2@ base~4@) (ite (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) base~4@) (core!result.Result./Ok (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l0.impl&%0.remove.? self~2@ base~4@))) (core!result.Result./Err self~2@))) :pattern ((main!impl_u.l0.impl&%0.unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l0.impl&__0.unmap.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.unmap.?_definition))))
(assert (forall ((self~2@ Poly) (base~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l0.PageTableContents.) (has_type base~4@ NAT)) (has_type (Poly%core!result.Result. (main!impl_u.l0.impl&%0.unmap.? self~2@ base~4@)) (TYPE%core!result.Result. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.))) :pattern ((main!impl_u.l0.impl&%0.unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l0.impl&__0.unmap.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.unmap.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::lemma_unmap_decrements_len")
(declare-fun ens%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. (main!impl_u.l0.PageTableContents. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l0.PageTableContents.) (base~4@ Int)) (! (= (ens%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. self~2@ base~4@) (and (> (vstd!set.impl&%0.len.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. self~2@)))))) 0) (= (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l0.impl&%0.unmap.? (Poly%main!impl_u.l0.PageTableContents. self~2@) (I base~4@))))))))) (vstd!set.impl&%0.remove.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. self~2@))))) (I base~4@))) (= (vstd!set.impl&%0.len.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l0.impl&%0.unmap.? (Poly%main!impl_u.l0.PageTableContents. self~2@) (I base~4@)))))))))) (- (vstd!set.impl&%0.len.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. self~2@)))))) 1)))) :pattern ((ens%main!impl_u.l0.impl&%0.lemma_unmap_decrements_len. self~2@ base~4@)) :qid internal_ens__main!impl_u.l0.impl&__0.lemma_unmap_decrements_len._definition :skolemid skolem_internal_ens__main!impl_u.l0.impl&__0.lemma_unmap_decrements_len._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::ranges_disjoint")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.ranges_disjoint.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.ranges_disjoint.) (forall ((self~2@ Poly) (other~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.ranges_disjoint.? self~2@ other~4@) (ite (<= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@)) (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. other~4@))) (<= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. self~2@)) (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. other~4@))) (<= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. other~4@)) (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. self~2@))))) :pattern ((main!impl_u.l0.impl&%0.ranges_disjoint.? self~2@ other~4@)) :qid internal_main!impl_u.l0.impl&__0.ranges_disjoint.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.ranges_disjoint.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::mappings_disjoint")
(assert (fuel_bool_default fuel%main!impl_u.l0.impl&%0.mappings_disjoint.))
(assert (=> (fuel_bool fuel%main!impl_u.l0.impl&%0.mappings_disjoint.) (forall ((self~2@ Poly) (other~4@ Poly)) (! (= (main!impl_u.l0.impl&%0.mappings_disjoint.? self~2@ other~4@) (forall ((s~12$ Poly) (o~14$ Poly)) (! (=> (and (has_type s~12$ NAT) (has_type o~14$ NAT)) (=> (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@)))) s~12$) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. other~4@)))) o~14$)) (not (main!definitions_t.overlap.? (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I s~12$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) s~12$)))))))))) (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I o~14$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. other~4@))) o~14$)))))))))))))) :pattern ((main!definitions_t.overlap.? (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I s~12$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. self~2@))) s~12$)))))))))) (Poly%main!definitions_t.MemRegion. (main!definitions_t.MemRegion./MemRegion (%I o~14$) (%I (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. other~4@))) o~14$)))))))))))) :qid user_main__impl_u__l0__PageTableContents__mappings_disjoint_83 :skolemid skolem_user_main__impl_u__l0__PageTableContents__mappings_disjoint_83))) :pattern ((main!impl_u.l0.impl&%0.mappings_disjoint.? self~2@ other~4@)) :qid internal_main!impl_u.l0.impl&__0.mappings_disjoint.?_definition :skolemid skolem_internal_main!impl_u.l0.impl&__0.mappings_disjoint.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l0::PageTableContents::lemma_ranges_disjoint_implies_mappings_disjoint")
(declare-fun ens%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. (main!impl_u.l0.PageTableContents. main!impl_u.l0.PageTableContents.) Bool)
(assert (forall ((self~2@ main!impl_u.l0.PageTableContents.) (other~4@ main!impl_u.l0.PageTableContents.)) (! (= (ens%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. self~2@ other~4@) (main!impl_u.l0.impl&%0.mappings_disjoint.? (Poly%main!impl_u.l0.PageTableContents. self~2@) (Poly%main!impl_u.l0.PageTableContents. other~4@))) :pattern ((ens%main!impl_u.l0.impl&%0.lemma_ranges_disjoint_implies_mappings_disjoint. self~2@ other~4@)) :qid internal_ens__main!impl_u.l0.impl&__0.lemma_ranges_disjoint_implies_mappings_disjoint._definition :skolemid skolem_internal_ens__main!impl_u.l0.impl&__0.lemma_ranges_disjoint_implies_mappings_disjoint._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l0::ambient_lemmas1")
(declare-fun ens%main!impl_u.l0.ambient_lemmas1. (Int) Bool)
(assert (forall ((no%param@ Int)) (! (= (ens%main!impl_u.l0.ambient_lemmas1. no%param@) (and (forall ((s1~14$ Poly) (s2~16$ Poly)) (! (=> (and (has_type s1~14$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type s2~16$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.))) (=> (and (vstd!set.impl&%0.finite.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. s1~14$)) (vstd!set.impl&%0.finite.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. s2~16$))) (vstd!set.impl&%0.finite.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. s1~14$ s2~16$))))) :pattern ((vstd!set.impl&%0.finite.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. s1~14$ s2~16$)))) :qid user_main__impl_u__l0__ambient_lemmas1_84 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_84)) (forall ((a~67$ Int) (b~69$ Int)) (! (= (Mul a~67$ b~69$) (Mul b~69$ a~67$)) :pattern ((Mul a~67$ b~69$)) :qid user_main__impl_u__l0__ambient_lemmas1_85 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_85)) (forall ((m1~98$ Poly) (m2~100$ Poly) (n~102$ Poly)) (! (=> (and (has_type m1~98$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type m2~100$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type n~102$ NAT)) (=> (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~98$) n~102$) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~100$) n~102$))) (= (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~98$ n~102$) m2~100$) (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~98$ m2~100$) n~102$)))) :pattern ((vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~98$ n~102$) m2~100$)) :pattern ((vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~98$ m2~100$) n~102$)) :qid user_main__impl_u__l0__ambient_lemmas1_86 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_86)) (forall ((m1~170$ Poly) (m2~172$ Poly) (n~174$ Poly)) (! (=> (and (has_type m1~170$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type m2~172$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type n~174$ NAT)) (=> (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~172$) n~174$) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~170$) n~174$))) (= (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~170$ (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~172$ n~174$)) (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~170$ m2~172$) n~174$)))) :pattern ((vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~170$ (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~172$ n~174$))) :pattern ((vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~170$ m2~172$) n~174$)) :qid user_main__impl_u__l0__ambient_lemmas1_87 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_87)) (forall ((m1~242$ Poly) (m2~244$ Poly) (n~246$ Poly) (v~248$ Poly)) (! (=> (and (has_type m1~242$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type m2~244$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type n~246$ NAT) (has_type v~248$ TYPE%main!definitions_t.PageTableEntry.)) (=> (and (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~242$) n~246$)) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~244$) n~246$))) (= (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~242$ n~246$ v~248$) m2~244$) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~242$ m2~244$) n~246$ v~248$)))) :pattern ((vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~242$ n~246$ v~248$) m2~244$)) :pattern ((vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~242$ m2~244$) n~246$ v~248$)) :qid user_main__impl_u__l0__ambient_lemmas1_88 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_88)) (forall ((m1~323$ Poly) (m2~325$ Poly) (n~327$ Poly) (v~329$ Poly)) (! (=> (and (has_type m1~323$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type m2~325$ (TYPE%vstd!map.Map. NAT TYPE%main!definitions_t.PageTableEntry.)) (has_type n~327$ NAT) (has_type v~329$ TYPE%main!definitions_t.PageTableEntry.)) (=> (and (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~323$) n~327$)) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~325$) n~327$))) (= (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~323$ (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~325$ n~327$ v~329$)) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~323$ m2~325$) n~327$ v~329$)))) :pattern ((vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~323$ (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m2~325$ n~327$ v~329$))) :pattern ((vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. m1~323$ m2~325$) n~327$ v~329$)) :qid user_main__impl_u__l0__ambient_lemmas1_89 :skolemid skolem_user_main__impl_u__l0__ambient_lemmas1_89)))) :pattern ((ens%main!impl_u.l0.ambient_lemmas1. no%param@)) :qid internal_ens__main!impl_u.l0.ambient_lemmas1._definition :skolemid skolem_internal_ens__main!impl_u.l0.ambient_lemmas1._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::entry_size")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.entry_size.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.entry_size.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.entry_size.? self~2@) (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((main!impl_u.l1.impl&%0.entry_size.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.entry_size.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_size.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (<= 0 (main!impl_u.l1.impl&%0.entry_size.? self~2@))) :pattern ((main!impl_u.l1.impl&%0.entry_size.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.entry_size.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_size.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::num_entries")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.num_entries.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.num_entries.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.num_entries.? self~2@) (main!definitions_t.impl&%7.num_entries.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((main!impl_u.l1.impl&%0.num_entries.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.num_entries.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.num_entries.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (<= 0 (main!impl_u.l1.impl&%0.num_entries.? self~2@))) :pattern ((main!impl_u.l1.impl&%0.num_entries.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.num_entries.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.num_entries.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::well_formed")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.well_formed.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.well_formed.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.well_formed.? self~2@) (and (and (and (main!definitions_t.impl&%7.inv.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))) (< (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))))))))) (main!definitions_t.aligned.? (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@))) (I (nClip (Mul (main!impl_u.l1.impl&%0.entry_size.? self~2@) (main!impl_u.l1.impl&%0.num_entries.? self~2@)))))) (= (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@)))) (main!impl_u.l1.impl&%0.num_entries.? self~2@)))) :pattern ((main!impl_u.l1.impl&%0.well_formed.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.well_formed.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.well_formed.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::empty")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.empty.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.empty.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.empty.? self~2@) (forall ((i~21$ Poly)) (! (=> (has_type i~21$ NAT) (=> (< (%I i~21$) (main!impl_u.l1.impl&%0.num_entries.? self~2@)) ((_ is main!impl_u.l1.NodeEntry./Empty) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$))))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)) :qid user_main__impl_u__l1__Directory__empty_90 :skolemid skolem_user_main__impl_u__l1__Directory__empty_90))) :pattern ((main!impl_u.l1.impl&%0.empty.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.empty.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.empty.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::pages_match_entry_size")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.pages_match_entry_size.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.pages_match_entry_size.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.pages_match_entry_size.? self~2@) (forall ((i~21$ Poly)) (! (=> (has_type i~21$ NAT) (=> (and (< (%I i~21$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Page) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)))) (= (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$))))))))) (main!impl_u.l1.impl&%0.entry_size.? self~2@)))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)) :qid user_main__impl_u__l1__Directory__pages_match_entry_size_91 :skolemid skolem_user_main__impl_u__l1__Directory__pages_match_entry_size_91))) :pattern ((main!impl_u.l1.impl&%0.pages_match_entry_size.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.pages_match_entry_size.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.pages_match_entry_size.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::directories_are_in_next_layer")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.directories_are_in_next_layer.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.directories_are_in_next_layer.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@) (forall ((i~21$ Poly)) (! (=> (has_type i~21$ NAT) (=> (and (< (%I i~21$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)))) (let ((directory~74$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$))))) (and (= (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. directory~74$))) (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) 1))) (= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. directory~74$))) (nClip (+ (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@)) (nClip (Mul (%I i~21$) (main!impl_u.l1.impl&%0.entry_size.? self~2@)))))))))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)) :qid user_main__impl_u__l1__Directory__directories_are_in_next_layer_92 :skolemid skolem_user_main__impl_u__l1__Directory__directories_are_in_next_layer_92))) :pattern ((main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.directories_are_in_next_layer.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_are_in_next_layer.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::directories_match_arch")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.directories_match_arch.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.directories_match_arch.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.directories_match_arch.? self~2@) (forall ((i~10$ Poly)) (! (=> (has_type i~10$ NAT) (=> (and (< (%I i~10$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~10$)))) (= (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~10$)))))) (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~10$)) :qid user_main__impl_u__l1__Directory__directories_match_arch_93 :skolemid skolem_user_main__impl_u__l1__Directory__directories_match_arch_93))) :pattern ((main!impl_u.l1.impl&%0.directories_match_arch.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.directories_match_arch.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_match_arch.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::directories_are_nonempty")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.directories_are_nonempty.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.directories_are_nonempty.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.directories_are_nonempty.? self~2@) (forall ((i~29$ Poly)) (! (=> (has_type i~29$ NAT) (=> (and (< (%I i~29$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~29$)))) (not (main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~29$)))))))) :pattern ((main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~29$)))))) :qid user_main__impl_u__l1__Directory__directories_are_nonempty_94 :skolemid skolem_user_main__impl_u__l1__Directory__directories_are_nonempty_94))) :pattern ((main!impl_u.l1.impl&%0.directories_are_nonempty.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.directories_are_nonempty.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_are_nonempty.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::frames_aligned")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.frames_aligned.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.frames_aligned.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.frames_aligned.? self~2@) (forall ((i~21$ Poly)) (! (=> (has_type i~21$ NAT) (=> (and (< (%I i~21$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Page) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)))) (main!definitions_t.aligned.? (I (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)))))))))) (I (main!impl_u.l1.impl&%0.entry_size.? self~2@))))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~21$)) :qid user_main__impl_u__l1__Directory__frames_aligned_95 :skolemid skolem_user_main__impl_u__l1__Directory__frames_aligned_95))) :pattern ((main!impl_u.l1.impl&%0.frames_aligned.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.frames_aligned.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.frames_aligned.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::inv")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.inv.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.inv. Fuel)
(assert (forall ((self~2@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%inv.? self~2@ fuel%@) (main!impl_u.l1.impl&%0.rec%inv.? self~2@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%inv.? self~2@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.inv._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.inv._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%inv.? self~2@ (succ fuel%@)) (and (and (and (and (and (and (main!impl_u.l1.impl&%0.well_formed.? self~2@) (main!impl_u.l1.impl&%0.pages_match_entry_size.? self~2@)) (main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@)) (main!impl_u.l1.impl&%0.directories_match_arch.? self~2@)) (main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ fuel%@)) (main!impl_u.l1.impl&%0.directories_are_nonempty.? self~2@)) (main!impl_u.l1.impl&%0.frames_aligned.? self~2@))) :pattern ((main!impl_u.l1.impl&%0.rec%inv.? self~2@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.inv._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.inv._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.inv.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l1.impl&%0.rec%inv.? self~2@ (succ (succ fuel_nat%main!impl_u.l1.impl&%0.inv.)))) :pattern ((main!impl_u.l1.impl&%0.inv.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.inv.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.inv.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::directories_obey_invariant")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.directories_obey_invariant.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.directories_obey_invariant. Fuel)
(assert (forall ((self~2@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ fuel%@) (main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.directories_obey_invariant._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_obey_invariant._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ (succ fuel%@)) (ite (and (and (main!impl_u.l1.impl&%0.well_formed.? self~2@) (main!impl_u.l1.impl&%0.directories_are_in_next_layer.? self~2@)) (main!impl_u.l1.impl&%0.directories_match_arch.? self~2@)) (forall ((i~69$ Poly)) (! (=> (has_type i~69$ NAT) (=> (and (< (%I i~69$) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~69$)))) (main!impl_u.l1.impl&%0.rec%inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~69$)))) fuel%@))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) i~69$)) :qid user_main__impl_u__l1__Directory__directories_obey_invariant_97 :skolemid skolem_user_main__impl_u__l1__Directory__directories_obey_invariant_97)) (%B (vstd!pervasive.arbitrary.? BOOL BOOL)))) :pattern ((main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.directories_obey_invariant._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_obey_invariant._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.directories_obey_invariant.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.directories_obey_invariant.? self~2@) (main!impl_u.l1.impl&%0.rec%directories_obey_invariant.? self~2@ (succ (succ fuel_nat%main!impl_u.l1.impl&%0.directories_obey_invariant.)))) :pattern ((main!impl_u.l1.impl&%0.directories_obey_invariant.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.directories_obey_invariant.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.directories_obey_invariant.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::entry_base_from_index")
(assert (fuel_bool_default fuel%main!impl_u.indexing.entry_base_from_index.))
(assert (=> (fuel_bool fuel%main!impl_u.indexing.entry_base_from_index.) (forall ((base~2@ Poly) (idx~4@ Poly) (entry_size~6@ Poly)) (! (= (main!impl_u.indexing.entry_base_from_index.? base~2@ idx~4@ entry_size~6@) (nClip (+ (%I base~2@) (nClip (Mul (%I idx~4@) (%I entry_size~6@)))))) :pattern ((main!impl_u.indexing.entry_base_from_index.? base~2@ idx~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.entry_base_from_index.?_definition :skolemid skolem_internal_main!impl_u.indexing.entry_base_from_index.?_definition))))
(assert (forall ((base~2@ Poly) (idx~4@ Poly) (entry_size~6@ Poly)) (! (=> (and (has_type base~2@ NAT) (has_type idx~4@ NAT) (has_type entry_size~6@ NAT)) (<= 0 (main!impl_u.indexing.entry_base_from_index.? base~2@ idx~4@ entry_size~6@))) :pattern ((main!impl_u.indexing.entry_base_from_index.? base~2@ idx~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.entry_base_from_index.?_pre_post_definition :skolemid skolem_internal_main!impl_u.indexing.entry_base_from_index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::entry_base")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.entry_base.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.entry_base.) (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (= (main!definitions_t.impl&%7.entry_base.? self~2@ layer~4@ base~6@ idx~8@) (main!impl_u.indexing.entry_base_from_index.? base~6@ idx~8@ (I (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)))) :pattern ((main!definitions_t.impl&%7.entry_base.? self~2@ layer~4@ base~6@ idx~8@)) :qid internal_main!definitions_t.impl&__7.entry_base.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.entry_base.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT) (has_type base~6@ NAT) (has_type idx~8@ NAT)) (<= 0 (main!definitions_t.impl&%7.entry_base.? self~2@ layer~4@ base~6@ idx~8@))) :pattern ((main!definitions_t.impl&%7.entry_base.? self~2@ layer~4@ base~6@ idx~8@)) :qid internal_main!definitions_t.impl&__7.entry_base.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.entry_base.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::upper_vaddr")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.upper_vaddr.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.upper_vaddr.) (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly)) (! (= (main!definitions_t.impl&%7.upper_vaddr.? self~2@ layer~4@ base~6@) (main!impl_u.indexing.entry_base_from_index.? base~6@ (I (main!definitions_t.impl&%7.num_entries.? self~2@ layer~4@)) (I (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)))) :pattern ((main!definitions_t.impl&%7.upper_vaddr.? self~2@ layer~4@ base~6@)) :qid internal_main!definitions_t.impl&__7.upper_vaddr.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.upper_vaddr.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT) (has_type base~6@ NAT)) (<= 0 (main!definitions_t.impl&%7.upper_vaddr.? self~2@ layer~4@ base~6@))) :pattern ((main!definitions_t.impl&%7.upper_vaddr.? self~2@ layer~4@ base~6@)) :qid internal_main!definitions_t.impl&__7.upper_vaddr.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.upper_vaddr.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::upper_vaddr")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.upper_vaddr.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.upper_vaddr.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.upper_vaddr.? self~2@) (main!definitions_t.impl&%7.upper_vaddr.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@))))) :pattern ((main!impl_u.l1.impl&%0.upper_vaddr.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.upper_vaddr.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.upper_vaddr.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (<= 0 (main!impl_u.l1.impl&%0.upper_vaddr.? self~2@))) :pattern ((main!impl_u.l1.impl&%0.upper_vaddr.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.upper_vaddr.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.upper_vaddr.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::entry_base")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.entry_base.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.entry_base.) (forall ((self~2@ Poly) (idx~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.entry_base.? self~2@ idx~4@) (main!impl_u.indexing.entry_base_from_index.? (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@))) idx~4@ (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))))))) :pattern ((main!impl_u.l1.impl&%0.entry_base.? self~2@ idx~4@)) :qid internal_main!impl_u.l1.impl&__0.entry_base.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_base.?_definition))))
(assert (forall ((self~2@ Poly) (idx~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type idx~4@ NAT)) (<= 0 (main!impl_u.l1.impl&%0.entry_base.? self~2@ idx~4@))) :pattern ((main!impl_u.l1.impl&%0.entry_base.? self~2@ idx~4@)) :qid internal_main!impl_u.l1.impl&__0.entry_base.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_base.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::entry_bounds")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.entry_bounds.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.entry_bounds.) (forall ((self~2@ Poly) (entry~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.entry_bounds.? self~2@ entry~4@) (tuple%2./tuple%2 (I (main!impl_u.l1.impl&%0.entry_base.? self~2@ entry~4@)) (I (main!impl_u.l1.impl&%0.entry_base.? self~2@ (I (nClip (+ (%I entry~4@) 1))))))) :pattern ((main!impl_u.l1.impl&%0.entry_bounds.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.entry_bounds.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_bounds.?_definition))))
(assert (forall ((self~2@ Poly) (entry~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type entry~4@ NAT)) (has_type (Poly%tuple%2. (main!impl_u.l1.impl&%0.entry_bounds.? self~2@ entry~4@)) (TYPE%tuple%2. NAT NAT))) :pattern ((main!impl_u.l1.impl&%0.entry_bounds.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.entry_bounds.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.entry_bounds.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::interp_of_entry")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.interp_of_entry.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.interp_of_entry. Fuel)
(assert (forall ((self~2@ Poly) (entry~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ fuel%@) (main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.interp_of_entry._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_of_entry._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (entry~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ (succ fuel%@)) (ite (and (main!impl_u.l1.impl&%0.inv.? self~2@) (< (%I entry~4@) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@)))))) (let ((tmp%%1$ (main!impl_u.l1.impl&%0.entry_bounds.? self~2@ entry~4@))) (let ((lower~61$ (%I (tuple%2./tuple%2/field%0 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (let ((upper~62$ (%I (tuple%2./tuple%2/field%1 (%Poly%tuple%2. (Poly%tuple%2. tmp%%1$)))))) (main!impl_u.l0.PageTableContents./PageTableContents (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((tmp%%2$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) entry~4@)))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%2$) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (let ((p~86$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.) (I (main!impl_u.l1.impl&%0.entry_base.? self~2@ entry~4@)) (Poly%main!definitions_t.PageTableEntry. p~86$)))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%2$) (let ((d~108$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.rec%interp_aux.? (Poly%main!impl_u.l1.Directory. d~108$) (I 0) fuel%@))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.))))))) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))) (%I (I lower~61$)) (%I (I upper~62$)))))) (%Poly%main!impl_u.l0.PageTableContents. (vstd!pervasive.arbitrary.? TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.)))) :pattern ((main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.interp_of_entry._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_of_entry._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.interp_of_entry.) (forall ((self~2@ Poly) (entry~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.interp_of_entry.? self~2@ entry~4@) (main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ entry~4@ (succ (succ fuel_nat%main!impl_u.l1.impl&%0.interp_of_entry.)))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.interp_of_entry.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_of_entry.?_definition))))
(assert (forall ((self~2@ Poly) (entry~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type entry~4@ NAT)) (has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? self~2@ entry~4@)) TYPE%main!impl_u.l0.PageTableContents.)) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.interp_of_entry.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_of_entry.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::interp_aux")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.interp_aux.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.interp_aux. Fuel)
(assert (forall ((self~2@ Poly) (i~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ fuel%@) (main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.interp_aux._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_aux._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (i~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ (succ fuel%@)) (ite (main!impl_u.l1.impl&%0.inv.? self~2@) (ite (>= (%I i~4@) (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))))) (main!impl_u.l0.PageTableContents./PageTableContents (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.)) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))) (%I (I (main!impl_u.l1.impl&%0.upper_vaddr.? self~2@))) (%I (I (main!impl_u.l1.impl&%0.upper_vaddr.? self~2@)))) (let ((rem~98$ (main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ (I (nClip (+ (%I i~4@) 1))) fuel%@))) (let ((entry_i~107$ (main!impl_u.l1.impl&%0.rec%interp_of_entry.? self~2@ i~4@ fuel%@))) (main!impl_u.l0.PageTableContents./PageTableContents (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.union_prefer_right.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. rem~98$)))) (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. entry_i~107$)))))) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. entry_i~107$))))) (%I (I (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. rem~98$))))))))) (%Poly%main!impl_u.l0.PageTableContents. (vstd!pervasive.arbitrary.? TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents.)))) :pattern ((main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.interp_aux._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_aux._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.interp_aux.) (forall ((self~2@ Poly) (i~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.interp_aux.? self~2@ i~4@) (main!impl_u.l1.impl&%0.rec%interp_aux.? self~2@ i~4@ (succ fuel_nat%main!impl_u.l1.impl&%0.interp_aux.))) :pattern ((main!impl_u.l1.impl&%0.interp_aux.? self~2@ i~4@)) :qid internal_main!impl_u.l1.impl&__0.interp_aux.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_aux.?_definition))))
(assert (forall ((self~2@ Poly) (i~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type i~4@ NAT)) (has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? self~2@ i~4@)) TYPE%main!impl_u.l0.PageTableContents.)) :pattern ((main!impl_u.l1.impl&%0.interp_aux.? self~2@ i~4@)) :qid internal_main!impl_u.l1.impl&__0.interp_aux.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp_aux.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::interp")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.interp.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.interp.) (forall ((self~2@ Poly)) (! (= (main!impl_u.l1.impl&%0.interp.? self~2@) (main!impl_u.l1.impl&%0.interp_aux.? self~2@ (I 0))) :pattern ((main!impl_u.l1.impl&%0.interp.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.interp.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp.?_definition))))
(assert (forall ((self~2@ Poly)) (! (=> (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) TYPE%main!impl_u.l0.PageTableContents.)) :pattern ((main!impl_u.l1.impl&%0.interp.? self~2@)) :qid internal_main!impl_u.l1.impl&__0.interp.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.interp.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::index_from_offset")
(assert (fuel_bool_default fuel%main!impl_u.indexing.index_from_offset.))
(assert (=> (fuel_bool fuel%main!impl_u.indexing.index_from_offset.) (forall ((offset~2@ Poly) (entry_size~4@ Poly)) (! (= (main!impl_u.indexing.index_from_offset.? offset~2@ entry_size~4@) (nClip (EucDiv (%I offset~2@) (%I entry_size~4@)))) :pattern ((main!impl_u.indexing.index_from_offset.? offset~2@ entry_size~4@)) :qid internal_main!impl_u.indexing.index_from_offset.?_definition :skolemid skolem_internal_main!impl_u.indexing.index_from_offset.?_definition))))
(assert (forall ((offset~2@ Poly) (entry_size~4@ Poly)) (! (=> (and (has_type offset~2@ NAT) (has_type entry_size~4@ NAT)) (<= 0 (main!impl_u.indexing.index_from_offset.? offset~2@ entry_size~4@))) :pattern ((main!impl_u.indexing.index_from_offset.? offset~2@ entry_size~4@)) :qid internal_main!impl_u.indexing.index_from_offset.?_pre_post_definition :skolemid skolem_internal_main!impl_u.indexing.index_from_offset.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::index_from_base_and_addr")
(assert (fuel_bool_default fuel%main!impl_u.indexing.index_from_base_and_addr.))
(assert (=> (fuel_bool fuel%main!impl_u.indexing.index_from_base_and_addr.) (forall ((base~2@ Poly) (addr~4@ Poly) (entry_size~6@ Poly)) (! (= (main!impl_u.indexing.index_from_base_and_addr.? base~2@ addr~4@ entry_size~6@) (main!impl_u.indexing.index_from_offset.? (I (nClip (- (%I addr~4@) (%I base~2@)))) entry_size~6@)) :pattern ((main!impl_u.indexing.index_from_base_and_addr.? base~2@ addr~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.index_from_base_and_addr.?_definition :skolemid skolem_internal_main!impl_u.indexing.index_from_base_and_addr.?_definition))))
(assert (forall ((base~2@ Poly) (addr~4@ Poly) (entry_size~6@ Poly)) (! (=> (and (has_type base~2@ NAT) (has_type addr~4@ NAT) (has_type entry_size~6@ NAT)) (<= 0 (main!impl_u.indexing.index_from_base_and_addr.? base~2@ addr~4@ entry_size~6@))) :pattern ((main!impl_u.indexing.index_from_base_and_addr.? base~2@ addr~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.index_from_base_and_addr.?_pre_post_definition :skolemid skolem_internal_main!impl_u.indexing.index_from_base_and_addr.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::index_for_vaddr")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.index_for_vaddr.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.index_for_vaddr.) (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (vaddr~8@ Poly)) (! (= (main!definitions_t.impl&%7.index_for_vaddr.? self~2@ layer~4@ base~6@ vaddr~8@) (main!impl_u.indexing.index_from_base_and_addr.? base~6@ vaddr~8@ (I (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)))) :pattern ((main!definitions_t.impl&%7.index_for_vaddr.? self~2@ layer~4@ base~6@ vaddr~8@)) :qid internal_main!definitions_t.impl&__7.index_for_vaddr.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.index_for_vaddr.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (vaddr~8@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT) (has_type base~6@ NAT) (has_type vaddr~8@ NAT)) (<= 0 (main!definitions_t.impl&%7.index_for_vaddr.? self~2@ layer~4@ base~6@ vaddr~8@))) :pattern ((main!definitions_t.impl&%7.index_for_vaddr.? self~2@ layer~4@ base~6@ vaddr~8@)) :qid internal_main!definitions_t.impl&__7.index_for_vaddr.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.index_for_vaddr.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::index_for_vaddr")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.index_for_vaddr.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.index_for_vaddr.) (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ vaddr~4@) (main!impl_u.indexing.index_from_base_and_addr.? (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@))) vaddr~4@ (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))))))) :pattern ((main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l1.impl&__0.index_for_vaddr.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.index_for_vaddr.?_definition))))
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type vaddr~4@ NAT)) (<= 0 (main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ vaddr~4@))) :pattern ((main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l1.impl&__0.index_for_vaddr.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.index_for_vaddr.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::next_entry_base_from_index")
(assert (fuel_bool_default fuel%main!impl_u.indexing.next_entry_base_from_index.))
(assert (=> (fuel_bool fuel%main!impl_u.indexing.next_entry_base_from_index.) (forall ((base~2@ Poly) (idx~4@ Poly) (entry_size~6@ Poly)) (! (= (main!impl_u.indexing.next_entry_base_from_index.? base~2@ idx~4@ entry_size~6@) (nClip (+ (%I base~2@) (nClip (Mul (nClip (+ (%I idx~4@) 1)) (%I entry_size~6@)))))) :pattern ((main!impl_u.indexing.next_entry_base_from_index.? base~2@ idx~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.next_entry_base_from_index.?_definition :skolemid skolem_internal_main!impl_u.indexing.next_entry_base_from_index.?_definition))))
(assert (forall ((base~2@ Poly) (idx~4@ Poly) (entry_size~6@ Poly)) (! (=> (and (has_type base~2@ NAT) (has_type idx~4@ NAT) (has_type entry_size~6@ NAT)) (<= 0 (main!impl_u.indexing.next_entry_base_from_index.? base~2@ idx~4@ entry_size~6@))) :pattern ((main!impl_u.indexing.next_entry_base_from_index.? base~2@ idx~4@ entry_size~6@)) :qid internal_main!impl_u.indexing.next_entry_base_from_index.?_pre_post_definition :skolemid skolem_internal_main!impl_u.indexing.next_entry_base_from_index.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::next_entry_base")
(assert (fuel_bool_default fuel%main!definitions_t.impl&%7.next_entry_base.))
(assert (=> (fuel_bool fuel%main!definitions_t.impl&%7.next_entry_base.) (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (= (main!definitions_t.impl&%7.next_entry_base.? self~2@ layer~4@ base~6@ idx~8@) (main!impl_u.indexing.next_entry_base_from_index.? base~6@ idx~8@ (I (main!definitions_t.impl&%7.entry_size.? self~2@ layer~4@)))) :pattern ((main!definitions_t.impl&%7.next_entry_base.? self~2@ layer~4@ base~6@ idx~8@)) :qid internal_main!definitions_t.impl&__7.next_entry_base.?_definition :skolemid skolem_internal_main!definitions_t.impl&__7.next_entry_base.?_definition))))
(assert (forall ((self~2@ Poly) (layer~4@ Poly) (base~6@ Poly) (idx~8@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!definitions_t.Arch.) (has_type layer~4@ NAT) (has_type base~6@ NAT) (has_type idx~8@ NAT)) (<= 0 (main!definitions_t.impl&%7.next_entry_base.? self~2@ layer~4@ base~6@ idx~8@))) :pattern ((main!definitions_t.impl&%7.next_entry_base.? self~2@ layer~4@ base~6@ idx~8@)) :qid internal_main!definitions_t.impl&__7.next_entry_base.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.impl&__7.next_entry_base.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::next_entry_base")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.next_entry_base.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.next_entry_base.) (forall ((self~2@ Poly) (idx~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.next_entry_base.? self~2@ idx~4@) (main!impl_u.indexing.next_entry_base_from_index.? (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@))) idx~4@ (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@))))))) :pattern ((main!impl_u.l1.impl&%0.next_entry_base.? self~2@ idx~4@)) :qid internal_main!impl_u.l1.impl&__0.next_entry_base.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.next_entry_base.?_definition))))
(assert (forall ((self~2@ Poly) (idx~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type idx~4@ NAT)) (<= 0 (main!impl_u.l1.impl&%0.next_entry_base.? self~2@ idx~4@))) :pattern ((main!impl_u.l1.impl&%0.next_entry_base.? self~2@ idx~4@)) :qid internal_main!impl_u.l1.impl&__0.next_entry_base.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.next_entry_base.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::lemma_entry_base_from_index")
(declare-fun ens%main!impl_u.indexing.lemma_entry_base_from_index. (Int Int Int) Bool)
(assert (forall ((base~2@ Int) (idx~4@ Int) (entry_size~6@ Int)) (! (= (ens%main!impl_u.indexing.lemma_entry_base_from_index. base~2@ idx~4@ entry_size~6@) (and (forall ((idx2~37$ Poly)) (! (=> (has_type idx2~37$ NAT) (=> (< idx~4@ (%I idx2~37$)) (< (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (main!impl_u.indexing.entry_base_from_index.? (I base~2@) idx2~37$ (I entry_size~6@))))) :pattern ((main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (main!impl_u.indexing.entry_base_from_index.? (I base~2@) idx2~37$ (I entry_size~6@))) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_99 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_99)) (forall ((idx2~103$ Poly)) (! (=> (has_type idx2~103$ NAT) (=> (< idx~4@ (%I idx2~103$)) (<= (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (main!impl_u.indexing.entry_base_from_index.? (I base~2@) idx2~103$ (I entry_size~6@))))) :pattern ((main!impl_u.indexing.entry_base_from_index.? (I base~2@) idx2~103$ (I entry_size~6@))) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_100 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_100)) (= (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I (nClip (+ idx~4@ 1))) (I entry_size~6@))) (= (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (nClip (+ (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) entry_size~6@))) (= (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@)) (nClip (+ entry_size~6@ (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))))) (forall ((n~229$ Poly)) (! (=> (has_type n~229$ NAT) (=> (and (and (< 0 (%I n~229$)) (main!definitions_t.aligned.? (I base~2@) n~229$)) (main!definitions_t.aligned.? (I entry_size~6@) n~229$)) (main!definitions_t.aligned.? (I (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))) n~229$))) :pattern ((main!definitions_t.aligned.? (I (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))) n~229$)) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_101 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_101)) (forall ((n~284$ Poly)) (! (=> (has_type n~284$ NAT) (=> (and (and (< 0 (%I n~284$)) (main!definitions_t.aligned.? (I base~2@) n~284$)) (main!definitions_t.aligned.? (I entry_size~6@) n~284$)) (main!definitions_t.aligned.? (I (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))) n~284$))) :pattern ((main!definitions_t.aligned.? (I (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))) n~284$)) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_102 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_102)) (=> (main!definitions_t.aligned.? (I base~2@) (I entry_size~6@)) (main!definitions_t.aligned.? (I (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))) (I entry_size~6@))) (<= base~2@ (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~4@) (I entry_size~6@))))) :pattern ((ens%main!impl_u.indexing.lemma_entry_base_from_index. base~2@ idx~4@ entry_size~6@)) :qid internal_ens__main!impl_u.indexing.lemma_entry_base_from_index._definition :skolemid skolem_internal_ens__main!impl_u.indexing.lemma_entry_base_from_index._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::nat_mul")
(assert (fuel_bool_default fuel%main!impl_u.indexing.nat_mul.))
(assert (=> (fuel_bool fuel%main!impl_u.indexing.nat_mul.) (forall ((a~2@ Poly) (b~4@ Poly)) (! (= (main!impl_u.indexing.nat_mul.? a~2@ b~4@) (nClip (Mul (%I a~2@) (%I b~4@)))) :pattern ((main!impl_u.indexing.nat_mul.? a~2@ b~4@)) :qid internal_main!impl_u.indexing.nat_mul.?_definition :skolemid skolem_internal_main!impl_u.indexing.nat_mul.?_definition))))
(assert (forall ((a~2@ Poly) (b~4@ Poly)) (! (=> (and (has_type a~2@ NAT) (has_type b~4@ NAT)) (<= 0 (main!impl_u.indexing.nat_mul.? a~2@ b~4@))) :pattern ((main!impl_u.indexing.nat_mul.? a~2@ b~4@)) :qid internal_main!impl_u.indexing.nat_mul.?_pre_post_definition :skolemid skolem_internal_main!impl_u.indexing.nat_mul.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::lib::mod_mult_zero_implies_mod_zero")
(declare-fun ens%main!impl_u.lib.mod_mult_zero_implies_mod_zero. (Int Int Int) Bool)
(assert (forall ((a~2@ Int) (b~4@ Int) (c~6@ Int)) (! (= (ens%main!impl_u.lib.mod_mult_zero_implies_mod_zero. a~2@ b~4@ c~6@) (main!definitions_t.aligned.? (I a~2@) (I b~4@))) :pattern ((ens%main!impl_u.lib.mod_mult_zero_implies_mod_zero. a~2@ b~4@ c~6@)) :qid internal_ens__main!impl_u.lib.mod_mult_zero_implies_mod_zero._definition :skolemid skolem_internal_ens__main!impl_u.lib.mod_mult_zero_implies_mod_zero._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::lemma_entry_base_from_index_support")
(declare-fun ens%main!impl_u.indexing.lemma_entry_base_from_index_support. (Int Int Int) Bool)
(assert (forall ((base~2@ Int) (idx~4@ Int) (entry_size~6@ Int)) (! (= (ens%main!impl_u.indexing.lemma_entry_base_from_index_support. base~2@ idx~4@ entry_size~6@) (and (forall ((a~23$ Int) (b~25$ Int)) (! (=> (and (<= 0 a~23$) (<= 0 b~25$)) (= (main!impl_u.indexing.nat_mul.? (I a~23$) (I b~25$)) (nClip (Mul a~23$ b~25$)))) :pattern ((nClip (Mul a~23$ b~25$))) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_support_103 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_support_103)) (forall ((a~55$ Poly) (b~57$ Poly)) (! (=> (and (has_type a~55$ NAT) (has_type b~57$ NAT)) (= (main!impl_u.indexing.nat_mul.? a~55$ b~57$) (main!impl_u.indexing.nat_mul.? b~57$ a~55$))) :pattern ((main!impl_u.indexing.nat_mul.? a~55$ b~57$)) :pattern ((main!impl_u.indexing.nat_mul.? b~57$ a~55$)) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_support_104 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_support_104)) (forall ((a~88$ Poly)) (! (=> (has_type a~88$ NAT) (=> (and (main!definitions_t.aligned.? (I base~2@) (I (main!impl_u.indexing.nat_mul.? (I entry_size~6@) a~88$))) (> (%I a~88$) 0)) (main!definitions_t.aligned.? (I base~2@) (I entry_size~6@)))) :pattern ((main!definitions_t.aligned.? (I base~2@) (I (main!impl_u.indexing.nat_mul.? (I entry_size~6@) a~88$)))) :qid user_main__impl_u__indexing__lemma_entry_base_from_index_support_105 :skolemid skolem_user_main__impl_u__indexing__lemma_entry_base_from_index_support_105)))) :pattern ((ens%main!impl_u.indexing.lemma_entry_base_from_index_support. base~2@ idx~4@ entry_size~6@)) :qid internal_ens__main!impl_u.indexing.lemma_entry_base_from_index_support._definition :skolemid skolem_internal_ens__main!impl_u.indexing.lemma_entry_base_from_index_support._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_inv_implies_interp_aux_inv")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. self~2@ i~4@) (and (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))) (=> (<= i~4@ (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))))) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))) (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (main!impl_u.l1.impl&%0.upper_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> (= i~4@ 0) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I 0))))) (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_aux_inv. self~2@ i~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_aux_inv._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_aux_inv._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_inv_implies_interp_inv")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. self~2@) (and (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))) (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))) (main!impl_u.l1.impl&%0.upper_vaddr.? (Poly%main!impl_u.l1.Directory. self~2@))) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))) (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_inv. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_inv._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_inv._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_inv_implies_interp_of_entry_inv")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. self~2@ i~4@) (and (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))) (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ i~4@ 1))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_inv_implies_interp_of_entry_inv. self~2@ i~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_of_entry_inv._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_inv_implies_interp_of_entry_inv._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_of_entry")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry. self~2@) (forall ((i~27$ Poly)) (! (=> (has_type i~27$ NAT) (=> (< (%I i~27$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (and (and (and (and (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$))) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$))) (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ (%I i~27$) 1)))))) (forall ((base~104$ Poly)) (! (=> (has_type base~104$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)))))) base~104$) (main!definitions_t.between.? base~104$ (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ (%I i~27$) 1)))))))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)))))) base~104$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_106 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_106))) (forall ((base~157$ Poly) (pte~159$ Poly)) (! (=> (and (has_type base~157$ NAT) (has_type pte~159$ TYPE%main!definitions_t.PageTableEntry.)) (=> (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$))))) base~157$ pte~159$) (main!definitions_t.between.? base~157$ (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ (%I i~27$) 1)))))))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$))))) base~157$ pte~159$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_107 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_107))))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_108 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_108))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_of_entries_disjoint")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. self~2@) (forall ((i~27$ Poly) (j~29$ Poly)) (! (=> (and (has_type i~27$ NAT) (has_type j~29$ NAT)) (=> (and (and (< (%I i~27$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (< (%I j~29$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (not (= i~27$ j~29$))) (main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) j~29$))))) :pattern ((main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) j~29$)))) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entries_disjoint_109 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entries_disjoint_109))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_of_entries_disjoint. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entries_disjoint._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entries_disjoint._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_empty_implies_interp_aux_empty")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. self~2@ i~4@) (and (= (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.))) (= (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) (vstd!set.impl&%0.empty.? NAT NAT)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_aux_empty. self~2@ i~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_aux_empty._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_aux_empty._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_empty_implies_interp_empty")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. self~2@) (and (= (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))) (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.empty.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry.))) (= (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) (vstd!set.impl&%0.empty.? NAT NAT)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_empty_implies_interp_empty. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_empty._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_empty_implies_interp_empty._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_ranges_disjoint_interp_aux_interp_of_entry")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. self~2@) (forall ((i~27$ Poly) (j~29$ Poly)) (! (=> (and (has_type i~27$ NAT) (has_type j~29$ NAT)) (=> (and (< (%I j~29$) (%I i~27$)) (< (%I i~27$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@)))) (main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) j~29$))))) :pattern ((main!impl_u.l0.impl&%0.ranges_disjoint.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) i~27$)) (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) j~29$)))) :qid user_main__impl_u__l1__Directory__lemma_ranges_disjoint_interp_aux_interp_of_entry_110 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_ranges_disjoint_interp_aux_interp_of_entry_110))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_ranges_disjoint_interp_aux_interp_of_entry. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_ranges_disjoint_interp_aux_interp_of_entry._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_ranges_disjoint_interp_aux_interp_of_entry._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. (main!impl_u.l1.Directory. Int Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int) (j~6@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. self~2@ i~4@ j~6@) (and (forall ((va~46$ Poly) (pte~48$ Poly)) (! (=> (and (has_type va~46$ NAT) (has_type pte~48$ TYPE%main!definitions_t.PageTableEntry.)) (=> (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@)))))) va~46$ pte~48$) (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))))) va~46$ pte~48$))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@)))))) va~46$ pte~48$)) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))))) va~46$ pte~48$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_111 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_111)) (forall ((va~91$ Poly)) (! (=> (has_type va~91$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))))))) va~91$) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) va~91$))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))))))) va~91$)) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) va~91$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_112 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_112)) (forall ((va~132$ Poly)) (! (=> (has_type va~132$ NAT) (=> (and (main!definitions_t.between.? va~132$ (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ j~6@ 1)))))) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))))))) va~132$))) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) va~132$)))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@))))))) va~132$)) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))))) va~132$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_113 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping_113)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping. self~2@ i~4@ j~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_aux_contains_mapping._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. self~2@ j~4@) (and (forall ((va~38$ Poly)) (! (=> (has_type va~38$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) va~38$) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) va~38$))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) va~38$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_114 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_114)) (forall ((va~77$ Poly) (pte~79$ Poly)) (! (=> (and (has_type va~77$ NAT) (has_type pte~79$ TYPE%main!definitions_t.PageTableEntry.)) (=> (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) va~77$ pte~79$) (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) va~77$ pte~79$))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) va~77$ pte~79$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_115 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_115)) (forall ((va~120$ Poly)) (! (=> (has_type va~120$ NAT) (=> (and (main!definitions_t.between.? va~120$ (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))) (I (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I (nClip (+ j~4@ 1)))))) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) va~120$))) (not (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) va~120$)))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) va~120$)) :qid user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_116 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping_116)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping. self~2@ j~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_of_entry_contains_mapping_implies_interp_contains_mapping._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::ambient_lemmas2")
(declare-fun ens%main!impl_u.l1.ambient_lemmas2. (Int) Bool)
(assert (forall ((no%param@ Int)) (! (= (ens%main!impl_u.l1.ambient_lemmas2. no%param@) (and (forall ((d~14$ Poly) (i~16$ Poly)) (! (=> (and (has_type d~14$ TYPE%main!impl_u.l1.Directory.) (has_type i~16$ NAT)) (=> (and (and (main!impl_u.l1.impl&%0.inv.? d~14$) (< (%I i~16$) (main!impl_u.l1.impl&%0.num_entries.? d~14$))) ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. d~14$))) i~16$)))) (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. d~14$))) i~16$))))))) :pattern ((main!impl_u.l1.impl&%0.inv.? d~14$) (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. d~14$))) i~16$)) :qid user_main__impl_u__l1__ambient_lemmas2_117 :skolemid skolem_user_main__impl_u__l1__ambient_lemmas2_117)) (forall ((d~109$ Poly)) (! (=> (has_type d~109$ TYPE%main!impl_u.l1.Directory.) (=> (main!impl_u.l1.impl&%0.inv.? d~109$) (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? d~109$)))) (main!impl_u.l1.impl&%0.upper_vaddr.? d~109$)))) :pattern ((main!impl_u.l1.impl&%0.interp.? d~109$)) :qid user_main__impl_u__l1__ambient_lemmas2_118 :skolemid skolem_user_main__impl_u__l1__ambient_lemmas2_118)) (forall ((d~142$ Poly)) (! (=> (has_type d~142$ TYPE%main!impl_u.l1.Directory.) (=> (main!impl_u.l1.impl&%0.inv.? d~142$) (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? d~142$)))) (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. d~142$))))) :pattern ((main!impl_u.l1.impl&%0.interp.? d~142$)) :qid user_main__impl_u__l1__ambient_lemmas2_119 :skolemid skolem_user_main__impl_u__l1__ambient_lemmas2_119)))) :pattern ((ens%main!impl_u.l1.ambient_lemmas2. no%param@)) :qid internal_ens__main!impl_u.l1.ambient_lemmas2._definition :skolemid skolem_internal_ens__main!impl_u.l1.ambient_lemmas2._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::indexing::lemma_index_from_base_and_addr")
(declare-fun ens%main!impl_u.indexing.lemma_index_from_base_and_addr. (Int Int Int Int) Bool)
(assert (forall ((base~2@ Int) (addr~4@ Int) (entry_size~6@ Int) (num_entries~8@ Int)) (! (= (ens%main!impl_u.indexing.lemma_index_from_base_and_addr. base~2@ addr~4@ entry_size~6@ num_entries~8@) (let ((idx~63$ (main!impl_u.indexing.index_from_base_and_addr.? (I base~2@) (I addr~4@) (I entry_size~6@)))) (and (and (< idx~63$ num_entries~8@) (main!definitions_t.between.? (I addr~4@) (I (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~63$) (I entry_size~6@))) (I (main!impl_u.indexing.next_entry_base_from_index.? (I base~2@) (I idx~63$) (I entry_size~6@))))) (=> (and (main!definitions_t.aligned.? (I base~2@) (I entry_size~6@)) (main!definitions_t.aligned.? (I addr~4@) (I entry_size~6@))) (= addr~4@ (main!impl_u.indexing.entry_base_from_index.? (I base~2@) (I idx~63$) (I entry_size~6@))))))) :pattern ((ens%main!impl_u.indexing.lemma_index_from_base_and_addr. base~2@ addr~4@ entry_size~6@ num_entries~8@)) :qid internal_ens__main!impl_u.indexing.lemma_index_from_base_and_addr._definition :skolemid skolem_internal_ens__main!impl_u.indexing.lemma_index_from_base_and_addr._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::resolve")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.resolve.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.resolve. Fuel)
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ fuel%@) (main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.resolve._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.resolve._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly) (fuel%@ Fuel)) (! (=> (and (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) vaddr~4@)) (= (main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ (succ fuel%@)) (let ((entry~74$ (main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ vaddr~4@))) (let ((tmp%%1$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) (I entry~74$))))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%1$) (let ((pte~93$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) (let ((offset~109$ (- (%I vaddr~4@) (main!impl_u.l1.impl&%0.entry_base.? self~2@ (I entry~74$))))) (core!result.Result./Ok (Poly%tuple%2. (tuple%2./tuple%2 (I (main!impl_u.l1.impl&%0.entry_base.? self~2@ (I entry~74$))) (Poly%main!definitions_t.PageTableEntry. pte~93$)))))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%1$) (let ((d~125$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) (main!impl_u.l1.impl&%0.rec%resolve.? (Poly%main!impl_u.l1.Directory. d~125$) vaddr~4@ fuel%@)) (core!result.Result./Err (Poly%tuple%0. tuple%0./tuple%0)))))))) :pattern ((main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.resolve._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.resolve._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.resolve.) (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (=> (and (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) vaddr~4@)) (= (main!impl_u.l1.impl&%0.resolve.? self~2@ vaddr~4@) (main!impl_u.l1.impl&%0.rec%resolve.? self~2@ vaddr~4@ (succ fuel_nat%main!impl_u.l1.impl&%0.resolve.)))) :pattern ((main!impl_u.l1.impl&%0.resolve.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l1.impl&__0.resolve.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.resolve.?_definition))))
(assert (forall ((self~2@ Poly) (vaddr~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type vaddr~4@ NAT)) (has_type (Poly%core!result.Result. (main!impl_u.l1.impl&%0.resolve.? self~2@ vaddr~4@)) (TYPE%core!result.Result. (TYPE%tuple%2. NAT TYPE%main!definitions_t.PageTableEntry.) TYPE%tuple%0.))) :pattern ((main!impl_u.l1.impl&%0.resolve.? self~2@ vaddr~4@)) :qid internal_main!impl_u.l1.impl&__0.resolve.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.resolve.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_aux_contains_implies_interp_of_entry_contains")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. self~2@ j~4@) (and (forall ((base~29$ Poly) (pte~31$ Poly)) (! (=> (and (has_type base~29$ NAT) (has_type pte~31$ TYPE%main!definitions_t.PageTableEntry.)) (=> (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) base~29$ pte~31$) (exists ((i~57$ Poly)) (! (and (has_type i~57$ NAT) (and (< (%I i~57$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~57$))))) base~29$ pte~31$))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~57$)) :qid user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_120 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_120)))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@)))))) base~29$ pte~31$)) :qid user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_121 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_121)) (forall ((base~93$ Poly)) (! (=> (has_type base~93$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) base~93$) (exists ((i~119$ Poly)) (! (and (has_type i~119$ NAT) (and (< (%I i~119$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~119$)))))) base~93$))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~119$)) :qid user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_122 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_122)))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@))))))) base~93$)) :qid user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_123 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_aux_contains_implies_interp_of_entry_contains_123)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_aux_contains_implies_interp_of_entry_contains. self~2@ j~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_aux_contains_implies_interp_of_entry_contains._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_aux_contains_implies_interp_of_entry_contains._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_interp_contains_implies_interp_of_entry_contains")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. self~2@) (and (forall ((base~27$ Poly) (pte~29$ Poly)) (! (=> (and (has_type base~27$ NAT) (has_type pte~29$ TYPE%main!definitions_t.PageTableEntry.)) (=> (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) base~27$ pte~29$) (exists ((i~53$ Poly)) (! (and (has_type i~53$ NAT) (and (< (%I i~53$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~53$))))) base~27$ pte~29$))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~53$)) :qid user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_124 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_124)))) :pattern ((vstd!map.impl&%0.contains_pair.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) base~27$ pte~29$)) :qid user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_125 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_125)) (forall ((base~89$ Poly)) (! (=> (has_type base~89$ NAT) (=> (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) base~89$) (exists ((i~113$ Poly)) (! (and (has_type i~113$ NAT) (and (< (%I i~113$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. self~2@))) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~113$)))))) base~89$))) :pattern ((main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) i~113$)) :qid user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_126 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_126)))) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) base~89$)) :qid user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_127 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_interp_contains_implies_interp_of_entry_contains_127)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_interp_contains_implies_interp_of_entry_contains. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_interp_contains_implies_interp_of_entry_contains._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_interp_contains_implies_interp_of_entry_contains._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. (main!impl_u.l1.Directory. Int Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int) (i~6@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. self~2@ vaddr~4@ i~6@) (not (exists ((base~108$ Poly)) (! (and (has_type base~108$ NAT) (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) base~108$) (main!definitions_t.between.? (I vaddr~4@) base~108$ (I (nClip (+ (%I base~108$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) base~108$)))))))))))) :pattern ((vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) base~108$)) :qid user_main__impl_u__l1__Directory__lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp_129 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp_129)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp. self~2@ vaddr~4@ i~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_no_mapping_in_interp_of_entry_implies_no_mapping_in_interp._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_resolve_structure_assertions")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. (main!impl_u.l1.Directory. Int Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int) (idx~6@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. self~2@ vaddr~4@ idx~6@) (=> ((_ is main!impl_u.l1.NodeEntry./Directory) (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I idx~6@)))) (let ((d~87$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I idx~6@)))))) (and (main!impl_u.l0.impl&%0.accepted_resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. d~87$))) (I vaddr~4@)) (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. d~87$)))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_resolve_structure_assertions. self~2@ vaddr~4@ idx~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_resolve_structure_assertions._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_resolve_structure_assertions._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_resolve_refines")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_resolve_refines. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (vaddr~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_resolve_refines. self~2@ vaddr~4@) (= (main!impl_u.l0.impl&%0.resolve.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I vaddr~4@)) (main!impl_u.l1.impl&%0.resolve.? (Poly%main!impl_u.l1.Directory. self~2@) (I vaddr~4@)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_resolve_refines. self~2@ vaddr~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_resolve_refines._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_resolve_refines._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::update")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.update.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.update.) (forall ((self~2@ Poly) (n~4@ Poly) (e~6@ Poly)) (! (= (main!impl_u.l1.impl&%0.update.? self~2@ n~4@ e~6@) (main!impl_u.l1.Directory./Directory (%Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (vstd!seq.Seq.update.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) n~4@ e~6@)) (%I (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)))) (%I (I (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@)))) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((main!impl_u.l1.impl&%0.update.? self~2@ n~4@ e~6@)) :qid internal_main!impl_u.l1.impl&__0.update.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.update.?_definition))))
(assert (forall ((self~2@ Poly) (n~4@ Poly) (e~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type n~4@ NAT) (has_type e~6@ TYPE%main!impl_u.l1.NodeEntry.)) (has_type (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ n~4@ e~6@)) TYPE%main!impl_u.l1.Directory.)) :pattern ((main!impl_u.l1.impl&%0.update.? self~2@ n~4@ e~6@)) :qid internal_main!impl_u.l1.impl&__0.update.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.update.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::candidate_mapping_in_bounds")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@) (and (<= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. self~2@)) (%I base~4@)) (<= (nClip (+ (%I base~4@) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l1.impl&%0.upper_vaddr.? self~2@)))) :pattern ((main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l1.impl&__0.candidate_mapping_in_bounds.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.candidate_mapping_in_bounds.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::accepted_mapping")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.accepted_mapping.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.accepted_mapping.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l1.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@) (and (and (and (main!definitions_t.aligned.? base~4@ (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!definitions_t.aligned.? (I (main!definitions_t.MemRegion./MemRegion/base (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))))) (main!impl_u.l1.impl&%0.candidate_mapping_in_bounds.? self~2@ base~4@ pte~6@)) (main!definitions_t.impl&%7.contains_entry_size_at_index_atleast.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (I (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((main!impl_u.l1.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l1.impl&__0.accepted_mapping.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.accepted_mapping.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_accepted_mapping_implies_interp_accepted_mapping_manual")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. self~2@ base~4@ pte~6@) (main!impl_u.l0.impl&%0.accepted_mapping.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual. self~2@ base~4@ pte~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_manual._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_accepted_mapping_implies_interp_accepted_mapping_auto")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_auto. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_auto. self~2@) (forall ((base~16$ Poly) (pte~18$ Poly)) (! (=> (and (has_type base~16$ NAT) (has_type pte~18$ TYPE%main!definitions_t.PageTableEntry.)) (=> (and (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)) (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) base~16$ pte~18$)) (main!impl_u.l0.impl&%0.accepted_mapping.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) base~16$ pte~18$))) :pattern ((main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. self~2@) base~16$ pte~18$)) :qid user_main__impl_u__l1__Directory__lemma_accepted_mapping_implies_interp_accepted_mapping_auto_130 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_accepted_mapping_implies_interp_accepted_mapping_auto_130))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_interp_accepted_mapping_auto. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_auto._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_interp_accepted_mapping_auto._definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::new_seq")
(assert (fuel_bool_default fuel%main!definitions_t.new_seq.))
(declare-const fuel_nat%main!definitions_t.new_seq. Fuel)
(assert (forall ((T& Type) (T&. Type) (i~2@ Poly) (e~4@ Poly) (fuel%@ Fuel)) (! (= (main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ fuel%@) (main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ zero)) :pattern ((main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ fuel%@)) :qid internal_main!definitions_t.new_seq._fuel_to_zero_definition :skolemid skolem_internal_main!definitions_t.new_seq._fuel_to_zero_definition)))
(assert (forall ((T& Type) (T&. Type) (i~2@ Poly) (e~4@ Poly) (fuel%@ Fuel)) (! (= (main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ (succ fuel%@)) (ite (= (%I i~2@) 0) (vstd!seq.Seq.empty.? T& T&.) (vstd!seq.Seq.add.? T& T&. (main!definitions_t.rec%new_seq.? T& T&. (I (nClip (- (%I i~2@) 1))) e~4@ fuel%@) (vstd!seq.Seq.push.? T& T&. (vstd!seq.Seq.empty.? T& T&.) e~4@)))) :pattern ((main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ (succ fuel%@))) :qid internal_main!definitions_t.new_seq._fuel_to_body_definition :skolemid skolem_internal_main!definitions_t.new_seq._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!definitions_t.new_seq.) (forall ((T& Type) (T&. Type) (i~2@ Poly) (e~4@ Poly)) (! (= (main!definitions_t.new_seq.? T& T&. i~2@ e~4@) (main!definitions_t.rec%new_seq.? T& T&. i~2@ e~4@ (succ fuel_nat%main!definitions_t.new_seq.))) :pattern ((main!definitions_t.new_seq.? T& T&. i~2@ e~4@)) :qid internal_main!definitions_t.new_seq.?_definition :skolemid skolem_internal_main!definitions_t.new_seq.?_definition))))
(assert (forall ((T& Type) (T&. Type) (i~2@ Poly) (e~4@ Poly)) (! (=> (and (has_type i~2@ NAT) (has_type e~4@ T&)) (has_type (main!definitions_t.new_seq.? T& T&. i~2@ e~4@) (TYPE%vstd!seq.Seq. T&))) :pattern ((main!definitions_t.new_seq.? T& T&. i~2@ e~4@)) :qid internal_main!definitions_t.new_seq.?_pre_post_definition :skolemid skolem_internal_main!definitions_t.new_seq.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::new_empty_dir")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.new_empty_dir.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.new_empty_dir.) (forall ((self~2@ Poly) (entry~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.new_empty_dir.? self~2@ entry~4@) (main!impl_u.l1.Directory./Directory (%Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!definitions_t.new_seq.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (I (main!definitions_t.impl&%7.num_entries.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@))) (I (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) 1))))) (Poly%main!impl_u.l1.NodeEntry. main!impl_u.l1.NodeEntry./Empty))) (%I (I (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. self~2@)) 1)))) (%I (I (main!impl_u.l1.impl&%0.entry_base.? self~2@ entry~4@))) (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. self~2@)))))) :pattern ((main!impl_u.l1.impl&%0.new_empty_dir.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.new_empty_dir.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.new_empty_dir.?_definition))))
(assert (forall ((self~2@ Poly) (entry~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type entry~4@ NAT)) (has_type (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? self~2@ entry~4@)) TYPE%main!impl_u.l1.Directory.)) :pattern ((main!impl_u.l1.impl&%0.new_empty_dir.? self~2@ entry~4@)) :qid internal_main!impl_u.l1.impl&__0.new_empty_dir.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.new_empty_dir.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::lemma_new_seq")
(declare-fun ens%main!definitions_t.lemma_new_seq. (Type Type Int Poly) Bool)
(assert (forall ((T& Type) (T&. Type) (i~2@ Int) (e~4@ Poly)) (! (= (ens%main!definitions_t.lemma_new_seq. T& T&. i~2@ e~4@) (and (= (vstd!seq.Seq.len.? T& T&. (main!definitions_t.new_seq.? T& T&. (I i~2@) e~4@)) i~2@) (forall ((j~34$ Poly)) (! (=> (has_type j~34$ NAT) (=> (< (%I j~34$) i~2@) (= (vstd!seq.Seq.index.? T& T&. (main!definitions_t.new_seq.? T& T&. (I i~2@) e~4@) j~34$) e~4@))) :pattern ((vstd!seq.Seq.index.? T& T&. (main!definitions_t.new_seq.? T& T&. (I i~2@) e~4@) j~34$)) :qid user_main__definitions_t__lemma_new_seq_131 :skolemid skolem_user_main__definitions_t__lemma_new_seq_131)))) :pattern ((ens%main!definitions_t.lemma_new_seq. T& T&. i~2@ e~4@)) :qid internal_ens__main!definitions_t.lemma_new_seq._definition :skolemid skolem_internal_ens__main!definitions_t.lemma_new_seq._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_new_empty_dir")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_new_empty_dir. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (entry~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_new_empty_dir. self~2@ entry~4@) (and (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I entry~4@)))) (= (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I entry~4@))))))) (main!definitions_t.impl&%7.num_entries.? (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) 1))))) (forall ((j~102$ Poly)) (! (=> (has_type j~102$ NAT) (=> (< (%I j~102$) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I entry~4@))))) (= (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I entry~4@)))))) j~102$)) main!impl_u.l1.NodeEntry./Empty))) :pattern ((vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I entry~4@)))))) j~102$)) :qid user_main__impl_u__l1__Directory__lemma_new_empty_dir_132 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_new_empty_dir_132)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_new_empty_dir. self~2@ entry~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_new_empty_dir._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_new_empty_dir._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::map_frame")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.map_frame.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.map_frame. Fuel)
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ fuel%@) (main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.map_frame._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.map_frame._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ (succ fuel%@)) (ite (and (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l1.impl&%0.accepted_mapping.? self~2@ base~4@ pte~6@)) (let ((entry~55$ (main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ base~4@))) (let ((tmp%%2$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) (I entry~55$))))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%2$) (let ((p~74$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (core!result.Result./Err self~2@)) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%2$) (let ((d~86$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (ite (= (main!impl_u.l1.impl&%0.entry_size.? self~2@) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (core!result.Result./Err self~2@) (let ((tmp%%1$ (main!impl_u.l1.impl&%0.rec%map_frame.? (Poly%main!impl_u.l1.Directory. d~86$) base~4@ pte~6@ fuel%@))) (ite ((_ is core!result.Result./Ok) tmp%%1$) (let ((d~123$ (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%1$)))))) (core!result.Result./Ok (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~55$) (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~123$)))))))) (let ((d~142$ (%Poly%main!impl_u.l1.Directory. (core!result.Result./Err/_0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%1$)))))) (core!result.Result./Err (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~55$) (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~142$)))))))))))) (ite (= (main!impl_u.l1.impl&%0.entry_size.? self~2@) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (core!result.Result./Ok (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~55$) (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Page (%Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (let ((new_dir~208$ (main!impl_u.l1.impl&%0.new_empty_dir.? self~2@ (I entry~55$)))) (core!result.Result./Ok (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~55$) (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.rec%map_frame.? (Poly%main!impl_u.l1.Directory. new_dir~208$) base~4@ pte~6@ fuel%@)))))))))))))))) (%Poly%core!result.Result. (vstd!pervasive.arbitrary.? (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.) (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.))))) :pattern ((main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.map_frame._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.map_frame._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.map_frame.) (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (= (main!impl_u.l1.impl&%0.map_frame.? self~2@ base~4@ pte~6@) (main!impl_u.l1.impl&%0.rec%map_frame.? self~2@ base~4@ pte~6@ (succ fuel_nat%main!impl_u.l1.impl&%0.map_frame.))) :pattern ((main!impl_u.l1.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l1.impl&__0.map_frame.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.map_frame.?_definition))))
(assert (forall ((self~2@ Poly) (base~4@ Poly) (pte~6@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type base~4@ NAT) (has_type pte~6@ TYPE%main!definitions_t.PageTableEntry.)) (has_type (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.))) :pattern ((main!impl_u.l1.impl&%0.map_frame.? self~2@ base~4@ pte~6@)) :qid internal_main!impl_u.l1.impl&__0.map_frame.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.map_frame.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::lib::aligned_transitive_auto")
(declare-fun ens%main!impl_u.lib.aligned_transitive_auto. (Int) Bool)
(assert (forall ((no%param@ Int)) (! (= (ens%main!impl_u.lib.aligned_transitive_auto. no%param@) (forall ((a~11$ Poly) (b~13$ Poly) (c~15$ Poly)) (! (=> (and (has_type a~11$ NAT) (has_type b~13$ NAT) (has_type c~15$ NAT)) (=> (and (and (and (< 0 (%I b~13$)) (< 0 (%I c~15$))) (main!definitions_t.aligned.? a~11$ b~13$)) (main!definitions_t.aligned.? b~13$ c~15$)) (main!definitions_t.aligned.? a~11$ c~15$))) :pattern ((main!definitions_t.aligned.? a~11$ b~13$) (main!definitions_t.aligned.? b~13$ c~15$)) :pattern ((main!definitions_t.aligned.? a~11$ b~13$) (main!definitions_t.aligned.? a~11$ c~15$)) :pattern ((main!definitions_t.aligned.? a~11$ b~13$) (main!definitions_t.aligned.? a~11$ c~15$)) :pattern ((main!definitions_t.aligned.? b~13$ c~15$) (main!definitions_t.aligned.? a~11$ c~15$)) :qid user_main__impl_u__lib__aligned_transitive_auto_133 :skolemid skolem_user_main__impl_u__lib__aligned_transitive_auto_133))) :pattern ((ens%main!impl_u.lib.aligned_transitive_auto. no%param@)) :qid internal_ens__main!impl_u.lib.aligned_transitive_auto._definition :skolemid skolem_internal_ens__main!impl_u.lib.aligned_transitive_auto._definition)))
(set-info :comment ";; Function-Axioms main::definitions_t::Arch::lemma_entry_sizes_aligned_auto")
(declare-fun ens%main!definitions_t.impl&%7.lemma_entry_sizes_aligned_auto. (main!definitions_t.Arch.) Bool)
(assert (forall ((self~2@ main!definitions_t.Arch.)) (! (= (ens%main!definitions_t.impl&%7.lemma_entry_sizes_aligned_auto. self~2@) (forall ((i~16$ Poly) (j~18$ Poly)) (! (=> (and (has_type i~16$ NAT) (has_type j~18$ NAT)) (=> (and (and (main!definitions_t.impl&%7.inv.? (Poly%main!definitions_t.Arch. self~2@)) (<= (%I i~16$) (%I j~18$))) (< (%I j~18$) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. self~2@))))))) (main!definitions_t.aligned.? (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. self~2@) i~16$)) (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. self~2@) j~18$))))) :pattern ((main!definitions_t.aligned.? (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. self~2@) i~16$)) (I (main!definitions_t.impl&%7.entry_size.? (Poly%main!definitions_t.Arch. self~2@) j~18$)))) :qid user_main__definitions_t__Arch__lemma_entry_sizes_aligned_auto_134 :skolemid skolem_user_main__definitions_t__Arch__lemma_entry_sizes_aligned_auto_134))) :pattern ((ens%main!definitions_t.impl&%7.lemma_entry_sizes_aligned_auto. self~2@)) :qid internal_ens__main!definitions_t.impl&__7.lemma_entry_sizes_aligned_auto._definition :skolemid skolem_internal_ens__main!definitions_t.impl&__7.lemma_entry_sizes_aligned_auto._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::lib::leq_add_aligned_less")
(declare-fun ens%main!impl_u.lib.leq_add_aligned_less. (Int Int Int) Bool)
(assert (forall ((a~2@ Int) (b~4@ Int) (c~6@ Int)) (! (= (ens%main!impl_u.lib.leq_add_aligned_less. a~2@ b~4@ c~6@) (<= (nClip (+ a~2@ b~4@)) c~6@)) :pattern ((ens%main!impl_u.lib.leq_add_aligned_less. a~2@ b~4@ c~6@)) :qid internal_ens__main!impl_u.lib.leq_add_aligned_less._definition :skolemid skolem_internal_ens__main!impl_u.lib.leq_add_aligned_less._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_accepted_mapping_implies_directory_accepted_mapping")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry. main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.) (d~8@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. self~2@ base~4@ pte~6@ d~8@) (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. d~8@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_accepted_mapping_implies_directory_accepted_mapping. self~2@ base~4@ pte~6@ d~8@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_directory_accepted_mapping._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_accepted_mapping_implies_directory_accepted_mapping._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_map_frame_empty_is_ok")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. self~2@ base~4@ pte~6@) (%B (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@)))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_map_frame_empty_is_ok. self~2@ base~4@ pte~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_empty_is_ok._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_empty_is_ok._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_map_frame_preserves_inv")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. self~2@ base~4@ pte~6@) (and (= (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (= (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (not (main!impl_u.l1.impl&%0.empty.? (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (main!impl_u.l1.impl&%0.inv.? (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@)))))) (not (exists ((b~132$ Poly)) (! (and (has_type b~132$ NAT) (and (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) b~132$) (main!definitions_t.between.? (I base~4@) b~132$ (I (nClip (+ (%I b~132$) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) b~132$)))))))))))) :pattern ((vstd!map.impl&%0.index.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) b~132$)) :qid user_main__impl_u__l1__Directory__lemma_map_frame_preserves_inv_135 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_map_frame_preserves_inv_135))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_map_frame_preserves_inv. self~2@ base~4@ pte~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_preserves_inv._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_preserves_inv._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_entries_equal_implies_interp_aux_equal")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. (main!impl_u.l1.Directory. main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (other~4@ main!impl_u.l1.Directory.) (i~6@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. self~2@ other~4@ i~6@) (= (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)) (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. other~4@) (I i~6@)))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_entries_equal_implies_interp_aux_equal. self~2@ other~4@ i~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_entries_equal_implies_interp_aux_equal._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_entries_equal_implies_interp_aux_equal._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_insert_interp_of_entry_implies_insert_interp_aux")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. (main!impl_u.l1.Directory. Int Int Int main!impl_u.l1.NodeEntry. main!definitions_t.PageTableEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (i~4@ Int) (j~6@ Int) (base~8@ Int) (n~10@ main!impl_u.l1.NodeEntry.) (pte~12@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. self~2@ i~4@ j~6@ base~8@ n~10@ pte~12@) (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@)))))) (I base~8@) (Poly%main!definitions_t.PageTableEntry. pte~12@))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~6@) (Poly%main!impl_u.l1.NodeEntry. n~10@))) (I i~4@))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp_aux. self~2@ i~4@ j~6@ base~8@ n~10@ pte~12@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp_aux._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp_aux._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_insert_interp_of_entry_implies_insert_interp")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. (main!impl_u.l1.Directory. Int Int main!impl_u.l1.NodeEntry. main!definitions_t.PageTableEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (base~6@ Int) (n~8@ main!impl_u.l1.NodeEntry.) (pte~10@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. self~2@ j~4@ base~6@ n~8@ pte~10@) (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.insert.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) (I base~6@) (Poly%main!definitions_t.PageTableEntry. pte~10@))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~8@))))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_insert_interp_of_entry_implies_insert_interp. self~2@ j~4@ base~6@ n~8@ pte~10@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_insert_interp_of_entry_implies_insert_interp._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_nonempty_implies_exists_interp_dom_contains")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. (main!impl_u.l1.Directory.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. self~2@) (exists ((b~32$ Poly)) (! (and (has_type b~32$ NAT) (vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) b~32$)) :pattern ((vstd!set.impl&%0.contains.? NAT NAT (vstd!map.impl&%0.dom.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))))))) b~32$)) :qid user_main__impl_u__l1__Directory__lemma_nonempty_implies_exists_interp_dom_contains_137 :skolemid skolem_user_main__impl_u__l1__Directory__lemma_nonempty_implies_exists_interp_dom_contains_137))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_nonempty_implies_exists_interp_dom_contains. self~2@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_nonempty_implies_exists_interp_dom_contains._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_nonempty_implies_exists_interp_dom_contains._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::result_map")
(assert (fuel_bool_default fuel%main!impl_u.l1.result_map.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.result_map.) (forall ((A& Type) (A&. Type) (B& Type) (B&. Type) (res~2@ Poly) (f~4@ Poly)) (! (= (main!impl_u.l1.result_map.? A& A&. B& B&. res~2@ f~4@) (ite ((_ is core!result.Result./Ok) (%Poly%core!result.Result. res~2@)) (let ((a~9$ (core!result.Result./Ok/_0 (%Poly%core!result.Result. res~2@)))) (core!result.Result./Ok (%%apply%%0 (%Poly%fun%1. f~4@) a~9$))) (let ((a~21$ (core!result.Result./Err/_0 (%Poly%core!result.Result. res~2@)))) (core!result.Result./Err (%%apply%%0 (%Poly%fun%1. f~4@) a~21$))))) :pattern ((main!impl_u.l1.result_map.? A& A&. B& B&. res~2@ f~4@)) :qid internal_main!impl_u.l1.result_map.?_definition :skolemid skolem_internal_main!impl_u.l1.result_map.?_definition))))
(assert (forall ((A& Type) (A&. Type) (B& Type) (B&. Type) (res~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type res~2@ (TYPE%core!result.Result. A& A&)) (has_type f~4@ (TYPE%fun%1. A& B&))) (has_type (Poly%core!result.Result. (main!impl_u.l1.result_map.? A& A&. B& B&. res~2@ f~4@)) (TYPE%core!result.Result. B& B&))) :pattern ((main!impl_u.l1.result_map.? A& A&. B& B&. res~2@ f~4@)) :qid internal_main!impl_u.l1.result_map.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.result_map.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_map_frame_refines_map_frame")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry.) Bool)
(declare-fun %%lambda%%3 () %%Function%%)
(assert (forall ((d~87$ Poly)) (! (= (%%apply%%0 %%lambda%%3 d~87$) (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? d~87$))) :pattern ((%%apply%%0 %%lambda%%3 d~87$)))))
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. self~2@ base~4@ pte~6@) (and (=> (%B (B ((_ is core!result.Result./Err) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))) (= (%Poly%main!impl_u.l1.Directory. (core!result.Result./Err/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@)))))) self~2@)) (= (main!impl_u.l1.result_map.? TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (Poly%fun%1. (mk_fun %%lambda%%3))) (main!impl_u.l0.impl&%0.map_frame.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_map_frame_refines_map_frame. self~2@ base~4@ pte~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_refines_map_frame._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_refines_map_frame._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_map_frame_structure_assertions")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. (main!impl_u.l1.Directory. Int main!definitions_t.PageTableEntry. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (pte~6@ main!definitions_t.PageTableEntry.) (idx~8@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. self~2@ base~4@ pte~6@ idx~8@) (let ((tmp%%1$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I idx~8@))))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%1$) (let ((p~65$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) true) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%1$) (let ((d~71$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) (and (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. d~71$)) (=> (not (= (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@)) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. pte~6@)))))))) (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. d~71$) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))) (=> (not (= (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@)) (main!definitions_t.MemRegion./MemRegion/size (%Poly%main!definitions_t.MemRegion. (Poly%main!definitions_t.MemRegion. (main!definitions_t.PageTableEntry./PageTableEntry/frame (%Poly%main!definitions_t.PageTableEntry. (Poly%main!definitions_t.PageTableEntry. pte~6@)))))))) (and (and (and (< (nClip (+ (main!impl_u.l1.Directory./Directory/layer (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) 1)) (vstd!seq.Seq.len.? TYPE%main!definitions_t.ArchLayer. TYPE%main!definitions_t.ArchLayer. (Poly%vstd!seq.Seq<main!definitions_t.ArchLayer.>. (main!definitions_t.Arch./Arch/layers (%Poly%main!definitions_t.Arch. (Poly%main!definitions_t.Arch. (main!impl_u.l1.Directory./Directory/arch (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))))))))) (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I idx~8@))))) (main!impl_u.l1.impl&%0.accepted_mapping.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I idx~8@))) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))) (%B (B ((_ is core!result.Result./Ok) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.map_frame.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.new_empty_dir.? (Poly%main!impl_u.l1.Directory. self~2@) (I idx~8@))) (I base~4@) (Poly%main!definitions_t.PageTableEntry. pte~6@))))))))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_map_frame_structure_assertions. self~2@ base~4@ pte~6@ idx~8@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_structure_assertions._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_map_frame_structure_assertions._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::accepted_unmap")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.accepted_unmap.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.accepted_unmap.) (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.accepted_unmap.? self~2@ base~4@) (main!impl_u.l0.impl&%0.accepted_unmap.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? self~2@)) base~4@)) :pattern ((main!impl_u.l1.impl&%0.accepted_unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l1.impl&__0.accepted_unmap.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.accepted_unmap.?_definition))))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::unmap")
(assert (fuel_bool_default fuel%main!impl_u.l1.impl&%0.unmap.))
(declare-const fuel_nat%main!impl_u.l1.impl&%0.unmap. Fuel)
(assert (forall ((self~2@ Poly) (base~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ fuel%@) (main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ zero)) :pattern ((main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ fuel%@)) :qid internal_main!impl_u.l1.impl&__0.unmap._fuel_to_zero_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.unmap._fuel_to_zero_definition)))
(assert (forall ((self~2@ Poly) (base~4@ Poly) (fuel%@ Fuel)) (! (= (main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ (succ fuel%@)) (ite (and (main!impl_u.l1.impl&%0.inv.? self~2@) (main!impl_u.l1.impl&%0.accepted_unmap.? self~2@ base~4@)) (let ((entry~68$ (main!impl_u.l1.impl&%0.index_for_vaddr.? self~2@ base~4@))) (let ((tmp%%2$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. self~2@))) (I entry~68$))))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%2$) (let ((p~87$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (ite (main!definitions_t.aligned.? base~4@ (I (main!impl_u.l1.impl&%0.entry_size.? self~2@))) (core!result.Result./Ok (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~68$) (Poly%main!impl_u.l1.NodeEntry. main!impl_u.l1.NodeEntry./Empty)))) (core!result.Result./Err self~2@))) (ite ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%2$) (let ((d~127$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%2$))))) (let ((tmp%%1$ (main!impl_u.l1.impl&%0.rec%unmap.? (Poly%main!impl_u.l1.Directory. d~127$) base~4@ fuel%@))) (ite ((_ is core!result.Result./Ok) tmp%%1$) (let ((new_d~139$ (%Poly%main!impl_u.l1.Directory. (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%1$)))))) (core!result.Result./Ok (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~68$) (Poly%main!impl_u.l1.NodeEntry. (ite (main!impl_u.l1.impl&%0.empty.? (Poly%main!impl_u.l1.Directory. new_d~139$)) main!impl_u.l1.NodeEntry./Empty (main!impl_u.l1.NodeEntry./Directory (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. new_d~139$))))))))) (let ((new_d~172$ (%Poly%main!impl_u.l1.Directory. (core!result.Result./Err/_0 (%Poly%core!result.Result. (Poly%core!result.Result. tmp%%1$)))))) (core!result.Result./Err (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? self~2@ (I entry~68$) (Poly%main!impl_u.l1.NodeEntry. (main!impl_u.l1.NodeEntry./Directory (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. new_d~172$))))))))))) (core!result.Result./Err self~2@))))) (%Poly%core!result.Result. (vstd!pervasive.arbitrary.? (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.) (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.))))) :pattern ((main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ (succ fuel%@))) :qid internal_main!impl_u.l1.impl&__0.unmap._fuel_to_body_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.unmap._fuel_to_body_definition)))
(assert (=> (fuel_bool fuel%main!impl_u.l1.impl&%0.unmap.) (forall ((self~2@ Poly) (base~4@ Poly)) (! (= (main!impl_u.l1.impl&%0.unmap.? self~2@ base~4@) (main!impl_u.l1.impl&%0.rec%unmap.? self~2@ base~4@ (succ fuel_nat%main!impl_u.l1.impl&%0.unmap.))) :pattern ((main!impl_u.l1.impl&%0.unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l1.impl&__0.unmap.?_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.unmap.?_definition))))
(assert (forall ((self~2@ Poly) (base~4@ Poly)) (! (=> (and (has_type self~2@ TYPE%main!impl_u.l1.Directory.) (has_type base~4@ NAT)) (has_type (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? self~2@ base~4@)) (TYPE%core!result.Result. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory.))) :pattern ((main!impl_u.l1.impl&%0.unmap.? self~2@ base~4@)) :qid internal_main!impl_u.l1.impl&__0.unmap.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.impl&__0.unmap.?_pre_post_definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_unmap_preserves_inv")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. self~2@ base~4@) (main!impl_u.l1.impl&%0.inv.? (core!result.Result./Ok/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_unmap_preserves_inv. self~2@ base~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_preserves_inv._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_preserves_inv._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. (main!impl_u.l1.Directory. Int Int Int main!impl_u.l1.NodeEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (i~6@ Int) (vaddr~8@ Int) (n~10@ main!impl_u.l1.NodeEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. self~2@ j~4@ i~6@ vaddr~8@ n~10@) (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~6@)))))) (I vaddr~8@))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~10@))) (I i~6@))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux. self~2@ j~4@ i~6@ vaddr~8@ n~10@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp_aux._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_remove_from_interp_of_entry_implies_remove_from_interp")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. (main!impl_u.l1.Directory. Int Int main!impl_u.l1.NodeEntry.) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (j~4@ Int) (vaddr~6@ Int) (n~8@ main!impl_u.l1.NodeEntry.)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. self~2@ j~4@ vaddr~6@ n~8@) (= (%Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (vstd!map.impl&%0.remove.? NAT NAT TYPE%main!definitions_t.PageTableEntry. TYPE%main!definitions_t.PageTableEntry. (Poly%vstd!map.Map<nat./main!definitions_t.PageTableEntry.>. (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@)))))) (I vaddr~6@))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. (main!impl_u.l1.impl&%0.update.? (Poly%main!impl_u.l1.Directory. self~2@) (I j~4@) (Poly%main!impl_u.l1.NodeEntry. n~8@))))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_remove_from_interp_of_entry_implies_remove_from_interp. self~2@ j~4@ vaddr~6@ n~8@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_remove_from_interp_of_entry_implies_remove_from_interp._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_unmap_refines_unmap")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. (main!impl_u.l1.Directory. Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. self~2@ base~4@) (and (=> (%B (B ((_ is core!result.Result./Err) (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))))))) (= (%Poly%main!impl_u.l1.Directory. (core!result.Result./Err/_0 (%Poly%core!result.Result. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@)))))) self~2@)) (= (main!impl_u.l1.result_map.? TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l1.Directory. TYPE%main!impl_u.l0.PageTableContents. TYPE%main!impl_u.l0.PageTableContents. (Poly%core!result.Result. (main!impl_u.l1.impl&%0.unmap.? (Poly%main!impl_u.l1.Directory. self~2@) (I base~4@))) (Poly%fun%1. (mk_fun %%lambda%%3))) (main!impl_u.l0.impl&%0.unmap.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp.? (Poly%main!impl_u.l1.Directory. self~2@))) (I base~4@))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_unmap_refines_unmap. self~2@ base~4@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_refines_unmap._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_refines_unmap._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::Directory::lemma_unmap_structure_assertions")
(declare-fun ens%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. (main!impl_u.l1.Directory. Int Int) Bool)
(assert (forall ((self~2@ main!impl_u.l1.Directory.) (base~4@ Int) (idx~6@ Int)) (! (= (ens%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. self~2@ base~4@ idx~6@) (let ((tmp%%1$ (%Poly%main!impl_u.l1.NodeEntry. (vstd!seq.Seq.index.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))) (I idx~6@))))) (ite ((_ is main!impl_u.l1.NodeEntry./Page) tmp%%1$) (let ((p~61$ (main!impl_u.l1.NodeEntry./Page/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) (=> (main!definitions_t.aligned.? (I base~4@) (I (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@)))) (= base~4@ (nClip (+ (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@))) (nClip (Mul idx~6@ (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@))))))))) (=> ((_ is main!impl_u.l1.NodeEntry./Directory) tmp%%1$) (let ((d~104$ (main!impl_u.l1.NodeEntry./Directory/_0 (%Poly%main!impl_u.l1.NodeEntry. (Poly%main!impl_u.l1.NodeEntry. tmp%%1$))))) (and (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. d~104$)) (main!impl_u.l1.impl&%0.accepted_unmap.? (Poly%main!impl_u.l1.Directory. d~104$) (I base~4@)))))))) :pattern ((ens%main!impl_u.l1.impl&%0.lemma_unmap_structure_assertions. self~2@ base~4@ idx~6@)) :qid internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_structure_assertions._definition :skolemid skolem_internal_ens__main!impl_u.l1.impl&__0.lemma_unmap_structure_assertions._definition)))
(set-info :comment ";; Function-Axioms main::impl_u::l1::result_map_ok")
(assert (fuel_bool_default fuel%main!impl_u.l1.result_map_ok.))
(assert (=> (fuel_bool fuel%main!impl_u.l1.result_map_ok.) (forall ((A& Type) (A&. Type) (B& Type) (B&. Type) (C& Type) (C&. Type) (res~2@ Poly) (f~4@ Poly)) (! (= (main!impl_u.l1.result_map_ok.? A& A&. B& B&. C& C&. res~2@ f~4@) (ite ((_ is core!result.Result./Ok) (%Poly%core!result.Result. res~2@)) (let ((a~9$ (core!result.Result./Ok/_0 (%Poly%core!result.Result. res~2@)))) (core!result.Result./Ok (%%apply%%0 (%Poly%fun%1. f~4@) a~9$))) (let ((b~21$ (core!result.Result./Err/_0 (%Poly%core!result.Result. res~2@)))) (core!result.Result./Err b~21$)))) :pattern ((main!impl_u.l1.result_map_ok.? A& A&. B& B&. C& C&. res~2@ f~4@)) :qid internal_main!impl_u.l1.result_map_ok.?_definition :skolemid skolem_internal_main!impl_u.l1.result_map_ok.?_definition))))
(assert (forall ((A& Type) (A&. Type) (B& Type) (B&. Type) (C& Type) (C&. Type) (res~2@ Poly) (f~4@ Poly)) (! (=> (and (has_type res~2@ (TYPE%core!result.Result. A& B&)) (has_type f~4@ (TYPE%fun%1. A& C&))) (has_type (Poly%core!result.Result. (main!impl_u.l1.result_map_ok.? A& A&. B& B&. C& C&. res~2@ f~4@)) (TYPE%core!result.Result. C& B&))) :pattern ((main!impl_u.l1.result_map_ok.? A& A&. B& B&. C& C&. res~2@ f~4@)) :qid internal_main!impl_u.l1.result_map_ok.?_pre_post_definition :skolemid skolem_internal_main!impl_u.l1.result_map_ok.?_pre_post_definition)))
(set-info :comment ";; Function-Def main::impl_u::l1::Directory::lemma_inv_implies_interp_aux_inv")
(set-option :smt.arith.solver 6)
(push 1)
(declare-const self~2@ main!impl_u.l1.Directory.)
(declare-const i~4@ Int)
(declare-const tmp%1@ Bool)
(declare-const tmp%2@ Int)
(declare-const tmp%3@ Bool)
(declare-const p~258@ main!definitions_t.PageTableEntry.)
(declare-const d~265@ main!impl_u.l1.Directory.)
(declare-const tmp%4@ Bool)
(declare-const tmp%5@ Int)
(declare-const tmp%6@ Int)
(declare-const tmp%7@ Int)
(declare-const tmp%8@ Int)
(declare-const pte~303@ main!definitions_t.PageTableEntry.)
(declare-const tmp%9@ Bool)
(declare-const pte~353@ main!definitions_t.PageTableEntry.)
(declare-const tmp%10@ Bool)
(declare-const tmp%11@ Bool)
(declare-const d~424@ main!impl_u.l1.Directory.)
(declare-const tmp%12@ Bool)
(declare-const tmp%13@ Bool)
(declare-const tmp%14@ Bool)
(declare-const tmp%15@ Bool)
(declare-const tmp%16@ Bool)
(declare-const tmp%17@ Bool)
(declare-const entry~226@ main!impl_u.l1.NodeEntry.)
(declare-const entry_i~235@ main!impl_u.l0.PageTableContents.)
(declare-const rem~252@ main!impl_u.l0.PageTableContents.)
(declare-const interp~154@ main!impl_u.l0.PageTableContents.)
(declare-const decrease%init0@ Int)
(declare-const decrease%init1@ Int)
(assert fuel_defaults)
(assert (has_type (Poly%main!impl_u.l1.Directory. d~424@) TYPE%main!impl_u.l1.Directory.))
(assert (has_type (Poly%main!impl_u.l0.PageTableContents. entry_i~235@) TYPE%main!impl_u.l0.PageTableContents.))
(assert (<= 0 i~4@))
(assert (has_type (Poly%main!impl_u.l1.Directory. self~2@) TYPE%main!impl_u.l1.Directory.))
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%0 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%1 Bool)
(set-info :comment ";; assertion failed")
(declare-const %%location_label%%2 Bool)
(declare-const %%query%% Bool)
(assert (=> %%query%% (not (=> (main!impl_u.l1.impl&%0.inv.? (Poly%main!impl_u.l1.Directory. self~2@)) (=> (= entry_i~235@ (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))) (=> (main!impl_u.l0.impl&%0.inv.? (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0)))) (=> (= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0))))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))) (=> (= (main!impl_u.l1.Directory./Directory/base_vaddr (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. d~424@))) (main!impl_u.l1.impl&%0.entry_base.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))) (=> (= (nClip (Mul (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. d~424@)) (main!impl_u.l1.impl&%0.num_entries.? (Poly%main!impl_u.l1.Directory. d~424@)))) (main!impl_u.l1.impl&%0.entry_size.? (Poly%main!impl_u.l1.Directory. self~2@))) (=> (= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0))))) (main!impl_u.l1.impl&%0.upper_vaddr.? (Poly%main!impl_u.l1.Directory. d~424@))) (=> (= (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_of_entry.? (Poly%main!impl_u.l1.Directory. self~2@) (I i~4@))))) (main!impl_u.l0.PageTableContents./PageTableContents/map (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0)))))) (=> (< i~4@ (vstd!seq.Seq.len.? TYPE%main!impl_u.l1.NodeEntry. TYPE%main!impl_u.l1.NodeEntry. (Poly%vstd!seq.Seq<main!impl_u.l1.NodeEntry.>. (main!impl_u.l1.Directory./Directory/entries (%Poly%main!impl_u.l1.Directory. (Poly%main!impl_u.l1.Directory. self~2@)))))) (=> (= tmp%10@ (<= (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. entry_i~235@))) (main!impl_u.l0.PageTableContents./PageTableContents/lower (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0))))))) (and (=> %%location_label%%0 tmp%10@) (=> tmp%10@ (=> (= tmp%11@ (>= (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. entry_i~235@))) (main!impl_u.l0.PageTableContents./PageTableContents/upper (%Poly%main!impl_u.l0.PageTableContents. (Poly%main!impl_u.l0.PageTableContents. (main!impl_u.l1.impl&%0.interp_aux.? (Poly%main!impl_u.l1.Directory. d~424@) (I 0))))))) (and (=> %%location_label%%1 tmp%11@) (=> tmp%11@ (=> %%location_label%%2 (main!impl_u.l0.impl&%0.mappings_in_bounds.? (Poly%main!impl_u.l0.PageTableContents. entry_i~235@)))))))))))))))))))))
(assert %%query%%)
(check-sat)
