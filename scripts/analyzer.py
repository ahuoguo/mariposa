from db_utils import *
import numpy as np
import ast
import scipy.stats
from enum import Enum
from vbkv_filemap import *
import shutil

from configs.projects import *
from configs.experiments import *
from plot_utils import *
import matplotlib.pyplot as plt
from statsmodels.stats.proportion import proportions_ztest
# import seaborn as sns

FSIZE = 16
FNAME ='Timds New Roman'
import random

plt.rcParams['text.usetex'] = True
plt.rcParams["font.family"] = "serif"

COLORS = [
    "#803E75", # Strong Purple
    "#FF6800", # Vivid Orange
    "#A6BDD7", # Very Light Blue
    "#C10020", # Vivid Red
    "#FFB300", # Vivid Yellow
    "#817066", # Medium Gray
    "#F6768E", # Strong Purplish Pink
]

PNAMES = {
    "D_KOMODO": "Komodo(D)",
    "D_FVBKV": "VeriBetrKV(D)",
    "D_LVBKV": "VeriBetrKV(L)",
    "FS_DICE": r"DICE$^{\star}$(F)",
    "FS_VWASM": "vWasm(F)",
    "S_KOMODO": "Komodo(S)",
} 

class ColorMapper:
    def __init__(self):
        self.i = 0
    
    def peek(self):
        return COLORS[self.i]
    
    def pop(self):
        self.i += 1
        return COLORS[self.i-1]

def get_color_map(keys):
    assert len(keys) <= len(COLORS)
    return {k: COLORS[i] for i, k in enumerate(keys)}

PROJECT_COLORS = get_color_map([c for c in PNAMES])

PERTURBATION_COLORS = {
    "shuffle": "#803E75",        
    "rename": "#FF6800",
    "rseed": "#A6BDD7",
    "union": "#FFB300",
    "unstable": "#FFB300",
    "unsolvable": "#C10020",
    "intersect": "#817066",
}

# PERTURBATION_COLORS = get_color_map([c for c in Mutation] + ["unsolvable", "union", "intersect"])
# PERTURBATION_COLORS["unstable"] = PERTURBATION_COLORS["union"]

def percentage(a, b):
    return a * 100 / b

class RCode(Enum):
    SAT = 1
    UNSAT = 2
    TIMEOUT = 3
    UNKNOWN = 4
    ERROR = 5

    def from_str(s):
        if s == "sat":
            return RCode.SAT
        elif s == "unsat":
            return RCode.UNSAT
        elif s == "timeout":
            return RCode.TIMEOUT
        elif s == "unknown":
            return RCode.UNKNOWN
        elif s == "error":
            return RCode.ERROR
        else:
            assert False

    def __str__(self):
        if self == RCode.SAT:
            return "sat"
        elif self == RCode.UNSAT:
            return "unsat"
        elif self == RCode.TIMEOUT:
            return "timeout"
        elif self == RCode.UNKNOWN:
            return "unknown"
        elif self == RCode.ERROR:
            return "error"
        else:
            assert False

def build_solver_summary_table(cfg, solver):
    con, cur = get_cursor(cfg.qcfg.db_path)
    solver_table = cfg.qcfg.get_solver_table_name(solver)
    summary_table = cfg.get_solver_summary_table_name(solver)

    if not check_table_exists(cur, solver_table):
        print(f"[WARN] table {solver_table} does not exist")
        con.close()
        return

    cur.execute(f"""DROP TABLE IF EXISTS {summary_table}""")

    cur.execute(f"""CREATE TABLE {summary_table} (
        vanilla_path TEXT,
        pretubrations TEXT,
        summaries BLOB)""")

    res = cur.execute(f"""
        SELECT DISTINCT(query_path), result_code, elapsed_milli
        FROM {solver_table}
        WHERE query_path = vanilla_path""")

    vanilla_rows = res.fetchall()
    for (vanilla_path, v_rcode, v_time) in tqdm(vanilla_rows):
        res = cur.execute(f"""
            SELECT result_code, elapsed_milli, perturbation FROM {solver_table}
            WHERE vanilla_path = "{vanilla_path}"
            AND perturbation IS NOT NULL""")

        perturbs = [str(p) for p in cfg.qcfg.enabled_muts]
        v_rcode = RCode.from_str(v_rcode).value
        results = {p: [[v_rcode], [v_time]] for p in perturbs}

        for row in res.fetchall():
            results[row[2]][0].append(RCode.from_str(row[0]).value)
            results[row[2]][1].append(row[1])

        mut_size = cfg.qcfg.max_mutants
        blob = np.zeros((len(perturbs), 2, mut_size + 1), dtype=int)
        for pi, perturb in enumerate(perturbs):
            (veri_res, veri_times) = results[perturb]
            blob[pi][0] = veri_res
            blob[pi][1] = veri_times

        cur.execute(f"""INSERT INTO {summary_table}
            VALUES(?, ?, ?);""", 
            (vanilla_path, str(perturbs), blob))

    con.commit()
    con.close()

def extend_solver_summary_table(cfg, ext_cfg, solver):
    con, cur = get_cursor(cfg.qcfg.db_path)
    solver_table = cfg.qcfg.get_solver_table_name(solver)
    solver_ext_table = ext_cfg.qcfg.get_solver_table_name(solver)
    # summary_table = cfg.get_solver_summary_table_name(solver)

    if not check_table_exists(cur, solver_table):
        con.close()
        return
    
    solver_table = cfg.qcfg.get_solver_table_name(solver)

    res = cur.execute(f"""
        SELECT query_path, result_code, elapsed_milli, command FROM {solver_ext_table} """)

    ext_results = dict()
    rows = res.fetchall()

    for (query_path, rcode, time, command) in tqdm(rows):
        stem = query_path.split("/")[-1]
        ext_results[stem] = (rcode, time, command)
        # print(stem, time, rcode)

    res = cur.execute(f"""
        SELECT query_path, rowid FROM {solver_table}
        WHERE result_code = "timeout" """)

    rows = res.fetchall()

    for (query_path, row_id) in tqdm(rows):
        stem = query_path.split("/")[-1]
        (rcode, time, command) = ext_results[stem]
        cur.execute(f"""UPDATE {solver_table}
            SET result_code = "{rcode}",
            elapsed_milli = {time},
            command = "{command}"
            WHERE rowid = {row_id}""")

    con.commit()
    con.close()

    build_solver_summary_table(cfg, solver)

def as_seconds(milliseconds):
    return milliseconds / 1000

def group_time_mean(times):
    assert len(times) != 0
    return as_seconds(np.mean(times))

def group_time_std(times):
    assert len(times) != 0
    return as_seconds(np.std(times))

def load_solver_summary(cfg, solver, skip=set()):
    con, cur = get_cursor(cfg.qcfg.db_path)
    new_table_name = cfg.qcfg.get_solver_table_name(solver) + "_summary"
    if not check_table_exists(cur, new_table_name):
        print(f"[INFO] skipping {new_table_name}")
        return None
    solver = str(solver)

    res = cur.execute(f"""SELECT * FROM {new_table_name}""")
    rows = res.fetchall()

    nrows = []
    mut_size = cfg.qcfg.max_mutants
    for row in rows:
        if row[0] in skip:
            continue
        perturbs = ast.literal_eval(row[1])
        blob = np.frombuffer(row[2], dtype=int)
        blob = blob.reshape((len(perturbs), 2, mut_size + 1))
        nrow = [row[0], perturbs, blob]
        nrows.append(nrow)
    con.close()
    return nrows

def get_unknowns(cfg):
    th = Classifier("strict")
    th.timeout = 6e4

    summary = load_solver_summary(cfg, cfg.qcfg.project.orig_solver)
    if summary is None:
        return set()
    categories = categorize_queries(summary, th)
    return categories[Stablity.UNKNOWN]

def load_solver_summaries(cfg, skip_unknowns=True):
    summaries = dict()

    if skip_unknowns:
        unkowns = get_unknowns(cfg)
    else:
        unkowns = set()

    for solver in cfg.samples:
        nrows = load_solver_summary(cfg, solver, unkowns)
        if nrows is None:
            continue
        summaries[solver] = nrows
    return summaries

class Stablity(str, Enum):
    UNKNOWN = "unknown"
    UNSOLVABLE = "unsolvable"
    UNSTABLE = "unstable"
    # TIME_UNSTABLE = "time_unstable"
    INCONCLUSIVE = "inconclusive"
    STABLE = "stable"

    def __str__(self) -> str:
        return super().__str__()

    def empty_map():
        em = {c: set() for c in Stablity}
        return em

# # miliseconds
# def indices_within_timeout(blob, timeout):
#     none_timeout = blob[1] < timeout 
#     return np.where(none_timeout)[0]

def count_within_timeout(blob, rcode, timeout=1e6):
    success = blob[0] == rcode.value
    none_timeout = blob[1] < timeout
    success = np.sum(np.logical_and(success, none_timeout))
    return success

    # if self.time_std is not None:
    #     std = np.std(times)
    #     T = (size - 1) * ((std / self.time_std) ** 2)
    #     if T > scipy.stats.chi2.ppf(1-self.confidence, df=size-1):
    #         return Stablity.TIME_UNSTABLE

class Classifier:
    def __init__(self, method):
        self.confidence = 0.05
        self.timeout = 1e6

        self.unsolvable = 5
        self.res_stable = 95
        self.discount = 0.8

        if method == "regression":
            assert False
            # self.categorize_group = self._categorize_group_regression
        elif method == "strict":
            self.categorize_group = self._categorize_strict
        elif method == "z_test":
            self.categorize_group = self._categorize_z_test
        else:
            assert False

    # def _categorize_group_regression(self, group_blob):
    #     pres = group_blob[0][0]
    #     ptime = group_blob[1][0]
    #     if pres != RCode.UNSAT.value or ptime > self.timeout:
    #         return Stablity.UNSOLVABLE

    #     timeout = max(ptime * 1.5, ptime + 50000)
    #     success = count_within_timeout(group_blob, RCode.UNSAT, timeout)

    #     if success < len(group_blob[0]) * 0.8:
    #         return Stablity.RES_UNSTABLE

    #     size = len(group_blob[0])
    #     if success != size:
    #         return Stablity.RES_UNSTABLE
    #     return Stablity.STABLE

    def _categorize_strict(self, group_blob):
        size = len(group_blob[0])
        success = count_within_timeout(group_blob, RCode.UNSAT, self.timeout)

        if success == 0:
            if count_within_timeout(group_blob, RCode.UNKNOWN, self.timeout) == size:
                return Stablity.UNKNOWN
            return Stablity.UNSOLVABLE

        if success == size:
            return Stablity.STABLE

        # if m > self.timeout * self.discount:
        #     return Stablity.STABLE
        return Stablity.UNSTABLE

    def _categorize_z_test(self, group_blob):
        size =  group_blob.shape[1]

        unsat_indices = group_blob[0] == RCode.UNSAT.value
        nto_indices = group_blob[1] < self.timeout
        valid_indices = np.logical_and(unsat_indices, nto_indices)
        success = np.sum(valid_indices)

        # success = count_within_timeout(group_blob, RCode.UNSAT, self.timeout)
        # if success == 0:
        #     if count_within_timeout(group_blob, RCode.UNKNOWN, self.timeout) == size:
        #         return Stablity.UNKNOWN

        value = self.unsolvable/100
        _, p_value = proportions_ztest(count=success,
                                        nobs=size,
                                        value=value, 
                                        alternative='smaller',
                                        prop_var=value)
        if p_value <= self.confidence:
            return Stablity.UNSOLVABLE

        value = self.res_stable/100
        _, p_value = proportions_ztest(count=success, 
                                        nobs=size,
                                        value=value,
                                        alternative='smaller',
                                        prop_var=value)

        if p_value <= self.confidence and \
            np.mean(group_blob[1][valid_indices]) < self.timeout * self.discount:
            return Stablity.UNSTABLE
    
        _, p_value = proportions_ztest(count=success, 
                                        nobs=size,
                                        value=value,
                                        alternative='larger',
                                        prop_var=value)
        if p_value <= self.confidence:
            return Stablity.STABLE
        return Stablity.INCONCLUSIVE

    def categorize_query(self, group_blobs, perturbs=None):
        ress = set()
        if perturbs is None:
            perturbs = [i for i in range(group_blobs.shape[0])]
        for i in perturbs:
            ress.add(self.categorize_group(group_blobs[i]))
        if ress == {Stablity.INCONCLUSIVE}:
            return Stablity.INCONCLUSIVE
        ress -= {Stablity.INCONCLUSIVE}
        if len(ress) == 1:
            return ress.pop()
        # if Stablity.UNSTABLE not in ress:
        #     print(ress)
        return Stablity.UNSTABLE

def categorize_queries(rows, classifier, perturbs=None):
    categories = Stablity.empty_map()
    for query_row in rows:
        plain_path = query_row[0]
        res = classifier.categorize_query(query_row[2], perturbs)
        categories[res].add(plain_path)
    return categories

def get_category_percentages(categories):
    percentages = dict()
    total = sum([len(i) for i in categories.values()])
    for c, i in categories.items():
        percentages[c] = percentage(len(i), total)
    return percentages, total

def async_cutoff_categories(categories, i, classifier, rows, perturbs):
    classifier.timeout = i * 1e3
    cur = {p: set() for p in perturbs + ["unsolvable", "unstable", "intersect"]}
    
    for query_row in rows:
        plain_path = query_row[0]
        group_blobs = query_row[2]
        ress = set()
        for k, p in enumerate(perturbs):
            res = classifier.categorize_group(group_blobs[k])
            if res == Stablity.UNSTABLE:
                cur[p].add(plain_path)
                cur["unstable"].add(plain_path)
            ress.add(res)
        if ress == {Stablity.UNSTABLE}:
            # if all of the perturbations is unstable
            cur["intersect"].add(plain_path)
        if ress == {Stablity.INCONCLUSIVE}:
            continue
        ress -= {Stablity.INCONCLUSIVE}
        if ress == {Stablity.UNSOLVABLE}:
            cur["unsolvable"].add(plain_path)
        elif ress != {Stablity.STABLE}:
            # if any of the perturbations is unstable
            # or the results are mixed
            cur["unstable"].add(plain_path)
            # print(ress, classifier.categorize_query(group_blobs))
            # assert classifier.categorize_query(group_blobs) == Stablity.UNSTABLE
        
    # print(len(cur["intersect"]), len(cur["rseed"]))
    assert(len(cur["intersect"]) < len(cur["rseed"]))
    categories[i] = cur

def mp_get_all_cutoff_categories(classifier, rows, cutoffs, perturbs):
    import multiprocessing as mp
    manager = mp.Manager()
    pool = mp.Pool(processes=8)
    categories = manager.dict()

    for i in cutoffs:
        # async_cutoff_categories(categories, i, classifier, rows, perturbs)
        pool.apply_async(async_cutoff_categories, 
                         args=(categories, i, classifier, rows, perturbs,))
    pool.close()
    pool.join()
    # print(categories)
    return categories

def _plot_ext_cutoff(cfg, sp):
    name = cfg.qcfg.name
    classifier = Classifier("z_test")
    perturbs = [str(p) for p in cfg.qcfg.enabled_muts]
    skip = get_unknowns(cfg)

    cutoffs = [i for i in range(10, 151, 1)]
    steps = [5, 30, 60]

    if cfg == D_LVBKV_CFG:
        diffs =  [[3.2194244604316546, 3.237410071942446, 3.183453237410072, 3.183453237410072, 3.2553956834532376, 3.273381294964029, 3.3633093525179856, 3.327338129496403, 3.2194244604316546, 3.2014388489208634, 3.2194244604316546, 3.2014388489208634, 3.2014388489208634, 3.29136690647482, 3.29136690647482, 3.327338129496403, 3.327338129496403, 3.29136690647482, 3.29136690647482, 3.3093525179856114, 3.3453237410071943, 3.327338129496403, 3.183453237410072, 3.1654676258992804, 3.147482014388489, 3.1654676258992804, 3.2194244604316546, 3.2194244604316546, 3.2194244604316546, 3.1654676258992804, 3.1654676258992804, 3.1654676258992804, 3.1654676258992804, 3.129496402877698, 3.147482014388489, 3.147482014388489, 3.147482014388489, 3.147482014388489, 3.1654676258992804, 3.1654676258992804, 3.147482014388489, 3.147482014388489, 3.129496402877698, 3.1654676258992804, 3.147482014388489, 3.147482014388489, 3.147482014388489, 3.147482014388489, 3.1115107913669067, 3.093525179856115, 3.093525179856115, 3.1115107913669067, 3.1115107913669067, 3.1115107913669067, 3.129496402877698, 3.129496402877698, 3.147482014388489, 3.129496402877698, 3.093525179856115, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.039568345323741, 3.039568345323741, 3.0215827338129495, 3.0215827338129495, 3.0215827338129495, 3.0215827338129495, 3.0215827338129495, 3.0215827338129495, 3.039568345323741, 3.0215827338129495, 3.0035971223021583, 3.0215827338129495, 3.0035971223021583, 3.0035971223021583, 2.985611510791367, 2.985611510791367, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.9136690647482015, 2.9136690647482015, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993], [2.5899280575539567, 2.643884892086331, 2.6258992805755397, 2.661870503597122, 2.679856115107914, 2.697841726618705, 2.805755395683453, 2.823741007194245, 2.7697841726618706, 2.823741007194245, 2.8597122302158273, 2.8597122302158273, 2.8597122302158273, 2.931654676258993, 2.9676258992805757, 3.0035971223021583, 3.0215827338129495, 2.985611510791367, 3.0035971223021583, 2.985611510791367, 3.0575539568345325, 3.0575539568345325, 2.985611510791367, 2.949640287769784, 2.931654676258993, 2.9676258992805757, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.9676258992805757, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.9136690647482015, 2.9136690647482015, 2.931654676258993, 2.949640287769784, 2.9676258992805757, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.949640287769784, 2.949640287769784, 2.9676258992805757, 3.0035971223021583, 2.985611510791367, 2.9676258992805757, 2.9676258992805757, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.9676258992805757, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.9676258992805757, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.8956834532374103, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.8956834532374103, 2.8956834532374103, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.931654676258993, 2.931654676258993, 2.9136690647482015, 2.9136690647482015, 2.9136690647482015, 2.8956834532374103], [2.4280575539568345, 2.4820143884892087, 2.464028776978417, 2.4820143884892087, 2.5179856115107913, 2.535971223021583, 2.5899280575539567, 2.6258992805755397, 2.6079136690647484, 2.6258992805755397, 2.679856115107914, 2.679856115107914, 2.679856115107914, 2.7338129496402876, 2.7697841726618706, 2.805755395683453, 2.805755395683453, 2.787769784172662, 2.787769784172662, 2.787769784172662, 2.8597122302158273, 2.8597122302158273, 2.787769784172662, 2.787769784172662, 2.787769784172662, 2.805755395683453, 2.823741007194245, 2.823741007194245, 2.805755395683453, 2.787769784172662, 2.805755395683453, 2.805755395683453, 2.823741007194245, 2.805755395683453, 2.823741007194245, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.823741007194245, 2.841726618705036, 2.823741007194245, 2.823741007194245, 2.823741007194245, 2.823741007194245, 2.805755395683453, 2.805755395683453, 2.805755395683453, 2.841726618705036, 2.841726618705036, 2.841726618705036, 2.8776978417266186, 2.8597122302158273, 2.8597122302158273, 2.8597122302158273, 2.8597122302158273, 2.841726618705036, 2.841726618705036, 2.8597122302158273, 2.8597122302158273, 2.8597122302158273, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8956834532374103, 2.8956834532374103, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8776978417266186, 2.8597122302158273, 2.8597122302158273, 2.8776978417266186, 2.8776978417266186]]
        untables =  [3.6870503597122304, 3.633093525179856, 3.579136690647482, 3.597122302158273, 3.5611510791366907, 3.5611510791366907, 3.633093525179856, 3.633093525179856, 3.5431654676258995, 3.5611510791366907, 3.5611510791366907, 3.5071942446043165, 3.435251798561151, 3.435251798561151, 3.381294964028777, 3.381294964028777, 3.381294964028777, 3.3633093525179856, 3.3992805755395685, 3.3992805755395685, 3.471223021582734, 3.4532374100719423, 3.3633093525179856, 3.3453237410071943, 3.3453237410071943, 3.3633093525179856, 3.327338129496403, 3.273381294964029, 3.273381294964029, 3.237410071942446, 3.237410071942446, 3.237410071942446, 3.237410071942446, 3.2194244604316546, 3.2014388489208634, 3.2014388489208634, 3.2194244604316546, 3.2014388489208634, 3.183453237410072, 3.183453237410072, 3.1654676258992804, 3.1654676258992804, 3.183453237410072, 3.2194244604316546, 3.2014388489208634, 3.183453237410072, 3.183453237410072, 3.1654676258992804, 3.1654676258992804, 3.147482014388489, 3.147482014388489, 3.183453237410072, 3.183453237410072, 3.1654676258992804, 3.183453237410072, 3.183453237410072, 3.1654676258992804, 3.1654676258992804, 3.147482014388489, 3.129496402877698, 3.129496402877698, 3.147482014388489, 3.129496402877698, 3.093525179856115, 3.093525179856115, 3.093525179856115, 3.0755395683453237, 3.0755395683453237, 3.0755395683453237, 3.0575539568345325, 3.0755395683453237, 3.0755395683453237, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.039568345323741, 3.039568345323741, 3.0215827338129495, 3.039568345323741, 3.039568345323741, 3.039568345323741, 3.0575539568345325, 3.0575539568345325, 3.0575539568345325, 3.0215827338129495, 3.0035971223021583, 3.0215827338129495, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 3.0035971223021583, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.985611510791367, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.9676258992805757, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.949640287769784, 2.931654676258993, 2.931654676258993, 2.931654676258993, 2.931654676258993]
        unsolvables =  [1.4568345323741008, 1.3669064748201438, 1.3129496402877698, 1.1870503597122302, 1.169064748201439, 1.1151079136690647, 1.0071942446043165, 0.9532374100719424, 0.935251798561151, 0.935251798561151, 0.9172661870503597, 0.8812949640287769, 0.8453237410071942, 0.8093525179856115, 0.7733812949640287, 0.7014388489208633, 0.6834532374100719, 0.7194244604316546, 0.6834532374100719, 0.6834532374100719, 0.6115107913669064, 0.6115107913669064, 0.6654676258992805, 0.6654676258992805, 0.6654676258992805, 0.6474820143884892, 0.5935251798561151, 0.5935251798561151, 0.5935251798561151, 0.5935251798561151, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5755395683453237, 0.5575539568345323, 0.539568345323741, 0.5215827338129496, 0.5215827338129496, 0.539568345323741, 0.539568345323741, 0.539568345323741, 0.539568345323741, 0.539568345323741, 0.539568345323741, 0.539568345323741, 0.5215827338129496, 0.5215827338129496, 0.5035971223021583, 0.4676258992805755, 0.4676258992805755, 0.4676258992805755, 0.4676258992805755, 0.4676258992805755, 0.4856115107913669, 0.4856115107913669, 0.4676258992805755, 0.4676258992805755, 0.4676258992805755, 0.44964028776978415, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4136690647482014, 0.4136690647482014, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4316546762589928, 0.4136690647482014, 0.4136690647482014, 0.4136690647482014, 0.39568345323741005, 0.39568345323741005, 0.39568345323741005, 0.4136690647482014, 0.4136690647482014, 0.39568345323741005, 0.39568345323741005, 0.39568345323741005, 0.39568345323741005, 0.39568345323741005, 0.39568345323741005, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3776978417266187, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273, 0.3597122302158273]
    elif cfg == D_FVBKV_CFG:
        diffs =  [[2.9306781889911706, 2.836746195754274, 2.817959797106895, 2.8555325944016534, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.893105391696412, 2.8743189930490325, 2.893105391696412, 2.8743189930490325, 2.817959797106895, 2.817959797106895, 2.780386999812136, 2.7616006011647567, 2.7428142025173776, 2.780386999812136, 2.817959797106895, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.8743189930490325, 2.893105391696412, 2.8555325944016534, 2.8743189930490325, 2.893105391696412, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.9306781889911706, 2.9306781889911706, 2.9306781889911706, 2.9494645876385497, 2.968250986285929, 2.9494645876385497, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.9306781889911706, 2.9306781889911706, 2.9494645876385497, 2.9306781889911706, 2.9306781889911706, 2.9306781889911706, 2.9306781889911706, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.8743189930490325, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412], [2.3858726282171707, 2.3670862295697916, 2.4234454255119293, 2.4798046214540674, 2.4798046214540674, 2.4985910201014465, 2.4798046214540674, 2.517377418748826, 2.5549502160435846, 2.5737366146909637, 2.5925230133383432, 2.5925230133383432, 2.6113094119857223, 2.5925230133383432, 2.6113094119857223, 2.630095810633102, 2.6113094119857223, 2.630095810633102, 2.648882209280481, 2.6676686079278604, 2.6676686079278604, 2.648882209280481, 2.648882209280481, 2.6676686079278604, 2.705241405222619, 2.705241405222619, 2.724027803869998, 2.724027803869998, 2.7428142025173776, 2.7616006011647567, 2.780386999812136, 2.7616006011647567, 2.780386999812136, 2.7991733984595153, 2.7991733984595153, 2.7991733984595153, 2.7991733984595153, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.8743189930490325, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.836746195754274, 2.817959797106895, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.817959797106895, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.836746195754274, 2.8555325944016534, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534], [2.329513432275033, 2.2919406349802744, 2.329513432275033, 2.3858726282171707, 2.3858726282171707, 2.3858726282171707, 2.4046590268645502, 2.442231824159309, 2.4798046214540674, 2.517377418748826, 2.536163817396205, 2.536163817396205, 2.5549502160435846, 2.536163817396205, 2.5549502160435846, 2.5549502160435846, 2.5549502160435846, 2.5737366146909637, 2.5925230133383432, 2.630095810633102, 2.630095810633102, 2.5925230133383432, 2.5925230133383432, 2.6113094119857223, 2.648882209280481, 2.648882209280481, 2.6676686079278604, 2.6676686079278604, 2.6864550065752395, 2.705241405222619, 2.724027803869998, 2.724027803869998, 2.7428142025173776, 2.7616006011647567, 2.7616006011647567, 2.780386999812136, 2.780386999812136, 2.817959797106895, 2.7991733984595153, 2.7991733984595153, 2.817959797106895, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.8555325944016534, 2.836746195754274, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.817959797106895, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.817959797106895, 2.817959797106895, 2.836746195754274, 2.836746195754274, 2.836746195754274, 2.817959797106895]]
        untables =  [3.1561149727597217, 3.118542175464963, 3.118542175464963, 3.1561149727597217, 3.099755776817584, 3.1561149727597217, 3.0809693781702046, 3.0621829795228255, 3.043396580875446, 3.043396580875446, 3.005823783580688, 3.005823783580688, 3.005823783580688, 2.968250986285929, 2.968250986285929, 2.9494645876385497, 2.9306781889911706, 2.893105391696412, 2.911891790343791, 2.911891790343791, 2.893105391696412, 2.8555325944016534, 2.836746195754274, 2.8555325944016534, 2.911891790343791, 2.911891790343791, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.9306781889911706, 2.9306781889911706, 2.9494645876385497, 2.911891790343791, 2.9494645876385497, 2.9494645876385497, 2.9306781889911706, 2.968250986285929, 2.9870373849333083, 2.9870373849333083, 2.9870373849333083, 3.005823783580688, 2.968250986285929, 2.968250986285929, 2.9494645876385497, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.9306781889911706, 2.9306781889911706, 2.9494645876385497, 2.9306781889911706, 2.968250986285929, 2.968250986285929, 2.968250986285929, 2.968250986285929, 2.968250986285929, 2.9494645876385497, 2.9494645876385497, 2.9494645876385497, 2.9494645876385497, 2.9306781889911706, 2.911891790343791, 2.911891790343791, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.911891790343791, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8555325944016534, 2.8555325944016534, 2.8555325944016534, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.8743189930490325, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412, 2.893105391696412]
        unsolvables =  [1.446552695848206, 1.4277662972008267, 1.3338343039639302, 1.2399023107270337, 1.2211159120796544, 1.2023295134322751, 1.1647567161375165, 1.127183918842758, 1.1083975201953786, 1.0520383242532407, 1.0332519256058614, 0.9768927296637234, 0.9393199323689648, 0.9581063310163441, 0.9393199323689648, 0.9205335337215855, 0.8829607364268269, 0.8641743377794476, 0.826601540484689, 0.8078151418373097, 0.7890287431899304, 0.8078151418373097, 0.7890287431899304, 0.7702423445425511, 0.7326695472477927, 0.751455945895172, 0.7326695472477927, 0.751455945895172, 0.7326695472477927, 0.7326695472477927, 0.695096749953034, 0.695096749953034, 0.695096749953034, 0.6763103513056548, 0.6763103513056548, 0.6575239526582755, 0.6575239526582755, 0.6199511553635169, 0.6199511553635169, 0.6199511553635169, 0.6011647567161376, 0.5823783580687583, 0.5823783580687583, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.563591959421379, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.563591959421379, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5260191621266204, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5448055607739997, 0.5072327634792411, 0.5072327634792411, 0.5072327634792411, 0.5072327634792411, 0.5072327634792411, 0.5072327634792411, 0.5072327634792411, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617, 0.4884463648318617]
    elif cfg == D_KOMODO_CFG:
        diffs =  [[3.700097370983447, 3.7487828627069133, 3.7974683544303796, 3.9922103213242455, 3.9922103213242455, 3.6514118792599803, 3.700097370983447, 3.602726387536514, 3.7974683544303796, 3.8948393378773125, 3.9435248296007788, 3.8948393378773125, 4.089581304771178, 4.235637779941578, 4.089581304771178, 4.138266796494644, 4.040895813047712, 4.089581304771178, 4.235637779941578, 4.138266796494644, 4.040895813047712, 3.8948393378773125, 4.040895813047712, 4.186952288218111, 4.138266796494644, 4.284323271665044, 4.284323271665044, 4.33300876338851, 4.33300876338851, 4.381694255111976, 4.430379746835443, 4.381694255111976, 4.381694255111976, 4.381694255111976, 4.381694255111976, 4.33300876338851, 4.381694255111976, 4.381694255111976, 4.47906523855891, 4.527750730282376, 4.625121713729309, 4.673807205452775, 4.625121713729309, 4.673807205452775, 4.673807205452775, 4.722492697176241, 4.771178188899708, 4.8198636806231745, 4.917234664070107, 4.965920155793573, 4.965920155793573, 5.063291139240507, 5.209347614410905, 5.209347614410905, 5.404089581304771, 5.306718597857838, 5.355404089581305, 5.306718597857838, 5.306718597857838, 5.452775073028238, 5.452775073028238, 5.404089581304771, 5.404089581304771, 5.404089581304771, 5.501460564751704, 5.501460564751704, 5.501460564751704, 5.452775073028238, 5.355404089581305, 5.306718597857838, 5.306718597857838, 5.258033106134372, 5.306718597857838, 5.258033106134372, 5.0146056475170395, 5.111976630963973, 5.111976630963973, 5.160662122687439, 5.111976630963973, 5.0146056475170395, 5.063291139240507, 5.063291139240507, 5.063291139240507, 5.063291139240507, 5.160662122687439, 5.111976630963973, 5.111976630963973, 5.111976630963973, 5.063291139240507, 5.111976630963973, 5.063291139240507, 5.0146056475170395, 5.063291139240507, 4.917234664070107, 4.965920155793573, 4.917234664070107, 4.917234664070107, 4.917234664070107, 4.917234664070107, 4.965920155793573, 4.965920155793573, 4.917234664070107, 4.917234664070107, 4.868549172346641, 4.8198636806231745, 4.771178188899708, 4.771178188899708, 4.722492697176241, 4.8198636806231745, 4.771178188899708, 4.771178188899708, 4.771178188899708, 4.8198636806231745, 4.8198636806231745, 4.771178188899708, 4.771178188899708, 4.8198636806231745, 4.8198636806231745, 4.8198636806231745, 4.771178188899708, 4.8198636806231745, 4.8198636806231745, 4.8198636806231745, 4.771178188899708, 4.771178188899708, 4.722492697176241, 4.722492697176241, 4.771178188899708, 4.771178188899708, 4.8198636806231745, 4.8198636806231745, 4.771178188899708, 4.673807205452775, 4.722492697176241, 4.722492697176241, 4.722492697176241], [2.142161635832522, 2.142161635832522, 2.239532619279455, 2.4829600778967866, 2.385589094449854, 2.385589094449854, 2.5316455696202533, 2.5316455696202533, 2.726387536514119, 2.775073028237585, 2.8237585199610518, 2.969814995131451, 3.0671859785783835, 3.1645569620253164, 3.1645569620253164, 3.11587147030185, 3.0671859785783835, 3.2132424537487827, 3.359298928919182, 3.3106134371957157, 3.2619279454722494, 3.2132424537487827, 3.359298928919182, 3.505355404089581, 3.456669912366115, 3.6514118792599803, 3.602726387536514, 3.700097370983447, 3.700097370983447, 3.7974683544303796, 3.8461538461538463, 3.9435248296007788, 3.8461538461538463, 3.7974683544303796, 3.8461538461538463, 3.8461538461538463, 3.8461538461538463, 3.9435248296007788, 4.040895813047712, 4.089581304771178, 4.186952288218111, 4.235637779941578, 4.284323271665044, 4.235637779941578, 4.284323271665044, 4.33300876338851, 4.33300876338851, 4.284323271665044, 4.381694255111976, 4.186952288218111, 4.235637779941578, 4.33300876338851, 4.47906523855891, 4.47906523855891, 4.576436222005842, 4.576436222005842, 4.625121713729309, 4.625121713729309, 4.673807205452775, 4.771178188899708, 4.722492697176241, 4.673807205452775, 4.625121713729309, 4.576436222005842, 4.673807205452775, 4.576436222005842, 4.576436222005842, 4.576436222005842, 4.47906523855891, 4.47906523855891, 4.430379746835443, 4.430379746835443, 4.527750730282376, 4.527750730282376, 4.527750730282376, 4.576436222005842, 4.576436222005842, 4.625121713729309, 4.576436222005842, 4.47906523855891, 4.527750730282376, 4.576436222005842, 4.527750730282376, 4.527750730282376, 4.576436222005842, 4.527750730282376, 4.527750730282376, 4.527750730282376, 4.527750730282376, 4.430379746835443, 4.430379746835443, 4.430379746835443, 4.47906523855891, 4.47906523855891, 4.527750730282376, 4.527750730282376, 4.430379746835443, 4.47906523855891, 4.430379746835443, 4.381694255111976, 4.33300876338851, 4.33300876338851, 4.33300876338851, 4.33300876338851, 4.33300876338851, 4.381694255111976, 4.381694255111976, 4.235637779941578, 4.284323271665044, 4.284323271665044, 4.33300876338851], [1.8500486854917235, 1.8500486854917235, 1.9474196689386563, 2.190847127555988, 2.190847127555988, 2.190847127555988, 2.3369036027263874, 2.385589094449854, 2.5803310613437196, 2.629016553067186, 2.6777020447906525, 2.775073028237585, 2.872444011684518, 2.9211295034079843, 2.9211295034079843, 2.9211295034079843, 2.8237585199610518, 2.872444011684518, 3.0185004868549172, 2.969814995131451, 2.969814995131451, 2.9211295034079843, 3.0671859785783835, 3.2132424537487827, 3.1645569620253164, 3.3106134371957157, 3.3106134371957157, 3.3106134371957157, 3.3106134371957157, 3.359298928919182, 3.359298928919182, 3.359298928919182, 3.3106134371957157, 3.2132424537487827, 3.2619279454722494, 3.2619279454722494, 3.2619279454722494, 3.3106134371957157, 3.4079844206426486, 3.456669912366115, 3.4079844206426486, 3.505355404089581, 3.554040895813048, 3.554040895813048, 3.6514118792599803, 3.700097370983447, 3.7487828627069133, 3.700097370983447, 3.7974683544303796, 3.7487828627069133, 3.7487828627069133, 3.7974683544303796, 3.8948393378773125, 3.8948393378773125, 3.9922103213242455, 3.9922103213242455, 3.9922103213242455, 3.9922103213242455, 4.040895813047712, 4.138266796494644, 4.089581304771178, 4.089581304771178, 4.040895813047712, 4.040895813047712, 4.186952288218111, 4.138266796494644, 4.186952288218111, 4.186952288218111, 4.186952288218111, 4.138266796494644, 4.138266796494644, 4.138266796494644, 4.186952288218111, 4.138266796494644, 4.138266796494644, 4.138266796494644, 4.089581304771178, 3.9922103213242455, 3.9922103213242455, 3.9922103213242455, 4.040895813047712]]
        untables =  [5.160662122687439, 4.965920155793573, 4.917234664070107, 5.0146056475170395, 4.625121713729309, 4.430379746835443, 4.625121713729309, 4.527750730282376, 4.8198636806231745, 4.771178188899708, 4.576436222005842, 4.625121713729309, 4.527750730282376, 4.625121713729309, 4.625121713729309, 4.576436222005842, 4.33300876338851, 4.527750730282376, 4.625121713729309, 4.527750730282376, 4.47906523855891, 4.430379746835443, 4.576436222005842, 4.722492697176241, 4.527750730282376, 4.722492697176241, 4.576436222005842, 4.625121713729309, 4.625121713729309, 4.673807205452775, 4.673807205452775, 4.771178188899708, 4.673807205452775, 4.625121713729309, 4.576436222005842, 4.576436222005842, 4.527750730282376, 4.527750730282376, 4.722492697176241, 4.771178188899708, 4.8198636806231745, 4.868549172346641, 4.868549172346641, 4.868549172346641, 4.965920155793573, 5.0146056475170395, 5.063291139240507, 4.917234664070107, 5.063291139240507, 5.111976630963973, 5.0146056475170395, 5.111976630963973, 5.258033106134372, 5.306718597857838, 5.452775073028238, 5.452775073028238, 5.501460564751704, 5.501460564751704, 5.55014605647517, 5.69620253164557, 5.6475170399221035, 5.6475170399221035, 5.55014605647517, 5.55014605647517, 5.6475170399221035, 5.598831548198636, 5.55014605647517, 5.55014605647517, 5.55014605647517, 5.55014605647517, 5.55014605647517, 5.55014605647517, 5.598831548198636, 5.452775073028238, 5.452775073028238, 5.501460564751704, 5.404089581304771, 5.404089581304771, 5.355404089581305, 5.111976630963973, 5.209347614410905, 5.258033106134372, 5.258033106134372, 5.160662122687439, 5.209347614410905, 5.160662122687439, 5.209347614410905, 5.209347614410905, 5.209347614410905, 5.258033106134372, 5.209347614410905, 5.160662122687439, 5.209347614410905, 5.160662122687439, 5.209347614410905, 5.160662122687439, 5.111976630963973, 5.111976630963973, 4.965920155793573, 5.0146056475170395, 4.965920155793573, 5.0146056475170395, 5.0146056475170395, 4.965920155793573, 4.965920155793573, 5.0146056475170395, 4.965920155793573, 4.965920155793573, 4.965920155793573, 4.917234664070107, 4.917234664070107, 4.965920155793573, 4.965920155793573, 4.965920155793573, 4.965920155793573, 4.917234664070107, 4.917234664070107, 4.917234664070107, 4.917234664070107, 4.8198636806231745, 4.868549172346641, 4.868549172346641, 4.868549172346641, 4.8198636806231745, 4.868549172346641, 4.868549172346641, 4.8198636806231745, 4.868549172346641, 4.868549172346641, 4.868549172346641, 4.8198636806231745, 4.771178188899708, 4.8198636806231745, 4.917234664070107, 4.868549172346641, 4.868549172346641, 4.965920155793573, 4.771178188899708, 4.771178188899708, 4.8198636806231745, 4.917234664070107]
        unsolvables =  [7.6923076923076925, 7.44888023369036, 7.156767283349562, 6.718597857838364, 6.572541382667965, 6.523855890944499, 6.280428432327167, 5.890944498539436, 5.69620253164557, 5.69620253164557, 5.69620253164557, 5.598831548198636, 5.501460564751704, 5.355404089581305, 5.355404089581305, 5.404089581304771, 5.306718597857838, 5.063291139240507, 4.868549172346641, 4.722492697176241, 4.625121713729309, 4.625121713729309, 4.527750730282376, 4.381694255111976, 4.235637779941578, 4.089581304771178, 4.089581304771178, 3.9922103213242455, 3.8461538461538463, 3.7974683544303796, 3.602726387536514, 3.554040895813048, 3.554040895813048, 3.505355404089581, 3.359298928919182, 3.2619279454722494, 3.1645569620253164, 3.0671859785783835, 3.0185004868549172, 3.0671859785783835, 2.969814995131451, 2.9211295034079843, 2.726387536514119, 2.6777020447906525, 2.5803310613437196, 2.5803310613437196, 2.5803310613437196, 2.5803310613437196, 2.5316455696202533, 2.5316455696202533, 2.5316455696202533, 2.5316455696202533, 2.5316455696202533, 2.5316455696202533, 2.4829600778967866, 2.4829600778967866, 2.4342745861733204, 2.385589094449854, 2.385589094449854, 2.288218111002921, 2.190847127555988, 2.190847127555988, 2.190847127555988, 2.190847127555988, 2.142161635832522, 2.142161635832522, 2.0934761441090557, 2.0934761441090557, 2.0934761441090557, 2.0934761441090557, 2.0934761441090557, 2.0934761441090557, 2.0934761441090557, 2.142161635832522, 2.0934761441090557, 2.044790652385589, 2.044790652385589, 2.044790652385589, 2.044790652385589, 2.044790652385589, 2.044790652385589, 2.044790652385589, 1.9474196689386563, 1.9474196689386563, 1.8987341772151898, 1.8500486854917235, 1.8500486854917235, 1.801363193768257, 1.801363193768257, 1.7526777020447906, 1.7526777020447906, 1.7526777020447906, 1.7526777020447906, 1.7526777020447906, 1.7526777020447906, 1.7039922103213243, 1.7039922103213243, 1.6553067185978578, 1.7039922103213243, 1.6553067185978578, 1.6553067185978578, 1.6066212268743914, 1.6066212268743914, 1.6066212268743914, 1.6066212268743914, 1.6066212268743914, 1.557935735150925, 1.557935735150925, 1.557935735150925, 1.4605647517039921, 1.4118792599805259, 1.3631937682570594, 1.3631937682570594, 1.3631937682570594, 1.3631937682570594, 1.2658227848101267, 1.2658227848101267, 1.2658227848101267, 1.2171372930866602, 1.2171372930866602, 1.2171372930866602, 1.1684518013631937, 1.1684518013631937, 1.1684518013631937, 1.1197663096397275, 1.1197663096397275, 1.1197663096397275, 1.1197663096397275, 1.1197663096397275, 1.1197663096397275, 1.1197663096397275, 1.071080817916261, 1.071080817916261, 1.071080817916261, 1.071080817916261, 1.071080817916261, 1.0223953261927945, 1.0223953261927945, 1.0223953261927945, 0.9737098344693281, 0.9737098344693281]
    else:
        rows = load_solver_summary(cfg, Z3_4_12_1, skip)
        categories = mp_get_all_cutoff_categories(classifier, rows, cutoffs, perturbs)
        total = len(rows)
        untables = [percentage(len(categories[i]["unstable"]), total) for i in cutoffs]
        unsolvables = [percentage(len(categories[i]["unsolvable"]), total) for i in cutoffs]

        diffs = [[] for _ in steps]
        for j, step in enumerate(steps):
            changes = []
            for i in cutoffs:
                if i + step > cutoffs[-1]:
                    continue
                curr = categories[i]
                next = categories[i+step]
                changes.append(percentage(len(curr["unstable"].intersection(next["unstable"])), total))
            diffs[j] = changes

        print("diffs = ", diffs)
        print("untables = ", untables)
        print("unsolvables = ", unsolvables)

    sp.plot(cutoffs, unsolvables,
            label=r"\texttt{unsolvable}",color=PERTURBATION_COLORS["unsolvable"], linewidth=1.5)
    sp.plot(cutoffs, untables,
            label=r"\texttt{unstable}" + "(+0s)", color=PERTURBATION_COLORS["unstable"], linewidth=1.5)
    
    step_colors = ["#A6BDD7", "#817066", "#F6768E"]

    for j, step in enumerate(steps):
        changes = diffs[j]
        sp.plot(cutoffs[:len(changes)], changes,
                label= r"\texttt{unstable}" + f"(+{step}s)",  linestyle='--', color=step_colors[j], linewidth=1.5)
        sp.vlines(cutoffs[-1]-step,
                ymin=0, ymax=changes[-1], linestyle='--', color=step_colors[j], linewidth=1.5)
    # sp.legend(loc='upper center', ncol=3, fancybox=True, shadow=True,bbox_to_anchor=(0.5, 1.15))

    sp.set_xlim(left=min(cutoffs), right=max(cutoffs))
    sp.set_xticks([10, 30, 60, 90, 120, 150])
    sp.set_title(f"{PNAMES[name]} {Z3_4_12_1.pstr()}", fontsize=FSIZE, fontname=FNAME)

def plot_ext_cutoff(cfg):
    figure, axis = plt.subplots(1, 1)
    figure.set_size_inches(7, 3)
    _plot_ext_cutoff(cfg, axis)
    # axis.legend(ncol=3)
    axis.legend(ncol=3)
    axis.set_ylim(bottom=0)
    name = cfg.qcfg.name
    plt.ylabel(r"proportion of queries ($\%$)", fontsize=FSIZE, fontname=FNAME)
    plt.xlabel("time limit (seconds)", fontsize=FSIZE, fontname=FNAME) 
    plt.tight_layout()
    plt.savefig(f"fig/time_cutoff/{name}_ext.pdf")
    plt.close()

def plot_vbkv_ext_cutoff():
    figure, axis = plt.subplots(2, 1)
    figure.set_size_inches(7, 6)

    _plot_ext_cutoff(D_KOMODO_CFG, axis[0])
    _plot_ext_cutoff(D_FVBKV_CFG, axis[1])
    
    axis[1].set_ylim(bottom=0, top=8)
    axis[1].legend()
    
    figure.supylabel(r"proportion of queries ($\%$)", fontsize=FSIZE, fontname=FNAME)
    figure.supxlabel("time limit (seconds)", fontsize=FSIZE, fontname=FNAME) 
    plt.tight_layout()
    
    # sp.legend(loc='upper center', ncol=3, fancybox=True, shadow=True,bbox_to_anchor=(0.5, 1.15))
    plt.savefig(f"fig/time_cutoff/VBKV_ext.pdf")
    plt.close()

pert_map = {
    "shuffle": r"shuffling",
    "rseed": r"reseeding",
    "rename": r"renaming",
}

def plot_pert_diff(cfg):
    perturbs = [str(p) for p in cfg.qcfg.enabled_muts]
    name = cfg.qcfg.name

    skip = get_unknowns(cfg)
    figure, axis = plt.subplots(1, 2)
    figure.set_size_inches(7, 3.5)

    cutoffs = np.arange(10, 61, 0.5)

    classifier = Classifier("z_test")
    top = 0
    solver = Z3_4_12_1
    rows = load_solver_summary(cfg, solver, skip)
    for si, solver in enumerate([cfg.qcfg.project.orig_solver, Z3_4_12_1]):
        rows = load_solver_summary(cfg, solver, skip)
        total = len(rows)
        sp = axis[si]

        categories = mp_get_all_cutoff_categories(classifier, rows, cutoffs, perturbs)
        keys = ["unstable"] + perturbs + ["unsolvable", "intersect"]
        points = {p:[] for p in keys}

        for j in cutoffs:
            for k, v in categories[j].items():
                points[k].append(percentage(len(v), total))

        for k in points:
            if k == "unsolvable":
                continue
            l = pert_map[k] if k in pert_map else k
            if k == "unstable":
                l = r"\texttt{unstable}" + "(all methods)"
            sp.plot(cutoffs, points[k], label=l, color=PERTURBATION_COLORS[k], linewidth=1.5)
            top = max(top, max(points[k]))

        sp.set_xlim(left=min(cutoffs), right=60)
        # sp.set_xticks([15, 30, 45, 60])
        sp.set_title(f"{ PNAMES[name]} {solver.pstr()}", fontsize=FSIZE, fontname=FNAME)

    axis[0].set_ylim(bottom=0, top=top)
    axis[1].set_ylim(bottom=0, top=top)
    # axis[i].set_xticks([min(cutoffs)] + np.arange(30, 6, 30).tolist() + [max(cutoffs)])
    axis[0].legend()

    figure.supylabel(r"proportion of queries ($\%$)", fontsize=FSIZE, fontname=FNAME)
    figure.supxlabel("time limit (seconds)", fontsize=FSIZE, fontname=FNAME)
    plt.tight_layout()

    plt.savefig(f"fig/pert_diff/{name}.pdf")
    plt.close()

def plot_sr_cdf(cfg):
    perturbs = [str(p) for p in cfg.qcfg.enabled_muts]
    name = cfg.qcfg.name
    from matplotlib.pyplot import figure
    figure(figsize=(7, 3.5))
    skip = get_unknowns(cfg)

    for solver in Z3_SOLVERS_ALL:
        rows = load_solver_summary(cfg, solver, skip)
        dps = np.zeros((len(rows), 3))
        for query_row in rows:
            # plain_path = query_row[0]
            group_blobs = query_row[2]
            # ress = set()
            plain_res = group_blobs[0][0][0]

            success = 0
            for k, p in enumerate(perturbs):
                success += count_within_timeout(group_blobs[k], RCode.UNSAT, timeout=6e4)
                
            if plain_res == RCode.UNSAT.value:
                # do not double count
                success -= 2

            # msr2 = min(msr2, sr2)
            dps[rows.index(query_row), 0] = percentage(success, 181)
            # dps[rows.index(query_row), 1] = percentage(msr2, 61)
        xs, ys = get_cdf_pts(dps[:,0])
        plt.scatter(xs, ys, label=solver.pstr(), marker=".", s=8)
    plt.ylim(bottom=0, top=12)
    plt.xlim(left=0, right=100)    
    plt.title(f"{PNAMES[name]}", fontsize=FSIZE, fontname=FNAME)
    plt.xlabel(r"success rate ($\%$)", fontsize=FSIZE, fontname=FNAME)
    plt.ylabel(r"cumulative proportion of queries ($\%$)", fontsize=FSIZE, fontname=FNAME)
    plt.tight_layout()
    plt.legend(ncols=2)
    plt.savefig(f"fig/sr_cdf/{name}.pdf")
    plt.close()

def plot_time_std(cfg):
    perturbs = [str(p) for p in cfg.qcfg.enabled_muts]
    name = cfg.qcfg.name

    skip = get_unknowns(cfg)
    figure, axis = plt.subplots(1, 2)
    figure.set_size_inches(7.5, 3.5)
  
    classifier = Classifier("z_test")
    classifier.timeout = 6e4 # 1 min

    std_max = 0
    y_bound = 0
    for i, solver in enumerate([cfg.qcfg.project.orig_solver, Z3_4_12_1]):
        rows = load_solver_summary(cfg, solver, skip)
        items = categorize_queries(rows, classifier)
        stables = items['stable']

        sp = axis[i]
        dps = [[], [], []]
        for query_row in rows:
            query_path = query_row[0]
            if query_path not in stables:
                continue
            group_blobs = query_row[2]

            for k, p in enumerate(perturbs):
                ts = group_blobs[k][1] 
                bs = np.clip(ts, 0, 60e3) / 1000
                dps[k].append(np.std(bs))

        for i in range(3):
            xs, ys = get_cdf_pts(dps[i])
            ys = np.flip(ys)
            try:
                start = np.where(xs > 1)[0][0]
            except:
                start = 0
            y_bound = max(ys[start], y_bound)
            std_max = max(std_max, max(xs))
            l = pert_map[perturbs[i]]
            sp.plot(xs, ys, label=l, color=PERTURBATION_COLORS[perturbs[i]])
        sp.set_title(f"{PNAMES[name]} {solver.pstr()}", fontsize=FSIZE, fontname=FNAME)

    axis[0].legend()
    
    for i in range(2):
        axis[i].set_xlim(left=1, right=std_max)
        axis[i].set_xticks([1] + [i for i in range(5, int(std_max), 5)])
        axis[i].set_ylim(bottom=0, top=y_bound)

    # print(std_max, y_bound)
    # std_max = 0
    # y_bound = 0

    # cfg = D_FVBKV_CFG

    # name = cfg.qcfg.name
    # skip = get_unknowns(cfg)

    # for i, solver in enumerate([cfg.qcfg.project.orig_solver, Z3_4_12_1]):
    #     rows = load_solver_summary(cfg, solver, skip)
    #     items = categorize_queries(rows, classifier)
    #     stables = items['stable']

    #     sp = axis[1][i]
    #     dps = [[], [], []]
    #     for query_row in rows:
    #         query_path = query_row[0]
    #         if query_path not in stables:
    #             continue
    #         group_blobs = query_row[2]

    #         for k, p in enumerate(perturbs):
    #             ts = group_blobs[k][1] 
    #             bs = np.clip(ts, 0, 60e3) / 1000
    #             dps[k].append(np.std(bs))

    #     for i in range(3):
    #         xs, ys = get_cdf_pts(dps[i])
    #         ys = np.flip(ys)
    #         try:
    #             start = np.where(xs > 1)[0][0]
    #         except:
    #             start = 0
    #         y_bound = max(ys[start], y_bound)
    #         std_max = max(std_max, max(xs))
    #         l = pert_map[perturbs[i]]
    #         sp.plot(xs, ys, label=l, color=PERTURBATION_COLORS[perturbs[i]])
    #     sp.set_title(f"{PNAMES[name]} {solver.pstr()}", fontsize=FSIZE, fontname=FNAME)

    # for i in range(2):
    #     axis[1][i].set_xlim(left=1, right=std_max)
    #     axis[1][i].set_xticks([1] + [i for i in range(5, int(std_max), 5)])
    #     axis[1][i].set_ylim(bottom=0, top=y_bound)

    # print(std_max, y_bound)

    # cfg = D_LVBKV_CFG
    # std_max = 0
    # y_bound = 0

    # name = cfg.qcfg.name
    # skip = get_unknowns(cfg)

    # for i, solver in enumerate([cfg.qcfg.project.orig_solver, Z3_4_12_1]):
    #     rows = load_solver_summary(cfg, solver, skip)
    #     items = categorize_queries(rows, classifier)
    #     stables = items['stable']

    #     sp = axis[2][i]
    #     dps = [[], [], []]
    #     for query_row in rows:
    #         query_path = query_row[0]
    #         if query_path not in stables:
    #             continue
    #         group_blobs = query_row[2]

    #         for k, p in enumerate(perturbs):
    #             ts = group_blobs[k][1] 
    #             bs = np.clip(ts, 0, 60e3) / 1000
    #             dps[k].append(np.std(bs))

    #     for i in range(3):
    #         xs, ys = get_cdf_pts(dps[i])
    #         ys = np.flip(ys)
    #         try:
    #             start = np.where(xs > 1)[0][0]
    #         except:
    #             start = 0
    #         y_bound = max(ys[start], y_bound)
    #         std_max = max(std_max, max(xs))
    #         l = pert_map[perturbs[i]]
    #         sp.plot(xs, ys, label=l, color=PERTURBATION_COLORS[perturbs[i]])
    #     sp.set_title(f"{PNAMES[name]} {solver.pstr()}", fontsize=FSIZE, fontname=FNAME)

    # for i in range(2):
    #     axis[2][i].set_xlim(left=1, right=std_max)
    #     axis[2][i].set_xticks([1] + [i for i in range(5, int(std_max), 5)])
    #     axis[2][i].set_ylim(bottom=0, top=y_bound)
    # print(std_max, y_bound)

    figure.supylabel(r"proportion of queries" "\n" r"above threshold ($\%$)", fontsize=FSIZE, fontname=FNAME)
    figure.supxlabel("time standard deviation (seconds)", fontsize=FSIZE, fontname=FNAME)
    plt.tight_layout()
    plt.savefig(f"fig/time_stable/{name}.pdf")
    plt.close()    

def export_timeouts(cfg, solver):
    con, cur = get_cursor(cfg.qcfg.db_path)
    solver_table = cfg.qcfg.get_solver_table_name(solver)

    if not check_table_exists(cur, solver_table):
        print(f"[WARN] export timeout: {solver_table} does not exist!")
        con.close()
        return
    clean_dir = cfg.qcfg.project.clean_dirs[solver]
    assert clean_dir.endswith("/")
    target_dir = clean_dir[:-1] + "_"+ str(solver) + "_ext/"

    res = cur.execute(f"""
        SELECT vanilla_path, perturbation, command FROM {solver_table}
        WHERE result_code = "timeout" """)

    rows = res.fetchall()
    # print(len(rows))

    for row in rows:
        vanilla_path = row[0]
        perturb = row[1]
        assert vanilla_path.endswith(".smt2")
        assert vanilla_path.startswith(clean_dir)
        stemed = vanilla_path[len(clean_dir):-5]
        command = row[2]
        [solver_path, mut_path, limit] = command.split(" ")
        index = mut_path.index(stemed) + len(stemed)
        info = mut_path[index:].split(".")
        # print(vanilla_path)
        if perturb is None:
            command = f"cp {vanilla_path} {target_dir}"
        else:
            seed = int(info[1])
            assert perturb == info[2]
            file_name = f"{str(seed)}.{perturb}.smt2"
            mutant_path = target_dir + stemed + "." + file_name
            command = f"./target/release/mariposa -i {vanilla_path} -p {perturb} -o {mutant_path} -s {seed}"
        print(command)

    con.close()

def plot_query_sizes(cfgs):
    import os
    # figure, axis = setup_fig(1, 2)
    colors = get_color_map([cfg.qcfg.name for cfg in cfgs])

    for cfg in cfgs:
        clean_dir = cfg.qcfg.project.clean_dirs[Z3_4_12_1]
        paths = list_smt2_files(clean_dir)
        sizes = [] 
        for path in paths:
            sizes.append(os.path.getsize(path) / 1024)
        n = len(sizes)
        label = cfg.qcfg.name
        color = colors[label]
        plt.plot(np.sort(sizes), np.arange(n), marker=".", label=label, color=color)

    plt.legend()
    plt.xscale("log")
    plt.ylabel("cumulative count")
    plt.xlabel("query size KB (log scale)")

    plt.tight_layout()
    plt.savefig("fig/sizes.pdf")

def async_mp_categorize_project(ratios, key, classifier, rows):
    items = categorize_queries(rows, classifier)
    ps, _ = get_category_percentages(items)
    ratios[key] = ps

def mp_categorize_projects(cfgs, classifier, solver_names):
    import multiprocessing as mp
    manager = mp.Manager()
    ratios = manager.dict()
    
    for cfg in cfgs:
        summaries = load_solver_summaries(cfg)
        pool = mp.Pool(processes=8)
        for solver in solver_names:
            key = (cfgs.index(cfg), solver_names.index(solver))
            rows = summaries[solver]
            pool.apply_async(async_mp_categorize_project, 
                            args=(ratios, key, classifier, rows,))
        pool.close()
        pool.join()

    category_count = len(Stablity)
    data = np.zeros((len(cfgs), len(solver_names), category_count))

    for key in ratios:
        i, j = key
        data[i][j] = [ratios[key][s] for s in Stablity]

    return data

def dump_all(cfgs=ALL_CFGS):
    project_names = [cfg.qcfg.name for cfg in cfgs]
    solver_names = [str(s) for s in Z3_SOLVERS_ALL]

    classifier = Classifier("z_test")
    classifier.timeout = 6e4 # 1 min
    # classifier.res_stable = 80
    # data = mp_categorize_projects(cfgs, classifier, solver_names)
    data = [[[0.0, 0.48685491723466406, 0.43816942551119764, 0.7789678675754625, 98.29600778967868], [0.0, 0.5842259006815969, 0.5842259006815969, 0.6329113924050633, 98.19863680623175], [0.0, 0.6329113924050633, 0.2921129503407984, 0.5842259006815969, 98.49074975657254], [0.0, 0.5355404089581305, 0.3894839337877313, 0.2921129503407984, 98.78286270691333], [0.0, 1.7526777020447906, 2.288218111002921, 1.2171372930866602, 94.74196689386562], [0.0, 2.5803310613437196, 4.625121713729309, 1.3631937682570594, 91.43135345666991], [0.0, 2.4342745861733204, 4.430379746835443, 1.2171372930866602, 91.91820837390458], [0.0, 2.5316455696202533, 5.0146056475170395, 1.071080817916261, 91.38266796494645]], [[0.0, 0.258732212160414, 0.6468305304010349, 0.0, 99.09443725743856], [0.0, 0.258732212160414, 0.6468305304010349, 0.0, 99.09443725743856], [0.0, 0.129366106080207, 0.6468305304010349, 0.0, 99.22380336351875], [0.0, 0.0, 0.38809831824062097, 0.0, 99.61190168175938], [0.0, 0.0, 0.129366106080207, 0.0, 99.87063389391979], [0.0, 0.258732212160414, 0.258732212160414, 0.0, 99.48253557567917], [0.0, 0.258732212160414, 0.258732212160414, 0.0, 99.48253557567917], [0.0, 0.129366106080207, 0.517464424320828, 0.0, 99.35316946959897]], [[0.0, 0.5755395683453237, 0.28776978417266186, 0.1618705035971223, 98.9748201438849], [0.0, 0.5575539568345323, 0.3237410071942446, 0.12589928057553956, 98.99280575539568], [0.0, 0.3597122302158273, 0.8812949640287769, 0.0539568345323741, 98.70503597122303], [0.0, 0.3057553956834532, 0.4856115107913669, 0.0539568345323741, 99.15467625899281], [0.0, 0.4136690647482014, 2.949640287769784, 0.1079136690647482, 96.52877697841727], [0.0, 0.5575539568345323, 3.2014388489208634, 0.17985611510791366, 96.06115107913669], [0.0, 0.5215827338129496, 3.3633093525179856, 0.1618705035971223, 95.95323741007195], [0.0, 0.539568345323741, 3.147482014388489, 0.1618705035971223, 96.15107913669065]], [[0.0, 0.6011647567161376, 0.7138831486004134, 0.3569415743002067, 98.32801052038324], [0.0, 0.6011647567161376, 0.7702423445425511, 0.1690775878264137, 98.4595153109149], [0.0, 0.1690775878264137, 0.6199511553635169, 0.1690775878264137, 99.04189366898366], [0.0, 0.3381551756528274, 0.7138831486004134, 0.1502911891790344, 98.79767048656772], [0.0, 0.375727972947586, 2.536163817396205, 0.5072327634792411, 96.58087544617696], [0.0, 0.6763103513056548, 3.1373285741123427, 0.3381551756528274, 95.84820589892918], [0.0, 0.563591959421379, 3.118542175464963, 0.3381551756528274, 95.97971068946083], [0.0, 0.563591959421379, 2.911891790343791, 0.3381551756528274, 96.18636107458201]], [[0.0, 1.3201320132013201, 0.33003300330033003, 0.132013201320132, 98.21782178217822], [0.0, 1.2541254125412542, 0.33003300330033003, 0.132013201320132, 98.28382838283828], [0.0, 1.1221122112211221, 0.39603960396039606, 0.132013201320132, 98.34983498349835], [0.0, 0.594059405940594, 0.528052805280528, 0.132013201320132, 98.74587458745874], [0.0, 0.9240924092409241, 0.528052805280528, 0.264026402640264, 98.28382838283828], [0.0, 1.386138613861386, 0.6600660066006601, 0.0, 97.95379537953795], [0.0, 1.056105610561056, 0.594059405940594, 0.264026402640264, 98.08580858085809], [0.0, 0.9240924092409241, 0.7920792079207921, 0.132013201320132, 98.15181518151815]], [[0.0, 0.3462204270051933, 0.17311021350259664, 0.0, 99.48066935949221], [0.0, 0.3462204270051933, 0.17311021350259664, 0.0, 99.48066935949221], [0.0, 0.05770340450086555, 0.1154068090017311, 0.0, 99.8268897864974], [0.0, 0.0, 0.05770340450086555, 0.0, 99.94229659549913], [0.0, 0.17311021350259664, 0.4039238315060589, 0.0, 99.42296595499134], [0.0, 0.1154068090017311, 0.3462204270051933, 0.0, 99.53837276399308], [0.0, 0.0, 0.28851702250432776, 0.0, 99.71148297749568], [0.0, 0.05770340450086555, 0.2308136180034622, 0.0, 99.71148297749568]]]
    data = np.array(data)
    # print(data.tolist())
    # return 

    bar_width = len(solver_names)/70
    fig, ax = plt.subplots()
    fig.set_size_inches(7, 4.5)

    br = np.arange(len(solver_names))
    br = [x - 2 * bar_width for x in br]

    # data[project_index][solver_index][category_index]
    handles = []
    print(np.round(data[:,-1], 1))

    for pi, project_row in enumerate(data):
        pcs = np.zeros((len(Stablity), len(solver_names)))

        br = [x + bar_width for x in br]
        for i, ps in enumerate(project_row):
            pcs[:, i] = ps
        pcolor = PROJECT_COLORS[project_names[pi]]
        pcs = np.cumsum(pcs,axis=0)

        plt.bar(br, height=pcs[1], width=bar_width,
                color=pcolor, alpha=0.40, edgecolor='black', linewidth=0.2)
        hd = plt.bar(br, height=pcs[2]-pcs[1], bottom=pcs[1], width=bar_width,
                color=pcolor, edgecolor='black', linewidth=0.2)
        handles.append(hd)
        plt.bar(br, height=pcs[3]-pcs[2], bottom=pcs[2], width=bar_width,
                color="w", edgecolor='black', linewidth=0.2)

        for i in range(len(solver_names)):
            if solver_names[i] == str(cfgs[pi].qcfg.project.orig_solver):
                plt.scatter(br[i], pcs[3][i] + 0.2, marker="*", color='black',  linewidth=0.8, s=10)
            # if i == 4 and pi == 0:
            #     plt.bar(br[i], height=20, bottom=pcs[3][i], width=bar_width, 
            #             color='white', edgecolor='black', linewidth=0.3, linestyle=(0, (1, 5)))

    label_x = 2.85
    leable_y = 5
    ls = (0, (1, 5))
    
    plt.text(label_x, leable_y, r'\texttt{unsolvable}', horizontalalignment='right')
    plt.plot([label_x + 0.05, 3.88], [leable_y + 0.05, 1.0], 
             'o', ls=ls, color='black', linewidth=0.5, ms=1)
    leable_y += 0.8
    plt.text(label_x, leable_y, r'\texttt{unstable}', horizontalalignment='right')
    plt.plot([label_x + 0.05, 3.88], [leable_y + 0.05, 2.7],
             'o', ls=ls, color='black', linewidth=0.5, ms=1)
    leable_y += 0.8
    plt.text(label_x, leable_y, r'\texttt{inconclusive}', horizontalalignment='right')
    plt.plot([label_x + 0.05, 3.88], [leable_y + 0.05, 4.7],
             'o', ls=ls, color='black', linewidth=0.5, ms=1)
    # plt.text(3.5, 5.45, r'\texttt{stable}' + "\n" + r"stack up to 100\%" + "\n" + "(unplotted)", horizontalalignment='right')
    # plt.plot([3.55, 3.88], [6.40, 6.75], 'o', ls='-', color='black', linewidth=0.2, ms=2)

    solver_lables = [f"{s.pstr()}\n{s.data[:-3]}" for s in Z3_SOLVERS_ALL]
    ax.tick_params(axis='both', which='major')
    plt.xticks([r + 2 * bar_width for r in range(len(solver_names))], solver_lables, rotation=30, ha='right')
    from matplotlib.lines import Line2D
    woot = Line2D([0], [0], marker="*", color='black', linestyle='None', label='artifact solver'),
    plt.legend(handles + [woot],  [PNAMES[p] for p in project_names] + ['artifact solver'])
    plt.ylabel(r'query proportion ($\%$)', fontsize=FSIZE, fontname=FNAME)
    plt.xlabel('solver versions and release dates', fontsize=FSIZE, fontname=FNAME)
    plt.ylim(bottom=0, top=9)
    plt.tight_layout()
    plt.savefig("fig/all.pdf")
    plt.close()

def compare_vbkvs(linear, dynamic):
    dfiles, lfiles = set(), set()
    for k, v in FILE_MAP.items():
        dfiles |= set(v[0])
        lfiles |= set(v[1])
    # print(len(lfiles))
    # print(len(dfiles))

    classifier = Classifier("z_test")
    classifier.timeout = 61e4
    # th.unsolvable = 20
    # th.res_stable = 80

    l_filtered = set()
    for query in linear.samples[Z3_4_12_1]:
        for f in lfiles:
            if "-" + f in query:
                l_filtered.add(query)
    d_filtered = set()
    for query in dynamic.samples[Z3_4_12_1]:
        for f in dfiles:
            if "-" + f in query:
                d_filtered.add(query)
                break

    print(len(l_filtered))
    print(len(d_filtered))

    # data = np.zeros((4, len(Stablity)))

    l_summary = load_solver_summary(linear, Z3_4_12_1, get_unknowns(linear))
    # l_categories = categorize_queries(l_summary, classifier)
    pts = []
    xs = []
    ys = []
    maybes = 0

    for query_row in l_summary:
        # if query_row[0] not in l_filtered:
        #     continue
        group_blobs = query_row[2]
        res = classifier.categorize_query(group_blobs, None)

        if res != Stablity.STABLE:
            continue
        
        mean = 0
        std = 0
        
        for i in range(3):
            times = group_blobs[:,1][i]
            times = np.clip(times, 0, 6e4) / 1000
            cur = np.std(times)
            if std < cur:
                mean = np.mean(times)
                std = cur
        
        if std < 1 and mean > 15:
            maybes += 1
        
        xs.append(mean)
        ys.append(std)

    plt.scatter(xs, ys, label="linear", s=2, alpha=0.5)
    print(maybes)

    maybes = 0

    d_summary = load_solver_summary(dynamic, Z3_4_12_1, get_unknowns(dynamic))

    xs = []
    ys = []
    for query_row in d_summary:
        # if query_row[0] not in d_filtered:
        #     continue
        group_blobs = query_row[2]
        res = classifier.categorize_query(group_blobs, None)

        if res != Stablity.STABLE:
            continue
        
        mean = 0
        std = 0
        
        for i in range(3):
            times = group_blobs[:,1][i]
            times = np.clip(times, 0, 6e4) / 1000
            cur = np.std(times)
            if std < cur:
                mean = np.mean(times)
                std = cur
        
        if std < 1 and mean > 15:
            maybes += 1
        
        xs.append(mean)
        ys.append(std)

    plt.scatter(xs, ys, label="dynamic", marker="x", s=2)
    plt.xlim(left=1)
    print(maybes)
    
    # print(len(d_summary))
    # pts = []
    # # d_categories = categorize_queries(d_summary, classifier)
    # for query_row in d_summary:
    #     if query_row[0] not in d_filtered:
    #         continue
    #     group_blobs = query_row[2] 
    #     if group_blobs[0][0][0] == RCode.UNSAT.value:
    #         pts.append(group_blobs[0][1][0] / 1000)
        
    # xs, ys = get_cdf_pts(pts)
    # # ys = np.flip(ys)
    # plt.plot(xs, ys, label="dynamic")
    # plt.xlim(left=5)
    # plt.ylim(bottom=98, top=100)

    plt.legend()
    plt.tight_layout()
    plt.savefig("fig/compare.pdf")

from scipy.stats import gaussian_kde
from statsmodels.stats import weightstats

def _plot_time_scatter(cfg, sp):
    summaries = load_solver_summaries(cfg)
    solver = Z3_4_12_1
    rows = summaries[solver]
    pf, cfs = 0, 0
    ps, css = 0, 0

    classifier = Classifier("z_test")
    cats = {i: [] for i in Stablity }

    scatters = np.zeros((len(rows), 2))
    for i, query_row in enumerate(rows):
        group_blobs = query_row[2]

        plain_res = group_blobs[0][0][0]
        plain_time = group_blobs[0][1][0]
        mutants = np.hstack((group_blobs[0,:,1:], group_blobs[1,:,1:], group_blobs[2,:,1:]))

        cat = classifier.categorize_query(group_blobs)
        cats[cat].append(i)

        valid_indices = mutants[0] == RCode.UNSAT.value
        success = np.sum(valid_indices)
        ts = np.median(mutants[1])
    
        if plain_res != RCode.UNSAT.value:
            pf += 1
            if success == 0:
                cfs += 1
        else:
            ps += 1
            if success == 180:
                css += 1
            # if success < 100:
            #     print(mutants[0])
            #     print(mutants[1]/1000)
            #     print(query_row[0])
            #     print("????")
        scatters[i][0] = plain_time/1000
        scatters[i][1] = ts/1000
    
    stables = cats[Stablity.STABLE]
    unstables = cats[Stablity.UNSTABLE]
    unsolvables = cats[Stablity.UNSOLVABLE] + cats[Stablity.UNKNOWN]
    inconclusives = cats[Stablity.INCONCLUSIVE]
    # others = list(set(range(len(rows))) - set(cats[Stablity.STABLE]) - set(cats[Stablity.UNSTABLE]))
    
    handles = []
    
    sp.scatter(scatters[:,0][stables], scatters[:,1][stables], s=8, color="#78A1BB", label=r"\texttt{stable}")
    sp.scatter(scatters[:,0][unstables], scatters[:,1][unstables], s=8, color="orange", label=r"\texttt{unstable}")
    sp.scatter(scatters[:,0][unsolvables], scatters[:,1][unsolvables], s=8, color="r", marker="s", label=r"\texttt{unsolvable}")
    sp.scatter(scatters[:,0][inconclusives], scatters[:,1][inconclusives], s=8, label=r"\texttt{inconclusive}")
    
    # sp.scatter(scatters[:,0][[cats[Stablity.Unk]], scatters[:,1][others], s=8, label="others")
    # print(pf, cfs, ps, css)
    # print(percentage(bounded, len(scatters)), mworse, len(scatters))
    # print(weightstats.ttost_paired(np.array(ys), np.array(xs), -0.57, -0.03))
    # print(weightstats.ttost_paired(np.array(ys), np.array(xs), 1.002, 1.015, transform=np.log))
    sp.fill_between([0.01, 1000],  [0.01 * 1.5, 1000 * 1.5], [0.01, 1000], alpha=0.1, color="green", label=r"$\frac{x}{1.5} < y < 1.5x$")
    sp.fill_between([0.01, 1000],  [0.01, 1000], [0.01 / 1.5, 1000 / 1.5], alpha=0.1, color="green")
    # sp.loglog([0.01, 1000], [0.01, 1000], color="black", linestyle="--",linewidth=0.75)
    sp.set_xlim(left=.1, right=160)
    sp.set_ylim(bottom=.1, top=160)
    sp.set_xscale("log")
    sp.set_yscale("log")
    handles, labels = sp.get_legend_handles_labels()
    order = [2,1,0,3, 4]
    sp.legend([handles[idx] for idx in order],[labels[idx] for idx in order])
    sp.set_aspect('equal', adjustable='box')
    title = f"{PNAMES[cfg.qcfg.name]} {solver.pstr()}"
    sp.set_title(title, fontsize=FSIZE, fontname=FNAME)

def plot_time_scatter(cfg):
    figure, axis = setup_fig(1, 1)
    _plot_time_scatter(cfg, axis)
    name = cfg.qcfg.name
    axis.set_xlabel("median mutant time (seconds)", fontsize=FSIZE, fontname=FNAME)
    axis.set_ylabel("original query time (seconds)", fontsize=FSIZE, fontname=FNAME)
    plt.tight_layout()
    plt.savefig(f"fig/time_scatter/{name}.pdf")
    plt.close()

def plot_time_scatter_paper():
    figure, axis = plt.subplots(1, 2)
    figure.set_size_inches(7, 4)
    _plot_time_scatter(D_KOMODO_CFG, axis[0])
    _plot_time_scatter(FS_VWASM_CFG, axis[1])
    
    figure.supxlabel("original time (seconds)", fontsize=FSIZE, fontname=FNAME)
    figure.supylabel("median mutant time (seconds)", fontsize=FSIZE, fontname=FNAME)
    plt.tight_layout()
    plt.savefig(f"fig/time_scatter/scatter.pdf")
    plt.close()

def create_benchmark(cfgs=ALL_CFGS):
    benchmark_path = "data/benchmarks"
    
    unstable_core_path = f"{benchmark_path}/unstable_core"
    unstable_ext_path = f"{benchmark_path}/unstable_ext"
    stable_core_path = f"{benchmark_path}/stable_core"
    stable_ext_path = f"{benchmark_path}/stable_ext"

    os.system(f"mkdir -p {unstable_core_path}")
    os.system(f"mkdir -p {unstable_ext_path}")
    os.system(f"mkdir -p {stable_core_path}")
    os.system(f"mkdir -p {stable_ext_path}")

    classifier = Classifier("z_test")
    classifier.timeout = 6e4 # 1 min
    # classifier.res_stable = 80
    # thres.time_std = 6e3 # 6 sec
    # data = mp_categorize_projects(cfgs, classifier, solver_names)
    
    for cfg in cfgs:
        print(cfg.get_project_name())
        unkowns = get_unknowns(cfg)
        unss = []
        for solver in [cfg.qcfg.project.orig_solver, Z3_4_12_1]:
            rows = load_solver_summary(cfg, solver, unkowns)
            items = categorize_queries(rows, classifier)
            unss.append(items)
        core = unss[0]['unstable'].intersection(unss[1]['unstable'])
        ext = unss[1]['unstable'] - core
        print("unstable core: ", len(core))
        print("unstable ext:", len(ext))
        
        stables = items['stable']
        
        # stable ext
        maybes = set()
        # stable core
        stable_core = set()

        for query_row in rows:
            query_path = query_row[0]
            if query_path not in stables:
                continue
            group_blobs = query_row[2]

            std = 0
            combined = np.concatenate((group_blobs[:,1][0], group_blobs[:,1][1], group_blobs[:,1][2]))
            std_combined = np.std(combined) / 1000

            # going thru each perturb
            for i in range(3):
                times = group_blobs[:,1][i]
                times = np.clip(times, 0, 6e4) / 1000
                std = max(std, np.std(times))

            # std = np.std(np.clip(group_blobs[0][1], 0, 6e4) / 1000)
            if std > 6:
                maybes.add(query_path)
                    # maybes[query_path] = np.std(bs)
            # std of all groups is less than 1
            elif std_combined < 1:
                stable_core.add(query_path)

        # randomly sample from stable_core:
        random.seed(4)
        sampled_core = random.sample(sorted(list(stable_core)), 30)

        print("stable core:", len(sampled_core), f" (original: {len(stable_core)})")
        print("stable ext:", len(maybes))
        
        DATA_PATH = f"/home/yizhou7/mariposa/"
        
        # add all unstable core 
        for filename in core:
            shutil.copyfile(f"{DATA_PATH}/{filename}", f"{unstable_core_path}/{cfg.get_project_name()}-{filename.split('/')[2]}")
#           print("added: ", filename)
        print("done! added ", len(core), " files!")

        # add all unstable ext
        for filename in ext:
            shutil.copyfile(f"{DATA_PATH}/{filename}", f"{unstable_ext_path}/{cfg.get_project_name()}-{filename.split('/')[2]}")
#           print("added: ", filename)
        print("done! added ", len(ext), " files!")

        # add all stable core
        for filename in sampled_core:
            shutil.copyfile(f"{DATA_PATH}/{filename}", f"{stable_core_path}/{cfg.get_project_name()}-{filename.split('/')[2]}")
#           print("added: ", filename)
        print("done! added ", len(sampled_core), " files!")

        # add all stable ext
        for filename in maybes:
            shutil.copyfile(f"{DATA_PATH}/{filename}", f"{stable_ext_path}/{cfg.get_project_name()}-{filename.split('/')[2]}")
#           print("added: ", filename)
        print("done! added ", len(maybes), " files!")

from scipy.stats import entropy

# def entropy_test():
#     cfg = D_KOMODO_CFG
#     summaries = load_solver_summaries(cfg, skip_unknowns=True)

#     for summary in summaries.values():
#         c = Classifier("z_test")
#         c.timeout = 6e4
#         counts = set()
#         counts2 = set()
#         for row in summary:
#             group_blobs = row[2]
#             max_ent = 0 
#             if c.categorize_query(group_blobs) == Stablity.UNSTABLE:
#                 counts2.add(row[0]) 
#             # entropy([1/2, 1/2], base=2)
#             for i in range(3):
#                 sr = count_within_timeout(group_blobs[i], RCode.UNSAT, 6e4) / 61
#                 max_ent = max(max_ent, entropy([1- sr, sr], base=2))
#             if max_ent >= 0.5:
#                 counts.add(row[0]) 
#         print(len(counts), len(counts2), len(counts.intersection(counts2)))


def count_timeouts(cfg):
    summaries = load_solver_summaries(cfg, skip_unknowns=True)
    c = Classifier("z_test")
    c.timeout = 15e4

    summary = summaries[Z3_4_12_1]
    counts = []
    for row in summary:
        group_blobs = row[2]
        # combined = np.concatenate((group_blobs[:,1][0], group_blobs[0,:,1:][1], group_blobs[0,:,1:][2]))
        if c.categorize_query(group_blobs) != Stablity.UNSTABLE:
            continue

        combined = np.hstack((group_blobs[0,:,:], group_blobs[1,:,1:], group_blobs[2,:,1:]))
        combined = combined.T

        to = 0
        fs = 0
        for (res, time) in combined:
            if time >= 15e4:
                to += 1
                fs += 1
            elif res != RCode.UNSAT.value:
                fs += 1
        if fs == 0:
            continue
        # if to == 0:
        #     print(combined.T)
        counts.append(percentage(to, fs))
    print(np.mean(counts))
        # success = blob[0] == rcode.value
        # none_timeout = blob[1] < timeout
        # success = np.sum(np.logical_and(success, none_timeout))
            
        # count_within_timeout(group_blobs[i], RCode.UNSAT, timeout=6e4)

def locality_analysis(cfg):
    summaries = load_solver_summaries(cfg, skip_unknowns=True)
    c = Classifier("z_test")
    c.timeout = 6e4
    summary = summaries[Z3_4_12_1]
    for row in summary:
        group_blobs = row[2]
        if c.categorize_query(group_blobs) != Stablity.UNSTABLE:
            continue
        fname = row[0].split(".dfy")[0][32:]

        if fname.endswith(".gen"):
            fname = fname.replace(".gen", ".vad")
        if "secprop-" in fname:
            fname = "secprop/" + fname[8:]
        elif "sha-" in fname:
            fname = "sha/" + fname[:]

        if fname.endswith(".gen"):
            fname = fname.replace(".gen", ".vad")
            print(fname)
        else:
            print(fname + ".dfy")
# D_KOMODO
# 92.04350439204808
# D_LVBKV
# 78.97515623111637
# D_FVBKV
# 67.92845101604333
